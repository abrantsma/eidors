<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fwd_model_parameters</title>
  <meta name="keywords" content="fwd_model_parameters">
  <meta name="description" content="FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; fwd_model_parameters.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fwd_model_parameters
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function param = fwd_model_parameters( fwd_model ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)
 Extract parameters from a 'fwd_model' struct which are 
 appropriate for Andy Adler's EIT code
   param.n_elem     =&gt; number of elements
   param.n_elec     =&gt; number of electrodes
   param.n_node     =&gt; number of nodes (vertices)
   param.n_stim     =&gt; number of current stimulation patterns
   param.n_elec     =&gt; number of electrodes
   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)
   param.n_meas     =&gt; number of measurements (total)
   param.boundary   =&gt; FEM boundary
   param.NODE       =&gt; vertex matrix
   param.ELEM       =&gt; connection matrix
   param.QQ         =&gt; Current into each NODE
   param.VOLUME     =&gt; Volume (or area) of each element
   param.normalize  =&gt; difference measurements normalized?
   param.N2E        =&gt; Node to electrode converter

 If the stimulation patterns has a 'interior_sources' field,
   the node current QQ, is set to this value for this stimulation.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>	FIND_ELECTRODE_BDY: find the boundary index area for electrode</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>	AA_FWD_PARAMETERS: data= aa_fwd_solve( fwd_model, image)</li><li><a href="../../../eidors/deprecated/exponential_covar_prior.html" class="code" title="function Reg= exponential_covar_prior( inv_model );">exponential_covar_prior</a>	EXPONENTIAL_COVAR_PRIOR image prior with exponential</li><li><a href="../../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/graphics/matlab/show_slices_move.html" class="code" title="function show_slices_move( img, move, move_scale )">show_slices_move</a>	SHOW_SLICES_MOVE   Shows planar slices of a 3D FEM with movement vectors</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../../eidors/solvers/inverse/inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">inv_solve_abs_core</a>	INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm</li><li><a href="../../../eidors/solvers/inverse/inv_solve_backproj.html" class="code" title="function img= inv_solve_backproj( inv_model, data1, data2)">inv_solve_backproj</a>	INV_SOLVE_BACKPROJ inverse solver using backprojection</li><li><a href="../../../eidors/solvers/inverse/inv_solve_conj_grad.html" class="code" title="function img= inv_solve_conj_grad( inv_model, data1, data2)">inv_solve_conj_grad</a>	INV_SOLVE_CONJ_GRAD inverse solver based on the CG</li><li><a href="../../../eidors/solvers/inverse/inv_solve_diff_kalman.html" class="code" title="function img= inv_solve_diff_kalman( inv_model, data1, data2)">inv_solve_diff_kalman</a>	INV_SOLVE_DIFF_KALMAN inverse solver for difference EIT</li><li><a href="../../../eidors/solvers/inverse/prior_exponential_covar.html" class="code" title="function Reg= prior_exponential_covar( inv_model );">prior_exponential_covar</a>	PRIOR_EXPONENTIAL_COVAR image prior with exponential</li><li><a href="../../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model );">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_time_smooth.html" class="code" title="function Reg= prior_time_smooth( inv_model );">prior_time_smooth</a>	PRIOR_TIME_SMOOTH calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function pp= calc_param( fwd_model )</a></li><li><a href="#_sub2" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a></li><li><a href="#_sub3" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a></li><li><a href="#_sub4" class="code">function [QQ, n_meas] = calc_QQ_slow(N2E, stim, p)</a></li><li><a href="#_sub5" class="code">function [QQ, n_meas] = calc_QQ_fast(N2E, stim, p)</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function param = fwd_model_parameters( fwd_model )</a>
0002 <span class="comment">% FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</span>
0003 <span class="comment">% Extract parameters from a 'fwd_model' struct which are</span>
0004 <span class="comment">% appropriate for Andy Adler's EIT code</span>
0005 <span class="comment">%   param.n_elem     =&gt; number of elements</span>
0006 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0007 <span class="comment">%   param.n_node     =&gt; number of nodes (vertices)</span>
0008 <span class="comment">%   param.n_stim     =&gt; number of current stimulation patterns</span>
0009 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0010 <span class="comment">%   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)</span>
0011 <span class="comment">%   param.n_meas     =&gt; number of measurements (total)</span>
0012 <span class="comment">%   param.boundary   =&gt; FEM boundary</span>
0013 <span class="comment">%   param.NODE       =&gt; vertex matrix</span>
0014 <span class="comment">%   param.ELEM       =&gt; connection matrix</span>
0015 <span class="comment">%   param.QQ         =&gt; Current into each NODE</span>
0016 <span class="comment">%   param.VOLUME     =&gt; Volume (or area) of each element</span>
0017 <span class="comment">%   param.normalize  =&gt; difference measurements normalized?</span>
0018 <span class="comment">%   param.N2E        =&gt; Node to electrode converter</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% If the stimulation patterns has a 'interior_sources' field,</span>
0021 <span class="comment">%   the node current QQ, is set to this value for this stimulation.</span>
0022 
0023 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0024 <span class="comment">% $Id: fwd_model_parameters.m 4833 2015-03-29 21:32:08Z bgrychtol-ipa $</span>
0025 
0026 <span class="keyword">if</span> isstr(fwd_model) &amp;&amp; strcmp(fwd_model, <span class="string">'UNIT_TEST'</span>); <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0027 
0028 copt.fstr = <span class="string">'fwd_model_parameters'</span>;
0029 copt.log_level = 4;
0030 
0031 param = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction pp= calc_param( fwd_model )">calc_param</a>,fwd_model,copt);
0032 
0033 
0034 <span class="comment">% perform actual parameter calculation</span>
0035 <a name="_sub1" href="#_subfunctions" class="code">function pp= calc_param( fwd_model )</a>
0036 
0037 pp.NODE= fwd_model.nodes';
0038 pp.ELEM= fwd_model.elems';
0039 
0040 n= size(pp.NODE,2);        <span class="comment">%NODEs</span>
0041 d= size(pp.ELEM,1);        <span class="comment">%dimentions+1</span>
0042 e= size(pp.ELEM,2);        <span class="comment">%ELEMents</span>
0043 <span class="keyword">try</span>
0044    p = length(fwd_model.stimulation );
0045 <span class="keyword">catch</span> 
0046    p = 0;
0047 <span class="keyword">end</span>
0048 <span class="keyword">try</span>
0049    n_elec= length( fwd_model.electrode );
0050 <span class="keyword">catch</span>
0051    n_elec= 0;
0052    fwd_model.electrode = [];
0053 <span class="keyword">end</span>
0054 
0055 copt.fstr = <span class="string">'element_volume'</span>;
0056 copt.log_level = 4;
0057 pp.VOLUME= <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub2" class="code" title="subfunction VOLUME = element_volume( NODE, ELEM, e, d)">element_volume</a>, {pp.NODE, pp.ELEM, e, d}, copt );
0058 
0059 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'boundary'</span>)
0060     bdy = double( fwd_model.boundary ); <span class="comment">% double because of stupid matlab bugs</span>
0061 <span class="keyword">else</span>
0062     bdy = <a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(fwd_model.elems);
0063 <span class="keyword">end</span>
0064 
0065 <span class="comment">% Matrix to convert Nodes to Electrodes</span>
0066 <span class="comment">% Complete electrode model for all electrodes</span>
0067 <span class="comment">%  N2E = sparse(1:n_elec, n+ (1:n_elec), 1, n_elec, n+n_elec);</span>
0068 <span class="comment">%  pp.QQ= sparse(n+n_elec,p);</span>
0069 copt.cache_obj = {fwd_model.nodes,fwd_model.elems,fwd_model.electrode};
0070 copt.fstr = <span class="string">'calculate_N2E'</span>;
0071 [N2E,cem_electrodes] = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub3" class="code" title="subfunction [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);">calculate_N2E</a>,{fwd_model, bdy, n_elec, n}, copt);
0072 
0073 <span class="keyword">if</span> p&gt;0
0074   stim = fwd_model.stimulation;
0075   [pp.QQ, pp.n_meas] = <a href="#_sub5" class="code" title="subfunction [QQ, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(N2E, stim, p);
0076 <span class="keyword">end</span>
0077 
0078 <span class="comment">% pack into a parameter return list</span>
0079 pp.n_elem   = e;
0080 pp.n_elec   = n_elec;
0081 pp.n_node   = n;
0082 pp.n_stim   = p;
0083 pp.n_dims   = d-1;
0084 pp.N2E      = N2E;
0085 pp.boundary = bdy;
0086 pp.normalize = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(fwd_model);
0087 
0088 
0089 <span class="comment">% calculate element volume and surface area</span>
0090 <a name="_sub2" href="#_subfunctions" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a>
0091    VOLUME=zeros(e,1);
0092    ones_d = ones(1,d);
0093    d1fac = prod( 1:d-1 );
0094    <span class="keyword">if</span> d &gt; size(NODE,1)
0095       <span class="keyword">for</span> i=1:e
0096           this_elem = NODE(:,ELEM(:,i)); 
0097           VOLUME(i)= abs(det([ones_d;this_elem])) / d1fac;
0098       <span class="keyword">end</span>
0099    <span class="keyword">elseif</span> d == 3 <span class="comment">% 3D nodes in 2D mesh</span>
0100       <span class="keyword">for</span> i=1:e
0101           this_elem = NODE(:,ELEM(:,i)); 
0102           d12= det([ones_d;this_elem([1,2],:)])^2;
0103           d13= det([ones_d;this_elem([1,3],:)])^2;
0104           d23= det([ones_d;this_elem([2,3],:)])^2;
0105           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0106       <span class="keyword">end</span>
0107    <span class="keyword">elseif</span> d == 2 <span class="comment">% 3D nodes in 1D mesh (ie resistor mesh)</span>
0108       <span class="keyword">for</span> i=1:e
0109           this_elem = NODE(:,ELEM(:,i)); 
0110           d12= det([ones_d;this_elem([1],:)])^2;
0111           d13= det([ones_d;this_elem([2],:)])^2;
0112           d23= det([ones_d;this_elem([3],:)])^2;
0113           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0114       <span class="keyword">end</span>
0115    <span class="keyword">else</span>
0116       warning(<span class="string">'mesh size not understood when calculating volumes'</span>)
0117       VOLUME = NaN;
0118    <span class="keyword">end</span>
0119    <span class="comment">% calculate element volume and surface area</span>
0120    VOLUME=zeros(e,1);
0121    ones_d = ones(1,d);
0122    d1fac = prod( 1:d-1 );
0123    <span class="keyword">if</span> d &gt; size(NODE,1)
0124       <span class="keyword">for</span> i=1:e
0125           this_elem = NODE(:,ELEM(:,i)); 
0126           VOLUME(i)= abs(det([ones_d;this_elem])) / d1fac;
0127       <span class="keyword">end</span>
0128    <span class="keyword">elseif</span> d == 3 <span class="comment">% 3D nodes in 2D mesh</span>
0129       <span class="keyword">for</span> i=1:e
0130           this_elem = NODE(:,ELEM(:,i)); 
0131           d12= det([ones_d;this_elem([1,2],:)])^2;
0132           d13= det([ones_d;this_elem([1,3],:)])^2;
0133           d23= det([ones_d;this_elem([2,3],:)])^2;
0134           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0135       <span class="keyword">end</span>
0136    <span class="keyword">elseif</span> d == 2 <span class="comment">% 3D nodes in 1D mesh (ie resistor mesh)</span>
0137       <span class="keyword">for</span> i=1:e
0138           this_elem = NODE(:,ELEM(:,i)); 
0139           d12= det([ones_d;this_elem([1],:)])^2;
0140           d13= det([ones_d;this_elem([2],:)])^2;
0141           d23= det([ones_d;this_elem([3],:)])^2;
0142           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0143       <span class="keyword">end</span>
0144    <span class="keyword">else</span>
0145       warning(<span class="string">'mesh size not understood when calculating volumes'</span>)
0146       VOLUME = NaN;
0147    <span class="keyword">end</span>
0148 
0149 
0150 
0151 <a name="_sub3" href="#_subfunctions" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a>
0152    cem_electrodes= 0; <span class="comment">% num electrodes part of Compl. Elec Model</span>
0153    N2E = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(n_elec, n+n_elec);
0154    <span class="keyword">for</span> i=1:n_elec
0155        <span class="keyword">try</span>
0156            elec_nodes = fwd_model.electrode(i).nodes;
0157        <span class="keyword">catch</span>
0158            <span class="keyword">break</span>; <span class="comment">%Not a real electrode so don't include</span>
0159        <span class="keyword">end</span>
0160        <span class="keyword">if</span> length(elec_nodes) ==1 <span class="comment">% point electrode (maybe inside body)</span>
0161           N2E(i, elec_nodes) = 1;
0162        <span class="keyword">elseif</span> length(elec_nodes) ==0
0163           error(<span class="string">'zero length electrode specified'</span>);
0164        <span class="keyword">else</span>
0165           bdy_idx= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, [], elec_nodes);
0166 
0167           <span class="keyword">if</span> ~isempty(bdy_idx) <span class="comment">% CEM electrode</span>
0168              cem_electrodes = cem_electrodes+1;
0169              N2E(i, n+cem_electrodes) =1;
0170           <span class="keyword">else</span> <span class="comment">% point electrodes</span>
0171                <span class="comment">% FIXME: make current defs between point electrodes and CEMs compatible</span>
0172              [bdy_idx,srf_area]= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, <span class="keyword">...</span>
0173                             fwd_model.nodes, elec_nodes);
0174              N2E(i, elec_nodes) = srf_area/sum(srf_area);
0175           <span class="keyword">end</span>
0176        <span class="keyword">end</span>
0177    <span class="keyword">end</span>
0178    N2E = N2E(:, 1:(n+cem_electrodes));
0179 
0180 
0181 <a name="_sub4" href="#_subfunctions" class="code">function [QQ, n_meas] = calc_QQ_slow(N2E, stim, p)</a>
0182    QQ = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),1,p);
0183    n_meas= 0; <span class="comment">% sum total number of measurements</span>
0184    <span class="keyword">for</span> i=1:p
0185        src= zeros(size(N2E,2),1);
0186        <span class="keyword">try</span>;  src =        N2E'* stim(i).stim_pattern; <span class="keyword">end</span>
0187        <span class="keyword">try</span>;  src = src +  stim(i).interior_sources;   <span class="keyword">end</span>
0188        <span class="keyword">if</span> all(size(src) == [1,1]) &amp;&amp; src==0
0189           error(<span class="string">'no stim_patterns or interior_sources provided for pattern #%d'</span>,i);
0190        <span class="keyword">end</span>
0191        
0192        QQ(:,i) = src;
0193        n_meas = n_meas + size(stim(i).meas_pattern,1);
0194    <span class="keyword">end</span>
0195 
0196 <a name="_sub5" href="#_subfunctions" class="code">function [QQ, n_meas] = calc_QQ_fast(N2E, stim, p)</a>
0197    QQ = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),1,p);
0198    <span class="keyword">try</span>
0199    ncols = arrayfun(@(x) size(x.stim_pattern,2), stim);
0200    <span class="keyword">end</span>
0201    <span class="keyword">if</span> any(ncols&gt;1);
0202       str = <span class="string">'multiple columns in stim_pattern for patterns: '</span>;
0203       error(<span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>, <span class="keyword">...</span>
0204             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0205    <span class="keyword">end</span>
0206    idx = 1:p; idx(ncols==0)= [];
0207    <span class="keyword">try</span>
0208    QQ(:,idx) = N2E' * horzcat( stim(:).stim_pattern );
0209    <span class="keyword">end</span>
0210 
0211    <span class="keyword">try</span>
0212    ncols = arrayfun(@(x) size(x.interior_sources,2), stim);
0213    <span class="keyword">end</span>
0214    <span class="keyword">if</span> any(ncols&gt;1);
0215       str = <span class="string">'multiple columns in interior_sources for patterns: '</span>;
0216       error(<span class="string">'EIDORS:fwd_model_parameters:interior_points'</span>,<span class="keyword">...</span>
0217             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0218    <span class="keyword">end</span>
0219    idx = 1:p; idx(ncols==0)= [];
0220    <span class="keyword">try</span>
0221    QQ(:,idx) = QQ(:,idx) +  N2E' * horzcat( stim(:).interior_sources );
0222    <span class="keyword">end</span>
0223 
0224    n_meas = size(vertcat(stim(:).meas_pattern),1);
0225 
0226 
0227 
0228 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0229    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,16); fmdl = imdl.fwd_model;
0230    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>(fmdl);
0231    [QQ1, n1m] = <a href="#_sub4" class="code" title="subfunction [QQ, n_meas] = calc_QQ_slow(N2E, stim, p)">calc_QQ_slow</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0232    [QQ2, n2m] = <a href="#_sub5" class="code" title="subfunction [QQ, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0233    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_QQ'</span>, norm(QQ1-QQ2,<span class="string">'fro'</span>) + norm(n1m-n2m), 0, 1e-15);
0234 
0235    fmdl.stimulation(8).stim_pattern = fmdl.stimulation(8).stim_pattern*[1,2]; 
0236    err= 0;
0237    <span class="keyword">try</span>;  pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>(fmdl);
0238    <span class="keyword">catch</span> e
0239       <span class="keyword">if</span> strcmp(e.identifier, <span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>);
0240          err = 1;
0241       <span class="keyword">end</span>
0242    <span class="keyword">end</span>
0243    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'error'</span>, err, 1);</pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>