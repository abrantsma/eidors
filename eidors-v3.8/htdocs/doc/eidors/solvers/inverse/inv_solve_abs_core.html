<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of inv_solve_abs_core</title>
  <meta name="keywords" content="inv_solve_abs_core">
  <meta name="description" content="INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; inv_solve_abs_core.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>inv_solve_abs_core
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img= inv_solve_abs_core( inv_model, data0); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data0      =&gt; EIT data

 This function is parameterized and uses function pointers where possible to
 allow its use as a general iterative solver framework. There are a large
 number of parameters and functions contained here. Sensible defaults are
 used throughout. You do not need to set every parameter.

 The solver operates as an absolute Gauss-Newton iterative solver by default.
 Wrapper functions are available to call this function in its various forms.
 Look forward to the &quot;See also&quot; section at the end of this help.

 Argument matrices to the internal functions (measurement inverse covariance,
 for example) are only calculated if required. Functions that are supplied to
 this <a href="inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">INV_SOLVE_ABS_CORE</a> must be able to survive being probed: they will have
 each parameter set to either 0 or 1 to determine if the function is sensitive
 to that argument. This works cleanly for most matrix multiplication based
 functions but for more abstract code, some handling of this behaviour may
 need to be implemented.

 In the following parameters, r_k is the current residual, r_{k-1} is the
 previous iteration's residual. k is the iteration count.

 Parameters denoted with a ** to the right of their default values are
 deprecated legacy parameters, some of which formerly existed under
 'inv_model.parameters.*'.

 Parameters (inv_model.<a href="inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">inv_solve_abs_core</a>.*):
   verbose (show progress)                (default 4)
      0: quiet
    &gt;=1: print iteration count
    &gt;=2: print details as the algorithm progresses
    &gt;=3: plot residuals versus iteration count
    &gt;=4: plot result at each iteration, see show_fem
    &gt;=5: plot line search per iteration
   plot_residuals                         (default 0)
    plot residuals without verbose output
   fig_prefix                       (default: &lt;none&gt;)
    figure file prefix; figures not saved if &lt;none&gt;
   fwd_solutions                          (default 0)
    0: ignore
    1: count fwd_solve(), generally the most
       computationally expensive component of
       the iterations
   residual_func =             (default @GN_residual)
    NOTE: @meas_residual exists to maintain
    compatibility with some older code
   max_iterations                        (default 10)  **
   ntol (estimate of machine precision) (default eps)
   tol (stop iter if r_k &lt; tol)           (default 0)
   dtol                              (default -0.01%)
    stop iter if (r_k - r_{k-1}) &lt; dtol AND
                 k &gt;= dtol_iter
   dtol_iter                              (default 0)
    apply dtol stopping criteria if k &gt;= dtol_iter
   min_value                           (default -inf)  **
   max_value                           (default +inf)  **
   line_optimize_func                (default &lt;none&gt;)  ** TODO
     [next,fmin,res]=f(org,dx,data0,opt);
     opt=line_optimize.* + objective_func
     Deprecated, use line_search_func instead.
   <a href="line_optimize.html" class="code" title="function [img fmin res] = line_optimize(imgk, dx, data0, opt)">line_optimize</a>.perturb
                   (default line_search_args.perturb)  ** TODO
     Deprecated, use line_search_args.perturb instead.
   update_func                         (default TODO)  ** TODO
     [img,opt]=f(org,next,dx,fmin,res,opt)
     Deprecated, use &lt;TODO&gt; instead.
   do_starting_estimate                   (default 1)  ** TODO
     Deprecated, use &lt;TODO&gt; instead.
   line_search_func       (default @line_search_onm2)
   line_search_dv_func      (default @update_dv_core)
   line_search_de_func      (default @update_de_core)
   line_search_args.perturb
                     (default [0 1/16 1/8 1/4 1/2 1])
    line search for alpha by these steps along sx
   line_search_args.plot                  (default 0)
   c2f_background                         (default 0)
    if &gt; 0, this is additional elem_data
    if a c2f map exists, the default is to decide
    based on an estimate of c2f overlap whether a
    background value is required. If a background is
    required, it is added as the last element of that
    type.
   c2f_background_fixed                   (default 1)
    hold the background estimate fixed or allow it
    to vary as any other elem_data
   elem_fixed                            (default [])
    meas_select already handles selecting from the
    valid measurements. we want the same for the
    elem_data, so we only work on modifying the
    legal values.
    Note that c2f_background's elements are added to
    this list if c2f_background_fixed == 1.
   prior_data             (default to jacobian_bkgnd)
    Sets the priors of type elem_prior. May be
    scalar, per elem_prior, or match the working
    length of each elem_data type. Note that for priors
    using the c2f a background element may be added
    to the end of that range when required; see
    c2f_background.
   elem_len                (default to all elem_data)
    A cell array list of how many of each
    elem_working there are in elem_data.
      prior_data = { 32.1, 10*ones(10,1) };
      elem_prior = {'conductivity', 'movement'};
      elem_len = { 20001, 10 };
   elem_prior               (default to elem_working)
    Input 'prior_data' type; immediately converted to
    'elem_working' type before first iteration.
   elem_working              (default 'conductivity')
   elem_output               (default 'conductivity')
    The working and output units for 'elem_data'.
    Valid types are 'conductivity' and 'resistivity'
    as plain units or with the prefix 'log_' or
    'log10_'. Conversions are handled internally.
    Scaling factors are applied to the Jacobian
    (calculated in units of 'conductivity') as
    appropriate.
    If elem_working == elem_output, then no
    conversions take place.
    For multiple types, use cell array.
    ex: elem_output = {'log_resistivity', 'movement'}
   meas_input                     (default 'voltage')
   meas_working                   (default 'voltage')
    Similarly to elem_working/output, conversion
    between 'voltage' and 'apparent_resistivity' and
    their log/log10 varients are handled internally.
    If meas_input == meas_working no conversions take
    place. The normalization factor 'N' is calculated
    if 'apparent_resistivity' is used.
   update_img_func             (default: pass-through)
    Called prior to calc_jacobian and update_dv.
    Elements are converted to their &quot;base types&quot;
    before this function is called. For example,
    'log_resistivity' becomes 'conductivity'.
    It is a hook to allow additional updates to the
    model before the Jacobian, or a new set of
    measurements are calculated via fwd_solve.
   return_working_variables               (default: 0)
    If 1, return the last working variables to the user
     img.var.J   Jacobian
     img.var.dx  descent direction
     img.var.sx  search direction
     img.var.alpha  line search result
     img.var.beta   conjugation parameter
     img.var.r   as:
       [ residual, mesurement misfit, element misfit ]
       with one row per iteration
   show_fem                       (default: @show_fem)
    Function with which to plot each iteration's
    current parameters.

   Signature for residual_func
    r = f(dv, de, W, hp2RtR)
   where
    r   - the residual
    dv  - change in voltage
    de  - change in image elements
    W   - measurement inverse covarience matrix
    hp2 - hyperparameter squared, see CALC_HYPERPARAMETER
    RtR - regularization matrix squared --&gt; hp2RtR = hp2*RtR

   Signature for line_optimize_func
    [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hp2RtR, dv, opt)
   where:
    alpha - line search result
    img   - the current image
            (optional, recalculated if not available)
    sx    - the search direction to which alpha should be applied
    data0 - the true measurements     (dv = N*data - N*data0)
    img0  - the image background (de = img - img0)
    N     - a measurement normalization factor, N*dv
    W     - measurement inverse covarience matrix
    hp2   - hyperparameter squared, see CALC_HYPERPARAMETER
    RtR   - regularization matrix squared --&gt; hp2RtR = hp2*RtR
    dv    - change in voltage
            (optional, recalculated if not available)
    opt   - additional arguments, updated at each call

   Signature for line_search_dv_func
    [dv, opt] = update_dv_core(img, data0, N, opt)
   where:
    dv    - change in voltage
    opt   - additional arguments, updated at each call
    data  - the estimated measurements
    img   - the current image
    data0 - the true measurements
    N     - a measurement normalization factor, N*dv

   Signature for line_search_de_func
    de = f(img, img0, opt)
   where:
    de    - change in image elements
    img   - the current image
    img0  - the image background (de = img - img0)
    opt   - additional arguments

   Signature for calc_jacobian_scaling_func
    S = f(x)
   where:
    S - to be used to scale the Jacobian
    x - current img.elem_data in units of 'conductivity'

   Signature for  update_img_func
    img2 = f(img1, opt)
   where
    img1 - an input image, the current working image
    img2 - a (potentially) modified version to be used
    for the fwd_solve/Jacobian calculations

 NOTE that the default line search is very crude. For
 my test problems it seems to amount to an expensive grid
 search. Much more efficient line search algorithms exist
 and some fragments already are coded elsewhere in the
 EIDORS code-base.

 See also: <a href="inv_solve_abs_GN.html" class="code" title="function img= inv_solve_abs_GN( inv_model, data1);">INV_SOLVE_ABS_GN</a>, INV_SOLVE_ABS_GN_LOGC,
           <a href="inv_solve_abs_CG.html" class="code" title="function img= inv_solve_abs_CG( inv_model, data1);">INV_SOLVE_ABS_CG</a>, INV_SOLVE_ABS_CG_LOGC,
           <a href="line_search_o2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_o2(imgk, dx, data1, img1, N, W, hp2RtR, dv0, opt)">LINE_SEARCH_O2</a>, <a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hp2RtR, dv0, opt, retry, pf_max)">LINE_SEARCH_ONM2</a>

 (C) 2010-2014 Alistair Boyle, Nolwenn Lesparre, Andy Adler, Bartłomiej Grychtol.
 License: GPL version 2 or version 3</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/graphics/matlab/show_pseudosection.html" class="code" title="function fwd_model= show_pseudosection( fwd_model, data, orientation)">show_pseudosection</a>	SHOW_PSEUDOSECTION: show a pseudo-section image of data</li><li><a href="../../../eidors/meshing/netgen/ng_mk_gen_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_gen_models(shape_str, elec_pos,  elec_shape, elec_obj, extra_ng_code);">ng_mk_gen_models</a>	NG_MK_GEN_MODELS: create generic models using netgen</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping( f_mdl, c_mdl );">mk_coarse_fine_mapping</a>	MK_COARSE_FINE_MAPPING: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/stim_pattern_geophys.html" class="code" title="function [stim,S]= stim_pattern_geophys( n_elec, pat_type,  options )">stim_pattern_geophys</a>	STIM_PATTERN_GEOPHYS: Create Geophysical Stimulation Patterns</li><li><a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>	</li><li><a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>	SPDIAG Sparse diagonal matrices and diagonals of a matrix.</li><li><a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="../../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">inv_solve_abs_core</a>	INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm</li><li><a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hp2RtR, dv0, opt, retry, pf_max)">line_search_onm2</a>	function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hp2RtR, dv0, opt)</li><li><a href="prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model );">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>	EIDORS_DEFAULT Default function handler.</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="inv_solve_abs_CG.html" class="code" title="function img= inv_solve_abs_CG( inv_model, data1);">inv_solve_abs_CG</a>	function img= inv_solve_abs_CG( inv_model, data1);</li><li><a href="inv_solve_abs_GN.html" class="code" title="function img= inv_solve_abs_GN( inv_model, data1);">inv_solve_abs_GN</a>	function img= inv_solve_abs_GN( inv_model, data1);</li><li><a href="inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">inv_solve_abs_core</a>	INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function show_meas_err(dvall, data0, k, N, W, opt)</a></li><li><a href="#_sub2" class="code">function img = init_elem_data(img, opt)</a></li><li><a href="#_sub3" class="code">function W = init_meas_icov(inv_model, opt)</a></li><li><a href="#_sub4" class="code">function [N, dN] = init_normalization(fmdl, data0, opt)</a></li><li><a href="#_sub5" class="code">function [stop, k, r, img] = update_residual(dv, img, de, W, hp2RtR, k, r, alpha, sx, opt)</a></li><li><a href="#_sub6" class="code">function beta = update_beta(dx_k, dx_km1, sx_km1, opt);</a></li><li><a href="#_sub7" class="code">function sx = update_sx(dx, beta, sx_km1, opt);</a></li><li><a href="#_sub8" class="code">function hp2RtR = update_hp2RtR(inv_model, J, k, img, opt)</a></li><li><a href="#_sub9" class="code">function plot_svd_elem(J, W, hp2RtR, k, sx, dx, img, opt)</a></li><li><a href="#_sub10" class="code">function plot_svd(J, W, hp2RtR, k, hp)</a></li><li><a href="#_sub11" class="code">function RtR = calc_RtR_prior_wrapper(inv_model, img, opt)</a></li><li><a href="#_sub12" class="code">function [J, opt] = update_jacobian(img, dN, k, opt)</a></li><li><a href="#_sub13" class="code">function S = dx_dlogx(x);</a></li><li><a href="#_sub14" class="code">function S = dx_dlog10x(x);</a></li><li><a href="#_sub15" class="code">function S = dx_dy(x);</a></li><li><a href="#_sub16" class="code">function S = dx_dlogy(x);</a></li><li><a href="#_sub17" class="code">function S = dx_dlog10y(x);</a></li><li><a href="#_sub18" class="code">function dN = da_dv(v,vh)</a></li><li><a href="#_sub19" class="code">function dN = dloga_dv(v,vh)</a></li><li><a href="#_sub20" class="code">function dN = dlog10a_dv(v,vh)</a></li><li><a href="#_sub21" class="code">function dN = dv_dv(v,vh)</a></li><li><a href="#_sub22" class="code">function dN = dlogv_dv(v,vh)</a></li><li><a href="#_sub23" class="code">function dN = dlog10v_dv(v,vh)</a></li><li><a href="#_sub24" class="code">function [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hp2RtR, k, dv, opt)</a></li><li><a href="#_sub25" class="code">function err_if_inf_or_nan(x, str);</a></li><li><a href="#_sub26" class="code">function [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)</a></li><li><a href="#_sub27" class="code">function  de = update_de(de, img, img0, opt)</a></li><li><a href="#_sub28" class="code">function [dv, opt] = update_dv(dv, img, data0, N, opt, reason)</a></li><li><a href="#_sub29" class="code">function data = map_meas_struct(data, N, out)</a></li><li><a href="#_sub30" class="code">function [dv, opt, err] = update_dv_core(img, data0, N, opt)</a></li><li><a href="#_sub31" class="code">function show_fem_iter(k, img, inv_model, stop, opt)</a></li><li><a href="#_sub32" class="code">function residual = GN_residual(dv, de, W, hp2RtR)</a></li><li><a href="#_sub33" class="code">function residual = meas_residual(dv, de, W, hp2RtR)</a></li><li><a href="#_sub34" class="code">function imdl = deprecate_imdl_opt(imdl,opt)</a></li><li><a href="#_sub35" class="code">function opt = parse_options(imdl)</a></li><li><a href="#_sub36" class="code">function check_matrix_sizes(J, W, hp2RtR, dv, de, opt)</a></li><li><a href="#_sub37" class="code">function dx = update_dx(J, W, hp2RtR, dv, de, opt)</a></li><li><a href="#_sub38" class="code">function dx = GN_update(J, W, hp2RtR, dv, de)</a></li><li><a href="#_sub39" class="code">function args = function_depends_upon(func, argn)</a></li><li><a href="#_sub40" class="code">function out = null_func(in, varargin);</a></li><li><a href="#_sub41" class="code">function [out, x, y, z] = ret1_func(varargin);</a></li><li><a href="#_sub42" class="code">function [inv_model, opt] = append_c2f_background(inv_model, opt)</a></li><li><a href="#_sub43" class="code">function [img, opt] = strip_c2f_background(img, opt, indent)</a></li><li><a href="#_sub44" class="code">function b = has_params(s)</a></li><li><a href="#_sub45" class="code">function out = map_img_base_types(img)</a></li><li><a href="#_sub46" class="code">function type = to_base_types(type)</a></li><li><a href="#_sub47" class="code">function img = map_img(img, out);</a></li><li><a href="#_sub48" class="code">function x = map_data(x, in, out)</a></li><li><a href="#_sub49" class="code">function b = map_meas(b, N, in, out)</a></li><li><a href="#_sub50" class="code">function x=range(y)</a></li><li><a href="#_sub51" class="code">function do_unit_test(solver)</a></li><li><a href="#_sub52" class="code">function do_unit_test_sub</a></li><li><a href="#_sub53" class="code">function test_map_data(data, in, out, expected)</a></li><li><a href="#_sub54" class="code">function test_map_meas(data, N, in, out, expected)</a></li><li><a href="#_sub55" class="code">function do_unit_test_rec1(solver)</a></li><li><a href="#_sub56" class="code">function do_unit_test_rec_mv(solver)</a></li><li><a href="#_sub57" class="code">function Jm = jacobian_movement_only (fwd_model, img);</a></li><li><a href="#_sub58" class="code">function RtR = prior_movement_only(imdl);</a></li><li><a href="#_sub59" class="code">function do_unit_test_rec2(solver)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img= inv_solve_abs_core( inv_model, data0);</a>
0002 <span class="comment">%INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm</span>
0003 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0004 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0005 <span class="comment">% data0      =&gt; EIT data</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% This function is parameterized and uses function pointers where possible to</span>
0008 <span class="comment">% allow its use as a general iterative solver framework. There are a large</span>
0009 <span class="comment">% number of parameters and functions contained here. Sensible defaults are</span>
0010 <span class="comment">% used throughout. You do not need to set every parameter.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% The solver operates as an absolute Gauss-Newton iterative solver by default.</span>
0013 <span class="comment">% Wrapper functions are available to call this function in its various forms.</span>
0014 <span class="comment">% Look forward to the &quot;See also&quot; section at the end of this help.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Argument matrices to the internal functions (measurement inverse covariance,</span>
0017 <span class="comment">% for example) are only calculated if required. Functions that are supplied to</span>
0018 <span class="comment">% this INV_SOLVE_ABS_CORE must be able to survive being probed: they will have</span>
0019 <span class="comment">% each parameter set to either 0 or 1 to determine if the function is sensitive</span>
0020 <span class="comment">% to that argument. This works cleanly for most matrix multiplication based</span>
0021 <span class="comment">% functions but for more abstract code, some handling of this behaviour may</span>
0022 <span class="comment">% need to be implemented.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% In the following parameters, r_k is the current residual, r_{k-1} is the</span>
0025 <span class="comment">% previous iteration's residual. k is the iteration count.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Parameters denoted with a ** to the right of their default values are</span>
0028 <span class="comment">% deprecated legacy parameters, some of which formerly existed under</span>
0029 <span class="comment">% 'inv_model.parameters.*'.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% Parameters (inv_model.inv_solve_abs_core.*):</span>
0032 <span class="comment">%   verbose (show progress)                (default 4)</span>
0033 <span class="comment">%      0: quiet</span>
0034 <span class="comment">%    &gt;=1: print iteration count</span>
0035 <span class="comment">%    &gt;=2: print details as the algorithm progresses</span>
0036 <span class="comment">%    &gt;=3: plot residuals versus iteration count</span>
0037 <span class="comment">%    &gt;=4: plot result at each iteration, see show_fem</span>
0038 <span class="comment">%    &gt;=5: plot line search per iteration</span>
0039 <span class="comment">%   plot_residuals                         (default 0)</span>
0040 <span class="comment">%    plot residuals without verbose output</span>
0041 <span class="comment">%   fig_prefix                       (default: &lt;none&gt;)</span>
0042 <span class="comment">%    figure file prefix; figures not saved if &lt;none&gt;</span>
0043 <span class="comment">%   fwd_solutions                          (default 0)</span>
0044 <span class="comment">%    0: ignore</span>
0045 <span class="comment">%    1: count fwd_solve(), generally the most</span>
0046 <span class="comment">%       computationally expensive component of</span>
0047 <span class="comment">%       the iterations</span>
0048 <span class="comment">%   residual_func =             (default @GN_residual)</span>
0049 <span class="comment">%    NOTE: @meas_residual exists to maintain</span>
0050 <span class="comment">%    compatibility with some older code</span>
0051 <span class="comment">%   max_iterations                        (default 10)  **</span>
0052 <span class="comment">%   ntol (estimate of machine precision) (default eps)</span>
0053 <span class="comment">%   tol (stop iter if r_k &lt; tol)           (default 0)</span>
0054 <span class="comment">%   dtol                              (default -0.01%)</span>
0055 <span class="comment">%    stop iter if (r_k - r_{k-1}) &lt; dtol AND</span>
0056 <span class="comment">%                 k &gt;= dtol_iter</span>
0057 <span class="comment">%   dtol_iter                              (default 0)</span>
0058 <span class="comment">%    apply dtol stopping criteria if k &gt;= dtol_iter</span>
0059 <span class="comment">%   min_value                           (default -inf)  **</span>
0060 <span class="comment">%   max_value                           (default +inf)  **</span>
0061 <span class="comment">%   line_optimize_func                (default &lt;none&gt;)  ** TODO</span>
0062 <span class="comment">%     [next,fmin,res]=f(org,dx,data0,opt);</span>
0063 <span class="comment">%     opt=line_optimize.* + objective_func</span>
0064 <span class="comment">%     Deprecated, use line_search_func instead.</span>
0065 <span class="comment">%   line_optimize.perturb</span>
0066 <span class="comment">%                   (default line_search_args.perturb)  ** TODO</span>
0067 <span class="comment">%     Deprecated, use line_search_args.perturb instead.</span>
0068 <span class="comment">%   update_func                         (default TODO)  ** TODO</span>
0069 <span class="comment">%     [img,opt]=f(org,next,dx,fmin,res,opt)</span>
0070 <span class="comment">%     Deprecated, use &lt;TODO&gt; instead.</span>
0071 <span class="comment">%   do_starting_estimate                   (default 1)  ** TODO</span>
0072 <span class="comment">%     Deprecated, use &lt;TODO&gt; instead.</span>
0073 <span class="comment">%   line_search_func       (default @line_search_onm2)</span>
0074 <span class="comment">%   line_search_dv_func      (default @update_dv_core)</span>
0075 <span class="comment">%   line_search_de_func      (default @update_de_core)</span>
0076 <span class="comment">%   line_search_args.perturb</span>
0077 <span class="comment">%                     (default [0 1/16 1/8 1/4 1/2 1])</span>
0078 <span class="comment">%    line search for alpha by these steps along sx</span>
0079 <span class="comment">%   line_search_args.plot                  (default 0)</span>
0080 <span class="comment">%   c2f_background                         (default 0)</span>
0081 <span class="comment">%    if &gt; 0, this is additional elem_data</span>
0082 <span class="comment">%    if a c2f map exists, the default is to decide</span>
0083 <span class="comment">%    based on an estimate of c2f overlap whether a</span>
0084 <span class="comment">%    background value is required. If a background is</span>
0085 <span class="comment">%    required, it is added as the last element of that</span>
0086 <span class="comment">%    type.</span>
0087 <span class="comment">%   c2f_background_fixed                   (default 1)</span>
0088 <span class="comment">%    hold the background estimate fixed or allow it</span>
0089 <span class="comment">%    to vary as any other elem_data</span>
0090 <span class="comment">%   elem_fixed                            (default [])</span>
0091 <span class="comment">%    meas_select already handles selecting from the</span>
0092 <span class="comment">%    valid measurements. we want the same for the</span>
0093 <span class="comment">%    elem_data, so we only work on modifying the</span>
0094 <span class="comment">%    legal values.</span>
0095 <span class="comment">%    Note that c2f_background's elements are added to</span>
0096 <span class="comment">%    this list if c2f_background_fixed == 1.</span>
0097 <span class="comment">%   prior_data             (default to jacobian_bkgnd)</span>
0098 <span class="comment">%    Sets the priors of type elem_prior. May be</span>
0099 <span class="comment">%    scalar, per elem_prior, or match the working</span>
0100 <span class="comment">%    length of each elem_data type. Note that for priors</span>
0101 <span class="comment">%    using the c2f a background element may be added</span>
0102 <span class="comment">%    to the end of that range when required; see</span>
0103 <span class="comment">%    c2f_background.</span>
0104 <span class="comment">%   elem_len                (default to all elem_data)</span>
0105 <span class="comment">%    A cell array list of how many of each</span>
0106 <span class="comment">%    elem_working there are in elem_data.</span>
0107 <span class="comment">%      prior_data = { 32.1, 10*ones(10,1) };</span>
0108 <span class="comment">%      elem_prior = {'conductivity', 'movement'};</span>
0109 <span class="comment">%      elem_len = { 20001, 10 };</span>
0110 <span class="comment">%   elem_prior               (default to elem_working)</span>
0111 <span class="comment">%    Input 'prior_data' type; immediately converted to</span>
0112 <span class="comment">%    'elem_working' type before first iteration.</span>
0113 <span class="comment">%   elem_working              (default 'conductivity')</span>
0114 <span class="comment">%   elem_output               (default 'conductivity')</span>
0115 <span class="comment">%    The working and output units for 'elem_data'.</span>
0116 <span class="comment">%    Valid types are 'conductivity' and 'resistivity'</span>
0117 <span class="comment">%    as plain units or with the prefix 'log_' or</span>
0118 <span class="comment">%    'log10_'. Conversions are handled internally.</span>
0119 <span class="comment">%    Scaling factors are applied to the Jacobian</span>
0120 <span class="comment">%    (calculated in units of 'conductivity') as</span>
0121 <span class="comment">%    appropriate.</span>
0122 <span class="comment">%    If elem_working == elem_output, then no</span>
0123 <span class="comment">%    conversions take place.</span>
0124 <span class="comment">%    For multiple types, use cell array.</span>
0125 <span class="comment">%    ex: elem_output = {'log_resistivity', 'movement'}</span>
0126 <span class="comment">%   meas_input                     (default 'voltage')</span>
0127 <span class="comment">%   meas_working                   (default 'voltage')</span>
0128 <span class="comment">%    Similarly to elem_working/output, conversion</span>
0129 <span class="comment">%    between 'voltage' and 'apparent_resistivity' and</span>
0130 <span class="comment">%    their log/log10 varients are handled internally.</span>
0131 <span class="comment">%    If meas_input == meas_working no conversions take</span>
0132 <span class="comment">%    place. The normalization factor 'N' is calculated</span>
0133 <span class="comment">%    if 'apparent_resistivity' is used.</span>
0134 <span class="comment">%   update_img_func             (default: pass-through)</span>
0135 <span class="comment">%    Called prior to calc_jacobian and update_dv.</span>
0136 <span class="comment">%    Elements are converted to their &quot;base types&quot;</span>
0137 <span class="comment">%    before this function is called. For example,</span>
0138 <span class="comment">%    'log_resistivity' becomes 'conductivity'.</span>
0139 <span class="comment">%    It is a hook to allow additional updates to the</span>
0140 <span class="comment">%    model before the Jacobian, or a new set of</span>
0141 <span class="comment">%    measurements are calculated via fwd_solve.</span>
0142 <span class="comment">%   return_working_variables               (default: 0)</span>
0143 <span class="comment">%    If 1, return the last working variables to the user</span>
0144 <span class="comment">%     img.var.J   Jacobian</span>
0145 <span class="comment">%     img.var.dx  descent direction</span>
0146 <span class="comment">%     img.var.sx  search direction</span>
0147 <span class="comment">%     img.var.alpha  line search result</span>
0148 <span class="comment">%     img.var.beta   conjugation parameter</span>
0149 <span class="comment">%     img.var.r   as:</span>
0150 <span class="comment">%       [ residual, mesurement misfit, element misfit ]</span>
0151 <span class="comment">%       with one row per iteration</span>
0152 <span class="comment">%   show_fem                       (default: @show_fem)</span>
0153 <span class="comment">%    Function with which to plot each iteration's</span>
0154 <span class="comment">%    current parameters.</span>
0155 <span class="comment">%</span>
0156 <span class="comment">%   Signature for residual_func</span>
0157 <span class="comment">%    r = f(dv, de, W, hp2RtR)</span>
0158 <span class="comment">%   where</span>
0159 <span class="comment">%    r   - the residual</span>
0160 <span class="comment">%    dv  - change in voltage</span>
0161 <span class="comment">%    de  - change in image elements</span>
0162 <span class="comment">%    W   - measurement inverse covarience matrix</span>
0163 <span class="comment">%    hp2 - hyperparameter squared, see CALC_HYPERPARAMETER</span>
0164 <span class="comment">%    RtR - regularization matrix squared --&gt; hp2RtR = hp2*RtR</span>
0165 <span class="comment">%</span>
0166 <span class="comment">%   Signature for line_optimize_func</span>
0167 <span class="comment">%    [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hp2RtR, dv, opt)</span>
0168 <span class="comment">%   where:</span>
0169 <span class="comment">%    alpha - line search result</span>
0170 <span class="comment">%    img   - the current image</span>
0171 <span class="comment">%            (optional, recalculated if not available)</span>
0172 <span class="comment">%    sx    - the search direction to which alpha should be applied</span>
0173 <span class="comment">%    data0 - the true measurements     (dv = N*data - N*data0)</span>
0174 <span class="comment">%    img0  - the image background (de = img - img0)</span>
0175 <span class="comment">%    N     - a measurement normalization factor, N*dv</span>
0176 <span class="comment">%    W     - measurement inverse covarience matrix</span>
0177 <span class="comment">%    hp2   - hyperparameter squared, see CALC_HYPERPARAMETER</span>
0178 <span class="comment">%    RtR   - regularization matrix squared --&gt; hp2RtR = hp2*RtR</span>
0179 <span class="comment">%    dv    - change in voltage</span>
0180 <span class="comment">%            (optional, recalculated if not available)</span>
0181 <span class="comment">%    opt   - additional arguments, updated at each call</span>
0182 <span class="comment">%</span>
0183 <span class="comment">%   Signature for line_search_dv_func</span>
0184 <span class="comment">%    [dv, opt] = update_dv_core(img, data0, N, opt)</span>
0185 <span class="comment">%   where:</span>
0186 <span class="comment">%    dv    - change in voltage</span>
0187 <span class="comment">%    opt   - additional arguments, updated at each call</span>
0188 <span class="comment">%    data  - the estimated measurements</span>
0189 <span class="comment">%    img   - the current image</span>
0190 <span class="comment">%    data0 - the true measurements</span>
0191 <span class="comment">%    N     - a measurement normalization factor, N*dv</span>
0192 <span class="comment">%</span>
0193 <span class="comment">%   Signature for line_search_de_func</span>
0194 <span class="comment">%    de = f(img, img0, opt)</span>
0195 <span class="comment">%   where:</span>
0196 <span class="comment">%    de    - change in image elements</span>
0197 <span class="comment">%    img   - the current image</span>
0198 <span class="comment">%    img0  - the image background (de = img - img0)</span>
0199 <span class="comment">%    opt   - additional arguments</span>
0200 <span class="comment">%</span>
0201 <span class="comment">%   Signature for calc_jacobian_scaling_func</span>
0202 <span class="comment">%    S = f(x)</span>
0203 <span class="comment">%   where:</span>
0204 <span class="comment">%    S - to be used to scale the Jacobian</span>
0205 <span class="comment">%    x - current img.elem_data in units of 'conductivity'</span>
0206 <span class="comment">%</span>
0207 <span class="comment">%   Signature for  update_img_func</span>
0208 <span class="comment">%    img2 = f(img1, opt)</span>
0209 <span class="comment">%   where</span>
0210 <span class="comment">%    img1 - an input image, the current working image</span>
0211 <span class="comment">%    img2 - a (potentially) modified version to be used</span>
0212 <span class="comment">%    for the fwd_solve/Jacobian calculations</span>
0213 <span class="comment">%</span>
0214 <span class="comment">% NOTE that the default line search is very crude. For</span>
0215 <span class="comment">% my test problems it seems to amount to an expensive grid</span>
0216 <span class="comment">% search. Much more efficient line search algorithms exist</span>
0217 <span class="comment">% and some fragments already are coded elsewhere in the</span>
0218 <span class="comment">% EIDORS code-base.</span>
0219 <span class="comment">%</span>
0220 <span class="comment">% See also: INV_SOLVE_ABS_GN, INV_SOLVE_ABS_GN_LOGC,</span>
0221 <span class="comment">%           INV_SOLVE_ABS_CG, INV_SOLVE_ABS_CG_LOGC,</span>
0222 <span class="comment">%           LINE_SEARCH_O2, LINE_SEARCH_ONM2</span>
0223 <span class="comment">%</span>
0224 <span class="comment">% (C) 2010-2014 Alistair Boyle, Nolwenn Lesparre, Andy Adler, Bartłomiej Grychtol.</span>
0225 <span class="comment">% License: GPL version 2 or version 3</span>
0226 
0227 <span class="comment">% $Id: inv_solve_abs_core.m 4941 2015-05-09 01:19:34Z aadler $</span>
0228 
0229 <span class="comment">%--------------------------</span>
0230 <span class="comment">% UNIT_TEST?</span>
0231 <span class="keyword">if</span> isstr(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>) &amp;&amp; (nargin == 1); <a href="#_sub51" class="code" title="subfunction do_unit_test(solver)">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0232 <span class="keyword">if</span> isstr(inv_model) &amp;&amp; strcmp(inv_model,<span class="string">'UNIT_TEST'</span>) &amp;&amp; (nargin == 2); <a href="#_sub51" class="code" title="subfunction do_unit_test(solver)">do_unit_test</a>(data0); <span class="keyword">return</span>; <span class="keyword">end</span>
0233 
0234 <span class="comment">%--------------------------</span>
0235 opt = <a href="#_sub35" class="code" title="subfunction opt = parse_options(imdl)">parse_options</a>(inv_model);
0236 <span class="keyword">if</span> opt.verbose &gt; 1
0237    fprintf(<span class="string">'  verbose = %d\n'</span>, opt.verbose);
0238 <span class="keyword">end</span>
0239 <span class="comment">%if opt.do_starting_estimate</span>
0240 <span class="comment">%    img = initial_estimate( inv_model, data0 ); % TODO</span>
0241 <span class="comment">%%%    AB-&gt;NL this is Nolwenn's homogeneous estimate...</span>
0242 <span class="comment">%%%    calc_background_resistivity is my version of this code</span>
0243 <span class="comment">%%%    that is working for my data set</span>
0244 <span class="comment">%else</span>
0245 [inv_model, opt] = <a href="#_sub42" class="code" title="subfunction [inv_model, opt] = append_c2f_background(inv_model, opt)">append_c2f_background</a>(inv_model, opt);
0246 <span class="comment">% calc_jacobian_bkgnd, used by mk_image does not understand</span>
0247 <span class="comment">% the course-to-fine mapping and explodes when it is fed a</span>
0248 <span class="comment">% prior based on the coarse model. Here we give that</span>
0249 <span class="comment">% function something it can swallow, then create then plug</span>
0250 <span class="comment">% in the correct prior afterwards.</span>
0251 <span class="keyword">if</span> isfield(inv_model, <span class="string">'jacobian_bkgnd'</span>)
0252   inv_model = rmfield(inv_model,<span class="string">'jacobian_bkgnd'</span>);
0253 <span class="keyword">end</span>
0254 inv_model.jacobian_bkgnd.value = 1;
0255 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( inv_model );
0256 img.inv_model = inv_model; <span class="comment">% stash the inverse model</span>
0257 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img); <span class="comment">% move data from whatever 'params' to img.elem_data</span>
0258 
0259 <span class="comment">% insert the prior data</span>
0260 img = <a href="#_sub2" class="code" title="subfunction img = init_elem_data(img, opt)">init_elem_data</a>(img, opt);
0261 
0262 <span class="comment">% map data and measurements to working types</span>
0263 <span class="comment">%  convert elem_data</span>
0264 img = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_working);
0265 <span class="comment">%  convert measurement data</span>
0266 <span class="keyword">if</span> ~isstruct(data0)
0267    d = data0;
0268    data0 = struct;
0269    data0.meas = d;
0270    data0.type = <span class="string">'data'</span>;
0271 <span class="keyword">end</span>
0272 data0.current_params = opt.meas_input;
0273 
0274 <span class="comment">% precalculate some of our matrices if required</span>
0275 W  = <a href="#_sub3" class="code" title="subfunction W = init_meas_icov(inv_model, opt)">init_meas_icov</a>(inv_model, opt);
0276 [N, dN] = <a href="#_sub4" class="code" title="subfunction [N, dN] = init_normalization(fmdl, data0, opt)">init_normalization</a>(inv_model.fwd_model, data0, opt);
0277 
0278 <span class="comment">% now get on with</span>
0279 img0 = img;
0280 hp2RtR = 0; alpha = 0; k = 0; sx = 0; r = 0; stop = 0; <span class="comment">% general init</span>
0281 residuals = zeros(opt.max_iterations,3); <span class="comment">% for residuals plots</span>
0282 dxp = 0; <span class="comment">% previous step's slope was... nothing</span>
0283 [dv, opt] = <a href="#_sub28" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>([], img, data0, N, opt);
0284 de = <a href="#_sub27" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>([], img, img0, opt);
0285 <span class="keyword">if</span> opt.verbose &gt;= 5 <span class="comment">% we only save the measurements at each iteration if we are being verbose</span>
0286   dvall = ones(size(data0.meas,1),opt.max_iterations+1)*NaN;
0287 <span class="keyword">end</span>
0288 <span class="keyword">while</span> 1
0289   <span class="keyword">if</span> opt.verbose &gt; 1
0290      <span class="keyword">if</span> k == 0
0291         fprintf(<span class="string">'  iteration start up\n'</span>)
0292      <span class="keyword">else</span>
0293         fprintf(<span class="string">'  iteration %d\n'</span>, k)
0294      <span class="keyword">end</span>
0295   <span class="keyword">end</span>
0296 
0297   <span class="comment">% calculate the Jacobian</span>
0298   <span class="comment">%  - Jacobian before RtR because it is needed for Noser prior</span>
0299   [J, opt] = <a href="#_sub12" class="code" title="subfunction [J, opt] = update_jacobian(img, dN, k, opt)">update_jacobian</a>(img, dN, k, opt);
0300 
0301   <span class="comment">% update RtR, if required (depends on prior)</span>
0302   hp2RtR = <a href="#_sub8" class="code" title="subfunction hp2RtR = update_hp2RtR(inv_model, J, k, img, opt)">update_hp2RtR</a>(inv_model, J, k, img, opt);
0303 
0304   <span class="comment">% determine the next search direction sx</span>
0305   <span class="comment">%  dx is specific to the algorithm, generally &quot;downhill&quot;</span>
0306   dx = <a href="#_sub37" class="code" title="subfunction dx = update_dx(J, W, hp2RtR, dv, de, opt)">update_dx</a>(J, W, hp2RtR, dv, de, opt);
0307   <span class="comment">% choose beta, beta=0 unless doing Conjugate Gradient</span>
0308   beta = <a href="#_sub6" class="code" title="subfunction beta = update_beta(dx_k, dx_km1, sx_km1, opt);">update_beta</a>(dx, dxp, sx, opt);
0309   <span class="comment">% sx_k = dx_k + beta * sx_{k-1}</span>
0310   sx = <a href="#_sub7" class="code" title="subfunction sx = update_sx(dx, beta, sx_km1, opt);">update_sx</a>(dx, beta, sx, opt);
0311   <span class="keyword">if</span> k ~= 0
0312      dxp = dx; <span class="comment">% saved for next iteration if using beta</span>
0313   <span class="keyword">end</span>
0314 
0315   <span class="comment">% plot SVD of Jacobian (before and after regularization)</span>
0316   <a href="#_sub9" class="code" title="subfunction plot_svd_elem(J, W, hp2RtR, k, sx, dx, img, opt)">plot_svd_elem</a>(J, W, hp2RtR, k, sx, dx, img, opt);
0317 
0318   <span class="comment">% line search for alpha, leaving the final selection as img</span>
0319   <span class="comment">% x_n = img.elem_data</span>
0320   <span class="comment">% x_{n+1} = x_n + \alpha sx</span>
0321   <span class="comment">% img.elem_data = x_{n+1}</span>
0322   [alpha, img, dv, opt] = <a href="#_sub24" class="code" title="subfunction [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hp2RtR, k, dv, opt)">update_alpha</a>(img, sx, data0, img0, N, W, hp2RtR, k, dv, opt);
0323   <span class="comment">% fix max/min values for x, clears dx if limits are hit, where</span>
0324   <span class="comment">% a cleared dv will trigger a recalculation of dv at the next update_dv()</span>
0325   [img, dv] = <a href="#_sub26" class="code" title="subfunction [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)">update_img_using_limits</a>(img, img0, data0, N, dv, opt);
0326 
0327   <span class="comment">% update change in element data from the prior de and</span>
0328   <span class="comment">% the measurement error dv</span>
0329   [dv, opt] = <a href="#_sub28" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>(dv, img, data0, N, opt);
0330   de = <a href="#_sub27" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>(de, img, img0, opt);
0331   <span class="keyword">if</span> opt.verbose &gt;= 5
0332     dvall(:,k+1) = dv;
0333     <a href="#_sub1" class="code" title="subfunction show_meas_err(dvall, data0, k, N, W, opt)">show_meas_err</a>(dvall, data0, k+1, N, W, opt);
0334   <span class="keyword">end</span>
0335   <a href="#_sub31" class="code" title="subfunction show_fem_iter(k, img, inv_model, stop, opt)">show_fem_iter</a>(k, img, inv_model, stop, opt);
0336 
0337   <span class="comment">% now find the residual, quit if we're done</span>
0338   [stop, k, r, img] = <a href="#_sub5" class="code" title="subfunction [stop, k, r, img] = update_residual(dv, img, de, W, hp2RtR, k, r, alpha, sx, opt)">update_residual</a>(dv, img, de, W, hp2RtR, k, r, alpha, sx, opt);
0339   <span class="keyword">if</span> stop
0340      <span class="keyword">break</span>;
0341   <span class="keyword">end</span>
0342 <span class="keyword">end</span>
0343 [img, opt] = <a href="#_sub43" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt);
0344 <span class="comment">% check we're returning the right size of data</span>
0345 <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
0346   img.fwd_model = inv_model.rec_model;
0347 <span class="keyword">end</span>
0348 <span class="keyword">if</span> opt.verbose &gt; 1
0349    <span class="keyword">if</span> k==1; itrs=<span class="string">''</span>; <span class="keyword">else</span> itrs=<span class="string">'s'</span>; <span class="keyword">end</span>
0350    fprintf(<span class="string">'  %d fwd_solves required for this solution in %d iteration%s\n'</span>, <span class="keyword">...</span>
0351            opt.fwd_solutions, k, itrs);
0352 <span class="keyword">end</span>
0353 <span class="comment">% convert data for output</span>
0354 img = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_output);
0355 img.meas_err = dv;
0356 <span class="keyword">if</span> opt.return_working_variables
0357   img.inv_solve_abs_core.J = J;
0358   img.inv_solve_abs_core.dx = dx;
0359   img.inv_solve_abs_core.sx = sx;
0360   img.inv_solve_abs_core.alpha = alpha;
0361   img.inv_solve_abs_core.beta = beta;
0362   img.inv_solve_abs_core.k = k;
0363   img.inv_solve_abs_core.r = r;
0364   img.inv_solve_abs_core.N = N;
0365   img.inv_solve_abs_core.W = W;
0366   img.inv_solve_abs_core.hp2RtR = hp2RtR;
0367   img.inv_solve_abs_core.dv = dv;
0368   img.inv_solve_abs_core.de = de;
0369   <span class="keyword">if</span> opt.verbose &gt;= 5
0370     img.inv_solve_abs_core.dvall = dvall;
0371   <span class="keyword">end</span>
0372 <span class="keyword">end</span>
0373 <span class="comment">%img = data_mapper(img, 1); % move data from img.elem_data to whatever 'params'</span>
0374 
0375 <a name="_sub1" href="#_subfunctions" class="code">function show_meas_err(dvall, data0, k, N, W, opt)</a>
0376    clf;
0377    subplot(211); bar(dvall(:,k)); ylabel(sprintf(<span class="string">'dv_k [%s]'</span>,opt.meas_working)); xlabel(<span class="string">'meas #'</span>); title(sprintf(<span class="string">'iter %d'</span>,k));
0378    subplot(212); bar(<a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(dvall(:,k),N,opt.meas_working, <span class="string">'voltage'</span>)); ylabel(<span class="string">'dv_k [V]'</span>); xlabel(<span class="string">'meas #'</span>); title(<span class="string">''</span>);
0379    drawnow;
0380    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0381       print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-meas_err%d'</span>,opt.fig_prefix,k));
0382       print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-meas_err%d'</span>,opt.fig_prefix,k));
0383       saveas(gcf,sprintf(<span class="string">'%s-meas_err%d.fig'</span>,opt.fig_prefix,k));
0384    <span class="keyword">end</span>
0385    drawnow;
0386 
0387 <a name="_sub2" href="#_subfunctions" class="code">function img = init_elem_data(img, opt)</a>
0388   <span class="keyword">if</span> opt.verbose &gt; 1
0389     fprintf(<span class="string">'  setting prior elem_data\n'</span>);
0390   <span class="keyword">end</span>
0391   ne2 = 0; <span class="comment">% init</span>
0392   img.elem_data = zeros(sum([opt.elem_len{:}]),1); <span class="comment">% preallocate</span>
0393   <span class="keyword">for</span> i=1:length(opt.elem_prior)
0394     ne1 = ne2+1; <span class="comment">% next start idx ne1</span>
0395     ne2 = ne1+opt.elem_len{i}-1; <span class="comment">% this set ends at idx ne2</span>
0396     <span class="keyword">if</span> opt.verbose &gt; 1
0397       <span class="keyword">if</span> length(opt.prior_data{i}) == 1
0398         fprintf(<span class="string">'    %d x %s: %0.1f\n'</span>,opt.elem_len{i},opt.elem_prior{i}, opt.prior_data{i});
0399       <span class="keyword">else</span>
0400         fprintf(<span class="string">'    %d x %s: ...\n'</span>,opt.elem_len{i},opt.elem_prior{i});
0401         <span class="keyword">if</span> length(opt.prior_data{i}) ~= opt.elem_len{i}
0402            error(sprintf(<span class="string">'expected %d elem, got %d elem in elem_prior'</span>, <span class="keyword">...</span>
0403                          opt.elem_len{i}, length(opt.prior_data{i})));
0404         <span class="keyword">end</span>
0405       <span class="keyword">end</span>
0406     <span class="keyword">end</span>
0407     img.params_sel(i) = {ne1:ne2};
0408     img.elem_data(img.params_sel{i}) = opt.prior_data{i};
0409   <span class="keyword">end</span>
0410   img.current_params = opt.elem_prior;
0411 
0412 <a name="_sub3" href="#_subfunctions" class="code">function W = init_meas_icov(inv_model, opt)</a>
0413    W = 1;
0414    <span class="keyword">if</span> opt.calc_meas_icov
0415       <span class="keyword">if</span> opt.verbose &gt; 1
0416          disp(<span class="string">'  calc measurement inverse covariance W'</span>);
0417       <span class="keyword">end</span>
0418       W   = <a href="../../../eidors/solvers/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0419    <span class="keyword">end</span>
0420    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(W, <span class="string">'init_meas_icov'</span>);
0421 
0422 <a name="_sub4" href="#_subfunctions" class="code">function [N, dN] = init_normalization(fmdl, data0, opt)</a>
0423    <span class="comment">% precalculate the normalization of the data if required (apparent resistivity)</span>
0424    N = 1;
0425    dN = 1;
0426    vh1.meas = 1;
0427    <span class="keyword">if</span> ~ischar(opt.meas_input) || ~ischar(opt.meas_working)
0428       error(<span class="string">'expected strings for meas_input and meas_working'</span>);
0429    <span class="keyword">end</span>
0430    go =       any(strcmp({opt.meas_input, opt.meas_working},<span class="string">'apparent_resistivity'</span>));
0431    go = go || any(strcmp({opt.meas_input, opt.meas_working},<span class="string">'log_apparent_resistivity'</span>));
0432    go = go || any(strcmp({opt.meas_input, opt.meas_working},<span class="string">'log10_apparent_resistivity'</span>));
0433    <span class="keyword">if</span> go
0434       <span class="keyword">if</span> opt.verbose &gt; 1
0435          disp([<span class="string">'  calc measurement normalization matrix N (voltage -&gt; '</span> opt.meas_working <span class="string">')'</span>]);
0436       <span class="keyword">end</span>
0437       <span class="comment">% calculate geometric factor for apparent_resitivity conversions</span>
0438       img1 = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,1);
0439       vh1  = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img1);
0440       N    = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh1.meas);
0441       <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(N,  <span class="string">'init_normalization: N'</span>);
0442    <span class="keyword">end</span>
0443    <span class="keyword">if</span> go &amp;&amp; (opt.verbose &gt; 1)
0444       disp([<span class="string">'  calc Jacobian normalization matrix   dN (voltage -&gt; '</span> opt.meas_working <span class="string">')'</span>]);
0445    <span class="keyword">end</span>
0446    <span class="comment">% calculate the normalization factor for the Jacobian</span>
0447    data0 = <a href="#_sub29" class="code" title="subfunction data = map_meas_struct(data, N, out)">map_meas_struct</a>(data0, N, <span class="string">'voltage'</span>); <span class="comment">% to voltage</span>
0448    <span class="keyword">switch</span> opt.meas_working
0449       <span class="keyword">case</span> <span class="string">'apparent_resistivity'</span>
0450          dN = <a href="#_sub18" class="code" title="subfunction dN = da_dv(v,vh)">da_dv</a>(data0.meas, vh1.meas);
0451       <span class="keyword">case</span> <span class="string">'log_apparent_resistivity'</span>
0452          dN = <a href="#_sub19" class="code" title="subfunction dN = dloga_dv(v,vh)">dloga_dv</a>(data0.meas, vh1.meas);
0453       <span class="keyword">case</span> <span class="string">'log10_apparent_resistivity'</span>
0454          dN = <a href="#_sub20" class="code" title="subfunction dN = dlog10a_dv(v,vh)">dlog10a_dv</a>(data0.meas, vh1.meas);
0455       <span class="keyword">case</span> <span class="string">'voltage'</span>
0456          dN = <a href="#_sub21" class="code" title="subfunction dN = dv_dv(v,vh)">dv_dv</a>(data0.meas, vh1.meas);
0457       <span class="keyword">case</span> <span class="string">'log_voltage'</span>
0458          dN = <a href="#_sub22" class="code" title="subfunction dN = dlogv_dv(v,vh) ">dlogv_dv</a>(data0.meas, vh1.meas);
0459       <span class="keyword">case</span> <span class="string">'log10_voltage'</span>
0460          dN = <a href="#_sub23" class="code" title="subfunction dN = dlog10v_dv(v,vh) ">dlog10v_dv</a>(data0.meas, vh1.meas);
0461       <span class="keyword">otherwise</span>
0462          error(<span class="string">'hmm'</span>);
0463    <span class="keyword">end</span>
0464    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(dN, <span class="string">'init_normalization: dN'</span>);
0465 
0466 <span class="comment">% r_km1: previous residual, if its the first iteration r_km1 = inf</span>
0467 <span class="comment">% r_k: new residual</span>
0468 <a name="_sub5" href="#_subfunctions" class="code">function [stop, k, r, img] = update_residual(dv, img, de, W, hp2RtR, k, r, alpha, sx, opt)</a>
0469   stop = 0;
0470 
0471   <span class="comment">% update residual estimate</span>
0472   <span class="keyword">if</span> k == 0
0473      r = zeros(opt.max_iterations, 3);
0474      r_km1 = inf;
0475   <span class="keyword">else</span>
0476      r_km1 = r(k, 1);
0477   <span class="keyword">end</span>
0478   r_k = feval(opt.residual_func, dv, de, W, hp2RtR);
0479   <span class="comment">% save residual for next iteration</span>
0480   r(k+1,1) = r_k;
0481 
0482   <span class="comment">% now do something with that information</span>
0483   <span class="keyword">if</span> opt.verbose &gt; 1
0484      <span class="keyword">if</span> k == 0
0485         fprintf(<span class="string">'    calc residual, r=%0.3g\n'</span>, r_k);
0486      <span class="keyword">else</span>
0487         fprintf(<span class="string">'    calc residual\n'</span>);
0488         fprintf(<span class="string">'      r =%0.3g\n'</span>, r_k);
0489         dr = (r_k - r_km1);
0490         fprintf(<span class="string">'      dr=%0.3g (%0.3g%%)\n'</span>, dr, dr/r_km1*100);
0491      <span class="keyword">end</span>
0492   <span class="keyword">end</span>
0493   <span class="keyword">if</span> opt.plot_residuals
0494      <span class="comment">%         optimization_criteria, data misfit, roughness</span>
0495      r(k+1,2:3) = [(dv'*dv)/2 (de'*de)/2];
0496      <span class="keyword">if</span> k &gt; 0
0497         clf;
0498         x = 1:(k+1);
0499         y = r(x, :);
0500         y = y ./ repmat(max(y,[],1),size(y,1),1) * 100;
0501         plot(x-1, y, <span class="string">'o-'</span>, <span class="string">'linewidth'</span>, 2, <span class="string">'MarkerSize'</span>, 10);
0502         title(<span class="string">'residuals'</span>);
0503         axis tight;
0504         ylabel(<span class="string">'residual (% of max)'</span>);
0505         xlabel(<span class="string">'iteration'</span>);
0506         set(gca, <span class="string">'xtick'</span>, x);
0507         set(gca, <span class="string">'xlim'</span>, [0 max(x)-1]);
0508         legend(<span class="string">'residual'</span>,<span class="string">'meas. misfit'</span>,<span class="string">'prior misfit'</span>);
0509         legend(<span class="string">'Location'</span>, <span class="string">'EastOutside'</span>);
0510         drawnow;
0511         <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0512            print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-r%d'</span>,opt.fig_prefix,k));
0513            print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-r%d'</span>,opt.fig_prefix,k));
0514            saveas(gcf,sprintf(<span class="string">'%s-r%d.fig'</span>,opt.fig_prefix,k));
0515         <span class="keyword">end</span>
0516      <span class="keyword">end</span>
0517   <span class="keyword">end</span>
0518 
0519   <span class="comment">% TODO return 'measurement residual' &amp; 'roughness' for progress plot, as well</span>
0520   <span class="comment">% evaluate stopping criteria</span>
0521   <span class="keyword">if</span> r_k &gt; r_km1 <span class="comment">% bad step</span>
0522      <span class="keyword">if</span> opt.verbose &gt; 1
0523         fprintf(<span class="string">'  terminated at iteration %d (bad step, returning previous iteration''s result)\n'</span>,k);
0524      <span class="keyword">end</span>
0525      img.elem_data = img.elem_data - alpha * sx; <span class="comment">% undo the last step</span>
0526      stop = -1;
0527   <span class="keyword">elseif</span> k &gt;= opt.max_iterations
0528      <span class="keyword">if</span> opt.verbose &gt; 1
0529         fprintf(<span class="string">'  terminated at iteration %d (max iterations)\n'</span>,k);
0530      <span class="keyword">end</span>
0531      stop = 1;
0532   <span class="keyword">elseif</span> r_k &lt; opt.tol + opt.ntol
0533      <span class="keyword">if</span> opt.verbose &gt; 1
0534         fprintf(<span class="string">'  terminated at iteration %d\n'</span>,k);
0535         fprintf(<span class="string">'    residual tolerance (%0.3g) achieved\n'</span>, opt.tol + opt.ntol);
0536      <span class="keyword">end</span>
0537      stop = 1;
0538   <span class="keyword">elseif</span> (k &gt;= opt.dtol_iter) &amp;&amp; ((r_k - r_km1)/r_km1 &gt; opt.dtol + 2*opt.ntol)
0539      <span class="keyword">if</span> opt.verbose &gt; 1
0540         fprintf(<span class="string">'  terminated at iteration %d (iterations not improving)\n'</span>, k);
0541         fprintf(<span class="string">'    residual slope tolerance (%0.3g) exceeded\n'</span>, opt.dtol + 2*opt.ntol);
0542      <span class="keyword">end</span>
0543      stop = 1;
0544   <span class="keyword">end</span>
0545   <span class="keyword">if</span> ~stop
0546      <span class="comment">% update iteration count</span>
0547      k = k+1;
0548   <span class="keyword">end</span>
0549 
0550 <span class="comment">% for Conjugate Gradient, else beta = 0</span>
0551 <span class="comment">%  dx_k, dx_{k-1}, sx_{k-1}</span>
0552 <a name="_sub6" href="#_subfunctions" class="code">function beta = update_beta(dx_k, dx_km1, sx_km1, opt);</a>
0553    <span class="keyword">if</span> isfield(opt, <span class="string">'beta_func'</span>)
0554       <span class="keyword">if</span> opt.verbose &gt; 1
0555          <span class="keyword">try</span> beta_str = func2str(opt.beta_func);
0556          <span class="keyword">catch</span>
0557             <span class="keyword">try</span> beta_str = opt.beta_func;
0558             <span class="keyword">catch</span> beta_str = <span class="string">'unknown'</span>;
0559             <span class="keyword">end</span>
0560          <span class="keyword">end</span>
0561       <span class="keyword">end</span>
0562       beta= feval(opt.beta_func, dx_k, dx_km1, sx_km1);
0563    <span class="keyword">else</span>
0564      beta_str = <span class="string">'&lt;none&gt;'</span>;
0565      beta = 0;
0566    <span class="keyword">end</span>
0567    <span class="keyword">if</span> opt.verbose &gt; 1
0568       str = sprintf(<span class="string">'    calc beta (%s)=%0.3f\n'</span>, beta_str, beta);
0569    <span class="keyword">end</span>
0570 
0571 <span class="comment">% update the search direction</span>
0572 <span class="comment">% for Gauss-Newton</span>
0573 <span class="comment">%   sx_k = dx_k</span>
0574 <span class="comment">% for Conjugate-Gradient</span>
0575 <span class="comment">%   sx_k = dx_k + beta * sx_{k-1}</span>
0576 <a name="_sub7" href="#_subfunctions" class="code">function sx = update_sx(dx, beta, sx_km1, opt);</a>
0577    sx = dx + beta * sx_km1;
0578    <span class="keyword">if</span>(opt.verbose &gt; 1)
0579       nsx = norm(sx);
0580       nsxk = norm(sx_km1);
0581       fprintf( <span class="string">'    update step dx, beta=%0.3g, ||dx||=%0.3g\n'</span>, beta, nsx);
0582       <span class="keyword">if</span> nsxk ~= 0
0583          fprintf( <span class="string">'      acceleration     d||dx||=%0.3g\n'</span>, nsx-nsxk);
0584          fprintf( <span class="string">'      direction change ||ddx||=%0.3g\n'</span>, norm(sx/nsx-sx_km1/nsxk));
0585       <span class="keyword">end</span>
0586    <span class="keyword">end</span>
0587 
0588 <span class="comment">% this function constructs the blockwise RtR matrix</span>
0589 <a name="_sub8" href="#_subfunctions" class="code">function hp2RtR = update_hp2RtR(inv_model, J, k, img, opt)</a>
0590    <span class="keyword">if</span> k==0 <span class="comment">% first the start up iteration use the initial hyperparameter</span>
0591       k=1;
0592    <span class="keyword">end</span>
0593    <span class="comment">% TODO sometimes (with Noser?) this requires the Jacobian, could this be done more efficiently?</span>
0594    <span class="comment">% add a test function to determine if img.elem_data affects RtR, skip this if independant</span>
0595    <span class="comment">% TODO we could detect in the opt_parsing whether the calc_RtR_prior depends on 'x' and skip this if no</span>
0596    <span class="keyword">if</span> ~opt.calc_RtR_prior
0597       error(<span class="string">'no RtR calculation mechanism, set imdl.inv_solve_abs_core.RtR_prior or imdl.RtR_prior'</span>);
0598    <span class="keyword">end</span>
0599    <span class="keyword">if</span> opt.verbose &gt; 1
0600       disp(<span class="string">'    calc hp^2 R^t R'</span>);
0601    <span class="keyword">end</span>
0602    hp2  = <a href="../../../eidors/solvers/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model ); <span class="comment">% = \lambda^2</span>
0603    net = sum([opt.elem_len{:}]); <span class="comment">% Number of Elements, Total</span>
0604    RtR = zeros(net,net); <span class="comment">% pre-allocate RtR</span>
0605    esi = 0; eei = 0; <span class="comment">% element start, element end</span>
0606    <span class="keyword">for</span> i = 1:size(opt.RtR_prior,1) <span class="comment">% row i</span>
0607       esi = eei + 1;
0608       eei = eei + opt.elem_len{i};
0609       esj = 0; eej = 0; <span class="comment">% element start, element end</span>
0610       <span class="keyword">for</span> j = 1:size(opt.RtR_prior,2) <span class="comment">% column j</span>
0611          esj = eej + 1;
0612          eej = eej + opt.elem_len{j};
0613          <span class="keyword">if</span> isempty(opt.RtR_prior{i,j}) <span class="comment">% null entries</span>
0614             <span class="keyword">continue</span>; <span class="comment">% no need to explicitly create zero block matrices</span>
0615          <span class="keyword">end</span>
0616 
0617          <span class="comment">% select a hyperparameter, potentially, per iteration</span>
0618          <span class="comment">% if we're at the end of the list, select the last entry</span>
0619          hp=opt.hyperparameter{i,j};
0620          <span class="keyword">if</span> length(hp) &gt; k
0621             hp=hp(k);
0622          <span class="keyword">else</span>
0623             hp=hp(end);
0624          <span class="keyword">end</span>
0625 
0626          <span class="keyword">if</span> opt.verbose &gt; 1
0627             <span class="keyword">try</span> RtR_str = func2str(opt.RtR_prior{i,j});
0628             <span class="keyword">catch</span>
0629                <span class="keyword">try</span> RtR_str = opt.RtR_prior{i,j};
0630                <span class="keyword">catch</span> RtR_str = <span class="string">'unknown'</span>;
0631                <span class="keyword">end</span>
0632             <span class="keyword">end</span>
0633             fprintf(<span class="string">'      {%d,%d} regularization RtR (%s), ne=%dx%d, hp=%0.4g\n'</span>, i,j,RtR_str,eei-esi+1,eej-esj+1,hp*sqrt(hp2));
0634          <span class="keyword">end</span>
0635          imgt = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, opt.elem_working{i});
0636          inv_modelt = inv_model;
0637          inv_modelt.RtR_prior = opt.RtR_prior{i,j};
0638          RtR(esi:eei, esj:eej) = hp.^2 * <a href="#_sub11" class="code" title="subfunction RtR = calc_RtR_prior_wrapper(inv_model, img, opt)">calc_RtR_prior_wrapper</a>(inv_modelt, imgt, opt);
0639       <span class="keyword">end</span>
0640    <span class="keyword">end</span>
0641    hp2RtR = hp2*RtR;
0642 
0643 <a name="_sub9" href="#_subfunctions" class="code">function plot_svd_elem(J, W, hp2RtR, k, sx, dx, img, opt)</a>
0644    <span class="keyword">if</span> opt.verbose &lt; 1
0645       <span class="keyword">return</span>; <span class="comment">% do nothing if not verbose</span>
0646    <span class="keyword">end</span>
0647    <span class="comment">% canonicalize the structures so we don't have to deal with a bunch of scenarios below</span>
0648    <span class="keyword">if</span> ~isfield(img, <span class="string">'params_sel'</span>)
0649       img.params_sel = {1:length(img.elem_data)};
0650    <span class="keyword">end</span>
0651    <span class="keyword">if</span> ~isfield(img, <span class="string">'current_params'</span>)
0652       img.current_params = <span class="string">'conductivity'</span>;
0653    <span class="keyword">end</span>
0654    <span class="keyword">if</span> ~iscell(img.current_params)
0655       img.current_params = {img.current_params};
0656    <span class="keyword">end</span>
0657    <span class="comment">% go</span>
0658    cols=length(opt.elem_working);
0659    <span class="keyword">if</span> norm(sx - dx) &lt; <a href="#_sub50" class="code" title="subfunction x=range(y)">range</a>(dx)/max(dx)*0.01 <span class="comment">% sx and dx are within 1%</span>
0660       rows=2;
0661    <span class="keyword">else</span>
0662       rows=3;
0663    <span class="keyword">end</span>
0664    clf; <span class="comment">% individual SVD plots</span>
0665    <span class="keyword">for</span> i=1:cols
0666       <span class="keyword">if</span> 1 <span class="comment">% if Tikhonov</span>
0667          hp=opt.hyperparameter{i};
0668          <span class="keyword">if</span> k ~= 0 &amp;&amp; k &lt; length(hp)
0669             hp = hp(k);
0670          <span class="keyword">else</span>
0671             hp = hp(end);
0672          <span class="keyword">end</span>
0673       <span class="keyword">else</span>
0674          hp = [];
0675       <span class="keyword">end</span>
0676       sel=img.params_sel{i};
0677       str=strrep(img.current_params{i},<span class="string">'_'</span>,<span class="string">' '</span>);
0678       <a href="#_sub10" class="code" title="subfunction plot_svd(J, W, hp2RtR, k, hp)">plot_svd</a>(J(:,sel), W, hp2RtR(sel,sel), k, hp); xlabel(str);
0679       drawnow;
0680       <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0681          print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-svd%d-%s'</span>,opt.fig_prefix,k,img.current_params{i}));
0682          print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-svd%d-%s'</span>,opt.fig_prefix,k,img.current_params{i}));
0683          saveas(gcf,sprintf(<span class="string">'%s-svd%d-%s.fig'</span>,opt.fig_prefix,k,img.current_params{i}));
0684       <span class="keyword">end</span>
0685    <span class="keyword">end</span>
0686    clf; <span class="comment">% combo plot</span>
0687    <span class="keyword">for</span> i=1:cols
0688       <span class="keyword">if</span> 1 <span class="comment">% if Tikhonov</span>
0689          hp=opt.hyperparameter{i};
0690          <span class="keyword">if</span> k ~= 0 &amp;&amp; k &lt; length(hp)
0691             hp = hp(k);
0692          <span class="keyword">else</span>
0693             hp = hp(end);
0694          <span class="keyword">end</span>
0695       <span class="keyword">else</span>
0696          hp = [];
0697       <span class="keyword">end</span>
0698       subplot(rows,cols,i);
0699       sel=img.params_sel{i};
0700       str=strrep(img.current_params{i},<span class="string">'_'</span>,<span class="string">' '</span>);
0701       <a href="#_sub10" class="code" title="subfunction plot_svd(J, W, hp2RtR, k, hp)">plot_svd</a>(J(:,sel), W, hp2RtR(sel,sel), k, hp); xlabel(str);
0702       subplot(rows,cols,cols+i);
0703       bar(dx(sel)); ylabel([<span class="string">'dx: '</span> str]);
0704       <span class="keyword">if</span> rows &gt; 2
0705          subplot(rows,cols,2*cols+i);
0706          bar(sx(sel)); ylabel([<span class="string">'sx: '</span> str]);
0707       <span class="keyword">end</span>
0708    <span class="keyword">end</span>
0709    drawnow;
0710    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0711       print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-svd%d'</span>,opt.fig_prefix,k));
0712       print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-svd%d'</span>,opt.fig_prefix,k));
0713       saveas(gcf,sprintf(<span class="string">'%s-svd%d.fig'</span>,opt.fig_prefix,k));
0714    <span class="keyword">end</span>
0715 
0716 <a name="_sub10" href="#_subfunctions" class="code">function plot_svd(J, W, hp2RtR, k, hp)</a>
0717    <span class="keyword">if</span> nargin &lt; 5
0718       hp = [];
0719    <span class="keyword">end</span>
0720    <span class="comment">% calculate the singular values before and after regularization</span>
0721    [~,s1,~]=svd(J'*W*J); s1=sqrt(diag(s1));
0722    [~,s2,~]=svd(J'*W*J + hp2RtR); s2=sqrt(diag(s2));
0723    h=semilogy(s1,<span class="string">'bx'</span>); axis tight; set(h,<span class="string">'LineWidth'</span>,2);
0724    hold on; h=semilogy(s2,<span class="string">'go'</span>); axis tight; set(h,<span class="string">'LineWidth'</span>,2); hold off;
0725    xlabel(<span class="string">'k'</span>); ylabel(<span class="string">'value \sigma'</span>);
0726    title(sprintf(<span class="string">'singular values of J at iteration %d'</span>,k));
0727    legend(<span class="string">'J^T J'</span>, <span class="string">'J^T J + \lambda^2 R^T R'</span>); legend location best;
0728    <span class="comment">% line for \lambda</span>
0729 <span class="comment">%     if regularization == 2 % Noser</span>
0730 <span class="comment">%        hp_scaled = hp*sqrt(norm(full(RtR)));</span>
0731 <span class="comment">%        h=line([1 length(s1)],[hp_scaled hp_scaled]);</span>
0732 <span class="comment">%        text(length(s1)/2,hp_scaled*0.9,sprintf('\\lambda ||R^T R||^{%0.1f}= %0.4g; \\lambda = %0.4g', noser_p, hp_scaled, hp));</span>
0733 <span class="comment">%        fprintf('  affecting %d of %d singular values\k', length(find(s1&lt;hp_scaled)), length(s1));</span>
0734 <span class="comment">%     else % Tikhonov</span>
0735    <span class="keyword">if</span> length(hp)==1
0736         h=line([1 length(s1)],[hp hp]);
0737         ly=10^(log10(hp)-0.05*<a href="#_sub50" class="code" title="subfunction x=range(y)">range</a>(log10([s1;s2])));
0738         text(length(s1)/2,ly,sprintf(<span class="string">'\\lambda = %0.4g'</span>, hp));
0739 <span class="comment">%       fprintf('  affecting %d of %d singular values\k', length(find(s1&lt;hp)), length(s1));</span>
0740      <span class="keyword">end</span>
0741      set(h,<span class="string">'LineStyle'</span>,<span class="string">'-.'</span>); set(h,<span class="string">'LineWidth'</span>,2);
0742    set(gca,<span class="string">'YMinorTick'</span>,<span class="string">'on'</span>, <span class="string">'YMinorGrid'</span>, <span class="string">'on'</span>, <span class="string">'YGrid'</span>, <span class="string">'on'</span>);
0743 
0744 
0745 <span class="comment">% TODO this function is one giant HACK around broken RtR generation with c2f matrices</span>
0746 <a name="_sub11" href="#_subfunctions" class="code">function RtR = calc_RtR_prior_wrapper(inv_model, img, opt)</a>
0747    RtR = <a href="../../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>( inv_model );
0748    <span class="keyword">if</span> size(RtR,1) &lt; length(img.elem_data)
0749      ne = length(img.elem_data) - size(RtR,1);
0750      <span class="comment">% we are correcting for the added background element</span>
0751      <span class="keyword">for</span> i=1:ne
0752        RtR(end+1:end+1, end+1:end+1) = RtR(1,1);
0753      <span class="keyword">end</span>
0754      <span class="keyword">if</span> opt.verbose &gt; 1
0755         fprintf(<span class="string">'      c2f: adjusting RtR by appending %d rows/cols\n'</span>, ne);
0756         disp(   <span class="string">'      TODO move this fix, or something like it to calc_RtR_prior -- this fix is a quick HACK to get things to run...'</span>);
0757      <span class="keyword">end</span>
0758    <span class="keyword">end</span>
0759 
0760 <span class="comment">% opt is only updated for the fwd_solve count</span>
0761 <a name="_sub12" href="#_subfunctions" class="code">function [J, opt] = update_jacobian(img, dN, k, opt)</a>
0762    k=k+1;
0763    base_types = <a href="#_sub45" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img);
0764    imgb = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, base_types);
0765    imgb = feval(opt.update_img_func, imgb, opt);
0766    <span class="comment">% if the electrodes/geometry moved, we need to recalculate dN if it depends on vh</span>
0767    <span class="comment">% note that only apparent_resisitivity needs vh; all others depend on data0 measurements</span>
0768    <span class="keyword">if</span> any(strcmp(<a href="#_sub45" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img), <span class="string">'movement'</span>)) &amp;&amp; any(strcmp(opt.meas_working, <span class="string">'apparent_resistivity'</span>))
0769       imgh = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgb, <span class="string">'conductivity'</span>); <span class="comment">% drop everything but conductivity</span>
0770       imgh.elem_data = imgh.elem_data*0 +1; <span class="comment">% conductivity = 1</span>
0771       vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh); vh = vh.meas;
0772       dN = <a href="#_sub18" class="code" title="subfunction dN = da_dv(v,vh)">da_dv</a>(1,vh); <span class="comment">% = diag(1/vh)</span>
0773       opt.fwd_solutions = opt.fwd_solutions +1;
0774    <span class="keyword">end</span>
0775    ee = 0; <span class="comment">% element select, init</span>
0776    pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>(imgb.fwd_model);
0777    J = zeros(pp.n_meas,sum([opt.elem_len{:}]));
0778    <span class="keyword">for</span> i=1:length(opt.jacobian)
0779      <span class="keyword">if</span>(opt.verbose &gt; 1)
0780         <span class="keyword">try</span> J_str = func2str(opt.jacobian{i});
0781         <span class="keyword">catch</span> J_str = opt.jacobian{i};
0782         <span class="keyword">end</span>
0783         <span class="keyword">if</span> i == 1 fprintf(<span class="string">'    calc Jacobian J(x) = '</span>);
0784         <span class="keyword">else</span>      fprintf(<span class="string">'                       + '</span>); <span class="keyword">end</span>
0785         fprintf(<span class="string">'(%s,'</span>, J_str);
0786      <span class="keyword">end</span>
0787      <span class="comment">% start and end of these Jacobian columns</span>
0788      es = ee+1;
0789      ee = es+opt.elem_len{i}-1;
0790      <span class="comment">% scaling if we are working in something other than direct conductivity</span>
0791      S = feval(opt.calc_jacobian_scaling_func{i}, imgb.elem_data(es:ee)); <span class="comment">% chain rule</span>
0792      <span class="comment">% finalize the jacobian</span>
0793      <span class="comment">% Note that if a normalization (i.e. apparent_resistivity) has been applied</span>
0794      <span class="comment">% to the measurements, it needs to be applied to the Jacobian as well!</span>
0795      imgt = imgb;
0796      <span class="keyword">if</span>  strcmp(base_types{i}, <span class="string">'conductivity'</span>) <span class="comment">% make legacy jacobian calculators happy... only conductivity on imgt.elem_data</span>
0797         imgt = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>);
0798      <span class="keyword">end</span>
0799      imgt.fwd_model.jacobian = opt.jacobian{i};
0800      Jn = <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( imgt ); <span class="comment">% unscaled natural units (i.e. conductivity)</span>
0801      J(:,es:ee) = dN * Jn * S; <span class="comment">% scaled and normalized</span>
0802      <span class="keyword">if</span> opt.verbose &gt; 1
0803         tmp = zeros(1,size(J,2));
0804         tmp(es:ee) = 1;
0805         tmp(opt.elem_fixed) = 0;
0806         fprintf(<span class="string">' %d DoF, %d meas, %s)\n'</span>, sum(tmp), size(J,1), func2str(opt.calc_jacobian_scaling_func{i}));
0807      <span class="keyword">end</span>
0808      <span class="keyword">if</span> opt.verbose &gt;= 5
0809         clf;
0810         t=axes(<span class="string">'Position'</span>,[0 0 1 1],<span class="string">'Visible'</span>,<span class="string">'off'</span>); <span class="comment">% something to put our title on after we're done</span>
0811         text(0.03,0.1,sprintf(<span class="string">'update\\_jacobian (%s), iter=%d'</span>, strrep(J_str,<span class="string">'_'</span>,<span class="string">'\_'</span>), k),<span class="string">'FontSize'</span>,20,<span class="string">'Rotation'</span>,90);
0812         <span class="keyword">for</span> y=0:1
0813            <span class="keyword">if</span> y == 0; D = Jn; <span class="keyword">else</span> D = J(:,es:ee); <span class="keyword">end</span>
0814            axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.13 0.62-y/2 0.8 0.3 ]);
0815            imagesc(D);
0816            <span class="keyword">if</span> y == 0; ylabel(<span class="string">'meas (1)'</span>); xlabel([<span class="string">'elem ('</span> strrep(base_types{i},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">')'</span>]);
0817            <span class="keyword">else</span>       ylabel(<span class="string">'meas (dN)'</span>); xlabel([<span class="string">'elem ('</span> strrep(opt.elem_working{i},<span class="string">'_'</span>,<span class="string">'\_'</span>) <span class="string">')'</span>]);
0818            <span class="keyword">end</span>
0819            os = get(gca, <span class="string">'Position'</span>); c=colorbar(<span class="string">'southoutside'</span>); <span class="comment">% colorbar start...</span>
0820            set(gca, <span class="string">'Position'</span>, os); <span class="comment">% fix STUPID colorbar resizing</span>
0821            <span class="comment">% reduce height, this has to be done after the axes fix or STUPID matlab messes things up real good</span>
0822            cP = get(c,<span class="string">'Position'</span>); set(c,<span class="string">'Position'</span>, [0.13    0.54-y/2    0.8    0.010]);
0823            axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.93 0.62-y/2 0.05 0.3 ]);
0824            barh(sum(D,2)); axis tight; axis ij; set(gca, <span class="string">'ytick'</span>, [], <span class="string">'yticklabel'</span>, []);
0825            axes(<span class="string">'units'</span>, <span class="string">'normalized'</span>, <span class="string">'position'</span>, [ 0.13 0.92-y/2 0.8 0.05 ]);
0826            bar(sum(D,1)); axis tight; set(gca, <span class="string">'xtick'</span>, [], <span class="string">'xticklabel'</span>, []);
0827         <span class="keyword">end</span>
0828         drawnow;
0829         <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
0830            print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-J%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
0831            print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-J%d-%s'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
0832            saveas(gcf,sprintf(<span class="string">'%s-J%d-%s.fig'</span>,opt.fig_prefix,k,strrep(J_str,<span class="string">'_'</span>,<span class="string">''</span>)));
0833         <span class="keyword">end</span>
0834      <span class="keyword">end</span>
0835    <span class="keyword">end</span>
0836 
0837 <span class="comment">% -------------------------------------------------</span>
0838 <span class="comment">% Chain Rule Products for Jacobian Translations</span>
0839 <span class="comment">% x is conductivity, we want the chain rule to translate the</span>
0840 <span class="comment">% Jacobian of conductivity to conductivity on resistivity or</span>
0841 <span class="comment">% logs of either.</span>
0842 <span class="comment">% This chain rule works out to a constant.</span>
0843 <span class="comment">%</span>
0844 <span class="comment">% d log_b(x)     1          d x</span>
0845 <span class="comment">% ---------- = ------- , ---------- = x ln(b)</span>
0846 <span class="comment">%     d x      x ln(b)   d log_b(x)</span>
0847 <a name="_sub13" href="#_subfunctions" class="code">function S = dx_dlogx(x);</a>
0848    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(x);
0849 <a name="_sub14" href="#_subfunctions" class="code">function S = dx_dlog10x(x);</a>
0850    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(x * log(10));
0851 <span class="comment">% resistivity 'y'</span>
0852 <span class="comment">% d x     d x   -1</span>
0853 <span class="comment">% ----- = --- = ---, y = 1/x --&gt; -(x^2)</span>
0854 <span class="comment">% d 1/x   d y   y^2</span>
0855 <a name="_sub15" href="#_subfunctions" class="code">function S = dx_dy(x);</a>
0856    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-(x.^2));
0857 <span class="comment">% then build the log versions of conductivity by combining chain rule products</span>
0858 <a name="_sub16" href="#_subfunctions" class="code">function S = dx_dlogy(x);</a>
0859 <span class="comment">%   S = dx_dy(x) * dy_dlogy(x);</span>
0860 <span class="comment">%     = -(x^2) * 1/x = -x</span>
0861    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-x);
0862 <a name="_sub17" href="#_subfunctions" class="code">function S = dx_dlog10y(x);</a>
0863 <span class="comment">%   S = dx_dy(x) * dy_dlog10y(x);</span>
0864 <span class="comment">%     = -(x^2) * 1/(ln(10) x) = -x / ln(10)</span>
0865    S = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(-x/log(10));
0866 <span class="comment">% ... some renaming to make things understandable above: x = 1/y</span>
0867 <span class="comment">%function S = dy_dlogy(x);</span>
0868 <span class="comment">%   S = dx_dlogx(1./x);</span>
0869 <span class="comment">%function S = dy_dlog10y(x);</span>
0870 <span class="comment">%   S = dx_dlog10x(1./x);</span>
0871 <span class="comment">% -------------------------------------------------</span>
0872 <span class="comment">% apparent_resistivity 'a' versus voltage 'x'</span>
0873 <span class="comment">% d a    1  d v    1         v</span>
0874 <span class="comment">% --- = --- --- = --- ; a = ---</span>
0875 <span class="comment">% d v    vh d v    vh        vh</span>
0876 <span class="comment">% log_apparent_resistivity</span>
0877 <span class="comment">% d loga   d loga d a    1   1     vh  1     1</span>
0878 <span class="comment">% ------ = ------ --- = --- --- = --- --- = ---</span>
0879 <span class="comment">% d v       d a   d v    a   vh    v   vh    v</span>
0880 <a name="_sub18" href="#_subfunctions" class="code">function dN = da_dv(v,vh)</a>
0881    dN = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh); <span class="comment">% N == dN for apparent_resistivity</span>
0882 <a name="_sub19" href="#_subfunctions" class="code">function dN = dloga_dv(v,vh)</a>
0883    dN = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./v);
0884 <a name="_sub20" href="#_subfunctions" class="code">function dN = dlog10a_dv(v,vh)</a>
0885    dN = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>( 1./(v * log(10)) );
0886 <a name="_sub21" href="#_subfunctions" class="code">function dN = dv_dv(v,vh)</a>
0887    dN = 1;
0888 <a name="_sub22" href="#_subfunctions" class="code">function dN = dlogv_dv(v,vh) </a><span class="comment">% same as dloga_dv</span>
0889    dN = <a href="#_sub19" class="code" title="subfunction dN = dloga_dv(v,vh)">dloga_dv</a>(v,vh);
0890 <a name="_sub23" href="#_subfunctions" class="code">function dN = dlog10v_dv(v,vh) </a><span class="comment">% same as dlog10a_dv</span>
0891    dN = <a href="#_sub20" class="code" title="subfunction dN = dlog10a_dv(v,vh)">dlog10a_dv</a>(v, vh);
0892 <span class="comment">% -------------------------------------------------</span>
0893 
0894 
0895 <a name="_sub24" href="#_subfunctions" class="code">function [alpha, img, dv, opt] = update_alpha(img, sx, data0, img0, N, W, hp2RtR, k, dv, opt)</a>
0896   <span class="keyword">if</span> k == 0 <span class="comment">% first iteration, just setting up, no line search happens</span>
0897      alpha = 0;
0898      <span class="keyword">return</span>;
0899   <span class="keyword">end</span>
0900 
0901   <span class="keyword">if</span>(opt.verbose &gt; 1)
0902      <span class="keyword">try</span> ls_str = func2str(opt.line_search_func);
0903      <span class="keyword">catch</span> ls_str = opt.line_search_func;
0904      <span class="keyword">end</span>
0905      fprintf(<span class="string">'    line search, alpha = %s\n'</span>, ls_str);
0906   <span class="keyword">end</span>
0907 
0908   <span class="comment">% some sanity checks before we feed this information to the line search</span>
0909   <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(sx, <span class="string">'sx (pre-line search)'</span>);
0910   <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img.elem_data (pre-line search)'</span>);
0911 
0912   <span class="keyword">if</span> any(size(img.elem_data) ~= size(sx))
0913      error(sprintf(<span class="string">'mismatch on elem_data[%d,%d] vs. sx[%d,%d] vector sizes, check c2f_background_fixed'</span>,size(img.elem_data), size(sx)));
0914   <span class="keyword">end</span>
0915 
0916   [alpha, imgo, dv, opto] = feval(opt.line_search_func, img, sx, data0, img0, N, W, hp2RtR, dv, opt);
0917   <span class="keyword">if</span> ~isempty(imgo)
0918      img = imgo;
0919   <span class="keyword">else</span>
0920      img.elem_data = img.elem_data + alpha*sx;
0921   <span class="keyword">end</span>
0922   <span class="keyword">if</span> ~isempty(opto)
0923      opt = opto;
0924   <span class="keyword">end</span>
0925 
0926   <span class="keyword">if</span>(opt.verbose &gt; 1)
0927      fprintf(<span class="string">'      selected alpha=%0.3g\n'</span>, alpha);
0928   <span class="keyword">end</span>
0929 
0930   <span class="keyword">if</span> (alpha == 0) &amp;&amp; (k == 1)
0931     error(<span class="string">'first iteration failed to advance solution'</span>);
0932   <span class="keyword">end</span>
0933 
0934 <a name="_sub25" href="#_subfunctions" class="code">function err_if_inf_or_nan(x, str);</a>
0935   <span class="keyword">if</span> any(any(isnan(x) | isinf(x)))
0936       error(sprintf(<span class="string">'bad %s (%d NaN, %d Inf of %d)'</span>, <span class="keyword">...</span>
0937                     str, <span class="keyword">...</span>
0938                     length(find(isnan(x))), <span class="keyword">...</span>
0939                     length(find(isinf(x))), <span class="keyword">...</span>
0940                     length(x(:))));
0941   <span class="keyword">end</span>
0942 
0943 
0944 <a name="_sub26" href="#_subfunctions" class="code">function [img, dv] = update_img_using_limits(img, img0, data0, N, dv, opt)</a>
0945   <span class="comment">% fix max/min values for x</span>
0946   <span class="keyword">if</span> opt.max_value ~= +inf
0947      lih = find(img.elem_data &gt; opt.max_value);
0948      img.elem_data(lih) = opt.max_value;
0949      <span class="keyword">if</span> opt.verbose &gt; 1
0950         fprintf(<span class="string">'    limit max(x)=%g for %d elements\n'</span>, opt.max_value, length(lih));
0951      <span class="keyword">end</span>
0952      dv = []; <span class="comment">% dv is now invalid since we changed the conductivity</span>
0953   <span class="keyword">end</span>
0954   <span class="keyword">if</span> opt.min_value ~= -inf
0955      lil = find(img.elem_data &lt; opt.min_value);
0956      img.elem_data(lil) = opt.min_value;
0957      <span class="keyword">if</span> opt.verbose &gt; 1
0958         fprintf(<span class="string">'    limit min(x)=%g for %d elements\n'</span>, opt.min_value, length(lil));
0959      <span class="keyword">end</span>
0960      dv = []; <span class="comment">% dv is now invalid since we changed the conductivity</span>
0961   <span class="keyword">end</span>
0962   <span class="comment">% update voltage change estimate if the limit operation changed the img data</span>
0963   [dv, opt] = <a href="#_sub28" class="code" title="subfunction [dv, opt] = update_dv(dv, img, data0, N, opt, reason)">update_dv</a>(dv, img, data0, N, opt, <span class="string">'(dv out-of-date)'</span>);
0964 
0965 <a name="_sub27" href="#_subfunctions" class="code">function  de = update_de(de, img, img0, opt)</a>
0966    img0 = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, opt.elem_working);
0967    img  = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img,  opt.elem_working);
0968    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img0.elem_data, <span class="string">'de img0'</span>);
0969    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data,  <span class="string">'de img'</span>);
0970    <span class="comment">% probably not the most robust check for whether this is the first update</span>
0971    <span class="comment">% but this ensures that we get exactly zero for the first iteration and not</span>
0972    <span class="comment">% a set of values that has numeric floating point errors that are nearly zero</span>
0973    <span class="keyword">if</span> isempty(de) <span class="comment">% first iteration</span>
0974       <span class="comment">% data hasn't changed yet!</span>
0975       de = zeros(size(img0.elem_data));
0976    <span class="keyword">else</span>
0977       de = img0.elem_data - img.elem_data;
0978    <span class="keyword">end</span>
0979    de(opt.elem_fixed) = 0; <span class="comment">% TODO is this redundant... delete me?</span>
0980    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(de, <span class="string">'de out'</span>);
0981 
0982 <a name="_sub28" href="#_subfunctions" class="code">function [dv, opt] = update_dv(dv, img, data0, N, opt, reason)</a>
0983    <span class="comment">% estimate current error as a residual</span>
0984    <span class="keyword">if</span> ~isempty(dv) <span class="comment">% need to calculate dv...</span>
0985       <span class="keyword">return</span>;
0986    <span class="keyword">end</span>
0987    <span class="keyword">if</span> nargin &lt; 7
0988       reason = <span class="string">''</span>;
0989    <span class="keyword">end</span>
0990    <span class="keyword">if</span> opt.verbose &gt; 1
0991       disp([<span class="string">'    fwd_solve b=Ax '</span>, reason]);
0992    <span class="keyword">end</span>
0993    [dv, opt, err] = <a href="#_sub30" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>(img, data0, N, opt);
0994 <span class="comment">% TODO AB inject the img.error here, so it doesn't need to be recalculated when calc_solution_error=1</span>
0995 <span class="comment">%   img.error = err;</span>
0996 
0997 <a name="_sub29" href="#_subfunctions" class="code">function data = map_meas_struct(data, N, out)</a>
0998    <span class="keyword">try</span>   current_meas_params = data.current_params;
0999    <span class="keyword">catch</span> current_meas_params = <span class="string">'voltage'</span>;
1000    <span class="keyword">end</span>
1001    data.meas = <a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(data.meas, N, current_meas_params, out);
1002    data.current_params = out;
1003    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(data.meas, <span class="string">'dv meas'</span>);
1004 
1005 <span class="comment">% also used by the line search as opt.line_search_dv_func</span>
1006 <a name="_sub30" href="#_subfunctions" class="code">function [dv, opt, err] = update_dv_core(img, data0, N, opt)</a>
1007    data0 = <a href="#_sub29" class="code" title="subfunction data = map_meas_struct(data, N, out)">map_meas_struct</a>(data0, N, <span class="string">'voltage'</span>);
1008    img = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <a href="#_sub45" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img));
1009    img = feval(opt.update_img_func, img, opt);
1010    img = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>); <span class="comment">% drop everything but conductivity</span>
1011    <span class="comment">% if the electrodes/geometry moved, we need to recalculate N if it's being used</span>
1012    <span class="keyword">if</span> any(any(N ~= 1)) &amp;&amp; any(strcmp(<a href="#_sub45" class="code" title="subfunction out = map_img_base_types(img)">map_img_base_types</a>(img), <span class="string">'movement'</span>))
1013       <span class="comment">% note: data0 is mapped back to 'voltage' before N is modified</span>
1014       imgh=img; imgh.elem_data = imgh.elem_data*0 +1; <span class="comment">% conductivity = 1</span>
1015       vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgh); vh = vh.meas;
1016       N = <a href="../../../eidors/overloads/spdiag.html" class="code" title="function S = spdiag(V,K)">spdiag</a>(1./vh);
1017       opt.fwd_solutions = opt.fwd_solutions +1;
1018    <span class="keyword">end</span>
1019    data = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
1020    opt.fwd_solutions = opt.fwd_solutions +1;
1021    dv = <a href="../../../eidors/solvers/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>(data, data0, img.fwd_model);
1022    <span class="keyword">if</span> nargout &gt;= 3
1023       err = norm(dv)/norm(data0.meas);
1024    <span class="keyword">else</span>
1025       err = NaN;
1026    <span class="keyword">end</span>
1027    dv = <a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(dv, N, <span class="string">'voltage'</span>, opt.meas_working);
1028    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(dv, <span class="string">'dv out'</span>);
1029 
1030 <a name="_sub31" href="#_subfunctions" class="code">function show_fem_iter(k, img, inv_model, stop, opt)</a>
1031   <span class="keyword">if</span> (opt.verbose &lt; 4) || (stop == -1)
1032      <span class="keyword">return</span>; <span class="comment">% if verbosity is low OR we're dropping the last iteration because it was bad, do nothing</span>
1033   <span class="keyword">end</span>
1034   <span class="keyword">if</span> opt.verbose &gt; 1
1035      disp(<span class="string">'    show_fem()'</span>);
1036   <span class="keyword">end</span>
1037   img = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'resistivity'</span>); <span class="comment">% TODO big fat hack to make this work at the expense of an actual function...</span>
1038   [img, opt] = <a href="#_sub43" class="code" title="subfunction [img, opt] = strip_c2f_background(img, opt, indent)">strip_c2f_background</a>(img, opt, <span class="string">'    '</span>);
1039   <span class="comment">% check we're returning the right size of data</span>
1040   <span class="keyword">if</span> isfield(inv_model, <span class="string">'rec_model'</span>)
1041     img.fwd_model = inv_model.rec_model;
1042   <span class="keyword">end</span>
1043 <span class="comment">%  bg = 1;</span>
1044 <span class="comment">%  img.calc_colours.ref_level = bg;</span>
1045 <span class="comment">%  img.calc_colours.clim = bg;</span>
1046   img.calc_colours.cb_shrink_move = [0.3,0.6,0.02]; <span class="comment">% move color bars</span>
1047   <span class="keyword">if</span> size(img.elem_data,1) ~= size(img.fwd_model.elems,1)
1048      warning(sprintf(<span class="string">'img.elem_data has %d elements, img.fwd_model.elems has %d elems\n'</span>, <span class="keyword">...</span>
1049                      size(img.elem_data,1), <span class="keyword">...</span>
1050                      size(img.fwd_model.elems,1)));
1051   <span class="keyword">end</span>
1052   clf; feval(opt.show_fem, img, 1);
1053   title(sprintf(<span class="string">'iter=%d'</span>,k));
1054   drawnow;
1055   <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>)
1056      print(<span class="string">'-dpdf'</span>,sprintf(<span class="string">'%s-fem%d'</span>,opt.fig_prefix,k));
1057      print(<span class="string">'-dpng'</span>,sprintf(<span class="string">'%s-fem%d'</span>,opt.fig_prefix,k));
1058      saveas(gcf,sprintf(<span class="string">'%s-fem%d.fig'</span>,opt.fig_prefix,k));
1059   <span class="keyword">end</span>
1060 
1061 <span class="comment">% TODO confirm that GN line_search_onm2 is using this residual calculation (preferably, directly)</span>
1062 <a name="_sub32" href="#_subfunctions" class="code">function residual = GN_residual(dv, de, W, hp2RtR)</a>
1063 <span class="comment">%   [size(dv); size(W); size(de); size(hp2RtR)]</span>
1064    <span class="comment">% we operate on whatever the iterations operate on (log data, resistance, etc) + perturb(i)*dx</span>
1065    residual = 0.5*( dv'*W*dv + de'*hp2RtR*de);
1066 
1067 <a name="_sub33" href="#_subfunctions" class="code">function residual = meas_residual(dv, de, W, hp2RtR)</a>
1068    residual = norm(dv);
1069 
1070 <span class="comment">%function img = initial_estimate( imdl, data )</span>
1071 <span class="comment">%   img = calc_jacobian_bkgnd( imdl );</span>
1072 <span class="comment">%   vs = fwd_solve(img);</span>
1073 <span class="comment">%</span>
1074 <span class="comment">%   if isstruct(data)</span>
1075 <span class="comment">%      data = data.meas;</span>
1076 <span class="comment">%   else</span>
1077 <span class="comment">%     meas_select = [];</span>
1078 <span class="comment">%     try</span>
1079 <span class="comment">%        meas_select = imdl.fwd_model.meas_select;</span>
1080 <span class="comment">%     end</span>
1081 <span class="comment">%     if length(data) == length(meas_select)</span>
1082 <span class="comment">%        data = data(meas_select);</span>
1083 <span class="comment">%     end</span>
1084 <span class="comment">%   end</span>
1085 <span class="comment">%</span>
1086 <span class="comment">%   pf = polyfit(data,vs.meas,1);</span>
1087 <span class="comment">%</span>
1088 <span class="comment">%   % create elem_data</span>
1089 <span class="comment">%   img = data_mapper(img);</span>
1090 <span class="comment">%</span>
1091 <span class="comment">%   if isfield(img.fwd_model,'coarse2fine');</span>
1092 <span class="comment">%      % TODO: the whole coarse2fine needs work here.</span>
1093 <span class="comment">%      %   what happens if c2f doesn't cover the whole region</span>
1094 <span class="comment">%</span>
1095 <span class="comment">%      % TODO: the two cases are very different. c2f case should match other</span>
1096 <span class="comment">%      nc = size(img.fwd_model.coarse2fine,2);</span>
1097 <span class="comment">%      img.elem_data = mean(img.elem_data)*ones(nc,1)*pf(1);</span>
1098 <span class="comment">%   else</span>
1099 <span class="comment">%      img.elem_data = img.elem_data*pf(1);</span>
1100 <span class="comment">%   end</span>
1101 <span class="comment">%</span>
1102 <span class="comment">%   % remove elem_data</span>
1103 <span class="comment">%%   img = data_mapper(img,1);</span>
1104 <span class="comment">%</span>
1105 <span class="comment">%function [img opt] = update_step(org, next, dx, fmin,res, opt)</span>
1106 <span class="comment">%   if isfield(opt, 'update_func')</span>
1107 <span class="comment">%      [img opt] = feval(opt.update_func,org,next,dx,fmin,res,opt);</span>
1108 <span class="comment">%   else</span>
1109 <span class="comment">%      img = next;</span>
1110 <span class="comment">%   end</span>
1111 <span class="comment">%</span>
1112 <span class="comment">% function bg = calc_background_resistivity(fmdl, va)</span>
1113 <span class="comment">%   % have a look at what we've created</span>
1114 <span class="comment">%   % compare data to homgeneous (how good is the model?)</span>
1115 <span class="comment">%   % NOTE background conductivity is set by matching amplitude of</span>
1116 <span class="comment">%   % homogeneous data against the measurements to get rough matching</span>
1117 <span class="comment">%   if(opt.verbose&gt;1)</span>
1118 <span class="comment">%     fprintf('est. background resistivity\n');</span>
1119 <span class="comment">%   end</span>
1120 <span class="comment">%   cache_obj = { fmdl, va };</span>
1121 <span class="comment">%   BACKGROUND_R = eidors_obj('get-cache', cache_obj, 'calc_background_resistivity');</span>
1122 <span class="comment">%   if isempty(BACKGROUND_R);</span>
1123 <span class="comment">%     imgh = mk_image(fmdl, 1); % conductivity = 1 S/m</span>
1124 <span class="comment">%     vh = fwd_solve(imgh);</span>
1125 <span class="comment">%     % take the best fit of the data</span>
1126 <span class="comment">%     BACKGROUND_R = vh.meas \ va; % 32 Ohm.m ... agrees w/ Wilkinson's papers</span>
1127 <span class="comment">%     % update cache</span>
1128 <span class="comment">%     eidors_obj('set-cache', cache_obj, 'calc_background_resistivity', BACKGROUND_R);</span>
1129 <span class="comment">%   else</span>
1130 <span class="comment">%     if(opt.verbose &gt; 1)</span>
1131 <span class="comment">%       fprintf('  ... cache hit\n');</span>
1132 <span class="comment">%     end</span>
1133 <span class="comment">%   end</span>
1134 <span class="comment">%   if(opt.verbose &gt; 1)</span>
1135 <span class="comment">%     fprintf('estimated background resistivity: %0.1f Ohm.m\n', BACKGROUND_R);</span>
1136 <span class="comment">%   end</span>
1137 
1138 <a name="_sub34" href="#_subfunctions" class="code">function imdl = deprecate_imdl_opt(imdl,opt)</a>
1139    <span class="keyword">if</span> ~isfield(imdl, opt)
1140       <span class="keyword">return</span>;
1141    <span class="keyword">end</span>
1142    <span class="keyword">if</span> ~isstruct(imdl.(opt))
1143       error([<span class="string">'unexpected inv_model.'</span> opt <span class="string">' where '</span> opt <span class="string">' is not a struct... i do not know what to do'</span>]);
1144    <span class="keyword">end</span>
1145 
1146    <span class="comment">% warn on anything but inv_model.inv_solve.calc_solution_error</span>
1147    Af = fieldnames(imdl.(opt));
1148    <span class="keyword">if</span> ~strcmp(opt, <span class="string">'inv_solve'</span>) || (length(Af(:)) ~= 1) || ~strcmp(Af(:),<span class="string">'calc_solution_error'</span>)
1149       disp(imdl)
1150       disp(imdl.(opt))
1151       warning(<span class="string">'EIDORS:deprecatedParameters'</span>,[<span class="string">'INV_SOLVE inv_model.'</span> opt <span class="string">'.* are deprecated in favor of inv_model.inv_solve_abs_core.* as of 30-Apr-2014.'</span>]);
1152    <span class="keyword">end</span>
1153 
1154    <span class="keyword">if</span> ~isfield(imdl, <span class="string">'inv_solve_abs_core'</span>)
1155       imdl.inv_solve_abs_core = imdl.(opt);
1156    <span class="keyword">else</span> <span class="comment">% we merge</span>
1157       <span class="comment">% merge struct trick from:</span>
1158       <span class="comment">%  http://stackoverflow.com/questions/38645</span>
1159       <span class="keyword">for</span> i = fieldnames(imdl.(opt))'
1160          imdl.inv_solve_abs_core.(i{1})=imdl.(opt).(i{1});
1161       <span class="keyword">end</span>
1162    <span class="keyword">end</span>
1163    imdl = rmfield(imdl, opt);
1164 
1165 <a name="_sub35" href="#_subfunctions" class="code">function opt = parse_options(imdl)</a>
1166    <span class="comment">% merge legacy options locations</span>
1167 <span class="comment">%   imdl = deprecate_imdl_opt(imdl, 'parameters');</span>
1168 <span class="comment">%   imdl = deprecate_imdl_opt(imdl, 'inv_solve');</span>
1169 
1170    <span class="comment">% for any general options</span>
1171    <span class="keyword">if</span> isfield(imdl, <span class="string">'inv_solve_abs_core'</span>)
1172       opt = imdl.inv_solve_abs_core;
1173    <span class="keyword">else</span>
1174       opt = struct;
1175    <span class="keyword">end</span>
1176 
1177    <span class="comment">% verbosity, debug output</span>
1178    <span class="comment">% 0: quiet</span>
1179    <span class="comment">% 1: print iteration count</span>
1180    <span class="comment">% 2: print details as the algorithm progresses</span>
1181    <span class="keyword">if</span> ~isfield(opt,<span class="string">'verbose'</span>)
1182       opt.verbose = 4;
1183       fprintf(<span class="string">'  inv_model.inv_solve_abs_core.verbosity not set; defaulting to verbosity=4. See help for details.\n'</span>);
1184    <span class="keyword">end</span>
1185    <span class="keyword">if</span> opt.verbose &gt; 1
1186       fprintf(<span class="string">'  setting default parameters\n'</span>);
1187    <span class="keyword">end</span>
1188    <span class="comment">% we track how many fwd_solves we do since they are the most expensive part of the iterations</span>
1189    opt.fwd_solutions = 0;
1190 
1191    <span class="keyword">if</span> ~isfield(opt, <span class="string">'show_fem'</span>)
1192       opt.show_fem = @<a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>;
1193    <span class="keyword">end</span>
1194 
1195    <span class="keyword">if</span> ~isfield(opt, <span class="string">'residual_func'</span>) <span class="comment">% the objective function</span>
1196       opt.residual_func = @<a href="#_sub32" class="code" title="subfunction residual = GN_residual(dv, de, W, hp2RtR)">GN_residual</a>; <span class="comment">% r = f(dv, de, W, hp2RtR)</span>
1197       <span class="comment">% NOTE: the meas_residual function exists to maintain</span>
1198       <span class="comment">% compatibility with Nolwenn's code, the GN_residual</span>
1199       <span class="comment">% is a better choice</span>
1200       <span class="comment">%opt.residual_func = @meas_residual; % r = f(dv, de, W, hp2RtR)</span>
1201    <span class="keyword">end</span>
1202 
1203    <span class="comment">% calculation of update components</span>
1204    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_func'</span>)
1205       opt.update_func = @<a href="#_sub38" class="code" title="subfunction dx = GN_update(J, W, hp2RtR, dv, de)">GN_update</a>; <span class="comment">% dx = f(J, W, hp2RtR, dv, de)</span>
1206    <span class="keyword">end</span>
1207    <span class="comment">% figure out if things need to be calculated</span>
1208    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_meas_icov'</span>) <span class="comment">% derivative of the objective function</span>
1209       opt.calc_meas_icov = 0; <span class="comment">% W</span>
1210    <span class="keyword">end</span>
1211    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_RtR_prior'</span>) <span class="comment">% derivative of the objective function</span>
1212       opt.calc_RtR_prior = 0; <span class="comment">% RtR</span>
1213    <span class="keyword">end</span>
1214    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_hyperparameter'</span>)
1215       opt.calc_hyperparameter = 0; <span class="comment">% hp2</span>
1216    <span class="keyword">end</span>
1217 
1218 <span class="comment">%   try</span>
1219       <span class="keyword">if</span> opt.verbose &gt; 1
1220          fprintf(<span class="string">'    examining function %s(...) for required arguments\n'</span>, func2str(opt.update_func));
1221       <span class="keyword">end</span>
1222       <span class="comment">% ensure that necessary components are calculated</span>
1223       <span class="comment">% opt.update_func: dx = f(J, W, hp2RtR, dv, de)</span>
1224 <span class="comment">%TODO BROKEN      args = function_depends_upon(opt.update_func, 6);</span>
1225       args = ones(4,1); <span class="comment">% TODO BROKEN</span>
1226       <span class="keyword">if</span> args(2) == 1
1227          opt.calc_meas_icov = 1;
1228       <span class="keyword">end</span>
1229       <span class="keyword">if</span> args(3) == 1
1230          opt.calc_hyperparameter = 1;
1231       <span class="keyword">end</span>
1232       <span class="keyword">if</span> args(4) == 1
1233          opt.calc_RtR_prior = 1;
1234       <span class="keyword">end</span>
1235 <span class="comment">%   catch</span>
1236 <span class="comment">%      error('exploration of function %s via function_depends_upon() failed', func2str(opt.update_func));</span>
1237 <span class="comment">%   end</span>
1238 
1239    <span class="comment">% stopping criteria, solution limits</span>
1240    <span class="keyword">if</span> ~isfield(opt, <span class="string">'max_iterations'</span>)
1241       opt.max_iterations = 10;
1242    <span class="keyword">end</span>
1243    <span class="keyword">if</span> ~isfield(opt, <span class="string">'ntol'</span>)
1244       opt.ntol = eps; <span class="comment">% attempt to quantify numeric machine precision</span>
1245    <span class="keyword">end</span>
1246    <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol'</span>)
1247       opt.tol = 0; <span class="comment">% terminate iterations if residual is less than tol</span>
1248    <span class="keyword">end</span>
1249    <span class="keyword">if</span> ~isfield(opt, <span class="string">'dtol'</span>)
1250       <span class="comment">% terminate iterations if residual slope is greater than dtol</span>
1251       <span class="comment">% generally, we would want dtol to be -0.01 (1% decrease) or something similar</span>
1252       <span class="comment">%  ... as progress levels out, stop working</span>
1253       <span class="comment">%opt.dtol = +inf;</span>
1254       opt.dtol = -1e-4; <span class="comment">% --&gt; -0.01% slope (really slow)</span>
1255    <span class="keyword">end</span>
1256    <span class="keyword">if</span> ~isfield(opt, <span class="string">'dtol_iter'</span>)
1257       <span class="comment">%opt.dtol_iter = inf; % ignore dtol for dtol_iter iterations</span>
1258       opt.dtol_iter = 0; <span class="comment">% use dtol from the begining</span>
1259    <span class="keyword">end</span>
1260    <span class="keyword">if</span> ~isfield(opt, <span class="string">'min_value'</span>)
1261       opt.min_value = -inf; <span class="comment">% min elem_data value</span>
1262    <span class="keyword">end</span>
1263    <span class="keyword">if</span> ~isfield(opt, <span class="string">'max_value'</span>)
1264       opt.max_value = +inf; <span class="comment">% max elem_data value</span>
1265    <span class="keyword">end</span>
1266    <span class="comment">% provide a graphical display of the line search values &amp; fit</span>
1267    <span class="keyword">if</span> ~isfield(opt, <span class="string">'plot_residuals'</span>)
1268       <span class="keyword">if</span> opt.verbose &gt; 2
1269          opt.plot_residuals = 1;
1270       <span class="keyword">else</span>
1271          opt.plot_residuals = 0;
1272       <span class="keyword">end</span>
1273    <span class="keyword">end</span>
1274    <span class="keyword">if</span> opt.plot_residuals ~= 0
1275       disp(<span class="string">'  residual plot (updated per iteration) are enabled, to disable them set'</span>);
1276       disp(<span class="string">'    inv_model.inv_solve_abs_core.plot_residuals=0'</span>);
1277    <span class="keyword">end</span>
1278 
1279    <span class="comment">% line search</span>
1280    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_func'</span>)
1281       <span class="comment">% [alpha, img, dv, opt] = f(img, sx, data0, img0, N, W, hp2RtR, dv, opt);</span>
1282       opt.line_search_func = @<a href="line_search_onm2.html" class="code" title="function  [alpha, img, dv, opt] = line_search_onm2(imgk, dx, data1, img1, N, W, hp2RtR, dv0, opt, retry, pf_max)">line_search_onm2</a>;
1283    <span class="keyword">end</span>
1284    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_dv_func'</span>)
1285       opt.line_search_dv_func = @<a href="#_sub30" class="code" title="subfunction [dv, opt, err] = update_dv_core(img, data0, N, opt)">update_dv_core</a>;
1286       <span class="comment">% [dv, opt] = update_dv_core(img, data0, N, opt)</span>
1287    <span class="keyword">end</span>
1288    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_de_func'</span>)
1289       <span class="comment">% we create an anonymous function to skip the first input argument since</span>
1290       <span class="comment">% we always want to calculate de in the line search</span>
1291       opt.line_search_de_func = @(img, img0, opt) <a href="#_sub27" class="code" title="subfunction  de = update_de(de, img, img0, opt)">update_de</a>(1, img, img0, opt);
1292       <span class="comment">% de = f(img, img0, opt)</span>
1293    <span class="keyword">end</span>
1294    <span class="comment">% an initial guess for the line search step sizes, may be modified by line search</span>
1295    <span class="comment">% TODO this 'sensible default' should be moved to the line_search code since it is not generic to any other line searches</span>
1296    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_args'</span>) || <span class="keyword">...</span>
1297       ~isfield(opt.line_search_args, <span class="string">'perturb'</span>)
1298       fmin = 1/4; <span class="comment">% arbitrary starting guess</span>
1299       opt.line_search_args.perturb = [0 fmin/4 fmin/2 fmin fmin*2 fmin*4];
1300       <span class="comment">%opt.line_search_args.perturb = [0 fmin/4 fmin fmin*4];</span>
1301       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.35 0.7 1.0];</span>
1302       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.5 0.7 1.0];</span>
1303       <span class="comment">%pt.line_search_args.perturb = [0 0.1 0.7 0.9 1.0];</span>
1304       <span class="comment">%opt.line_search_args.perturb = [0 0.1 0.9 1.0];</span>
1305    <span class="keyword">end</span>
1306    <span class="comment">% provide a graphical display of the line search values &amp; fit</span>
1307    <span class="keyword">if</span> ~isfield(opt,<span class="string">'line_search_args'</span>) || <span class="keyword">...</span>
1308       ~isfield(opt.line_search_args, <span class="string">'plot'</span>)
1309       <span class="keyword">if</span> opt.verbose &gt;= 5
1310          opt.line_search_args.plot = 1;
1311       <span class="keyword">else</span>
1312          opt.line_search_args.plot = 0;
1313       <span class="keyword">end</span>
1314    <span class="keyword">end</span>
1315    <span class="comment">% pass fig_prefix to the line search as well, unless they are supposed to go somewhere elese</span>
1316    <span class="keyword">if</span> isfield(opt,<span class="string">'fig_prefix'</span>) &amp;&amp; <span class="keyword">...</span>
1317       isfield(opt,<span class="string">'line_search_args'</span>) &amp;&amp; <span class="keyword">...</span>
1318       ~isfield(opt.line_search_args, <span class="string">'fig_prefix'</span>)
1319       opt.line_search_args.fig_prefix = opt.fig_prefix;
1320    <span class="keyword">end</span>
1321    <span class="comment">% some help on how to turn off the line search plots if we don't want to see them</span>
1322    <span class="keyword">if</span> opt.line_search_args.plot ~= 0
1323       disp(<span class="string">'  line search plots (per iteration) are enabled, to disable them set'</span>);
1324       disp(<span class="string">'    inv_model.inv_solve_abs_core.line_search_args.plot=0'</span>);
1325    <span class="keyword">end</span>
1326 
1327    <span class="comment">% background</span>
1328    <span class="comment">% if &gt; 0, this is the elem_data that holds the background</span>
1329    <span class="comment">% this is stripped off just before the iterations complete</span>
1330    <span class="keyword">if</span> ~isfield(opt, <span class="string">'c2f_background'</span>)
1331      <span class="keyword">if</span> isfield(imdl, <span class="string">'fwd_model'</span>) &amp;&amp; isfield(imdl.fwd_model, <span class="string">'coarse2fine'</span>)
1332         opt.c2f_background = -1; <span class="comment">% possible: check if its required later</span>
1333      <span class="keyword">else</span>
1334         opt.c2f_background = 0;
1335      <span class="keyword">end</span>
1336    <span class="keyword">end</span>
1337    <span class="keyword">if</span> ~isfield(opt, <span class="string">'c2f_background_fixed'</span>)
1338       opt.c2f_background_fixed = 1; <span class="comment">% generally, don't touch the background</span>
1339    <span class="keyword">end</span>
1340 
1341 
1342    <span class="comment">% DATA CONVERSION settings</span>
1343    <span class="comment">% elem type for the initial estimate is based on calc_jacobian_bkgnd which returns an img</span>
1344    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_working'</span>)
1345       opt.elem_working = {<span class="string">'conductivity'</span>};
1346    <span class="keyword">end</span>
1347    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_prior'</span>)
1348       opt.elem_prior = opt.elem_working;
1349    <span class="keyword">end</span>
1350    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_output'</span>)
1351       opt.elem_output = {<span class="string">'conductivity'</span>};
1352    <span class="keyword">end</span>
1353    <span class="keyword">if</span> ~isfield(opt, <span class="string">'meas_input'</span>)
1354       opt.meas_input = <span class="string">'voltage'</span>;
1355    <span class="keyword">end</span>
1356    <span class="keyword">if</span> ~isfield(opt, <span class="string">'meas_working'</span>)
1357       opt.meas_working = <span class="string">'voltage'</span>;
1358    <span class="keyword">end</span>
1359    <span class="comment">% if the user didn't put these into cell arrays, do</span>
1360    <span class="comment">% so here so there is less error checking later in</span>
1361    <span class="comment">% the code</span>
1362    <span class="keyword">for</span> i = {<span class="string">'elem_working'</span>, <span class="string">'elem_prior'</span>, <span class="string">'elem_output'</span>}; <span class="comment">%, 'meas_input', 'meas_working'}</span>
1363      <span class="comment">% MATLAB voodoo: deincapsulate a cell containing a</span>
1364      <span class="comment">% string, then use that to access a struct eleemnt</span>
1365      x = opt.(i{1});
1366      <span class="keyword">if</span> ~iscell(x)
1367         opt.(i{1}) = {x};
1368      <span class="keyword">end</span>
1369    <span class="keyword">end</span>
1370 
1371    <span class="keyword">if</span> ~isfield(opt, <span class="string">'prior_data'</span>)
1372       <span class="keyword">if</span> isfield(imdl, <span class="string">'jacobian_bkgnd'</span>) &amp;&amp; <span class="keyword">...</span>
1373          isfield(imdl.jacobian_bkgnd, <span class="string">'value'</span>) &amp;&amp; <span class="keyword">...</span>
1374          length(opt.elem_prior) == 1
1375          opt.prior_data = {imdl.jacobian_bkgnd.value};
1376       <span class="keyword">else</span>
1377          error(<span class="string">'requires inv_model.inv_solve_abs_core.prior_data'</span>);
1378       <span class="keyword">end</span>
1379    <span class="keyword">end</span>
1380 
1381    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_len'</span>)
1382       <span class="keyword">if</span> length(opt.elem_working) == 1
1383          <span class="keyword">if</span> isfield(imdl.fwd_model, <span class="string">'coarse2fine'</span>)
1384             c2f = imdl.fwd_model.coarse2fine; <span class="comment">% coarse-to-fine mesh mapping</span>
1385             opt.elem_len = { size(c2f,2) };
1386          <span class="keyword">else</span>
1387             opt.elem_len = { size(imdl.fwd_model.elems,1) };
1388          <span class="keyword">end</span>
1389       <span class="keyword">else</span>
1390         error(<span class="string">'requires inv_model.inv_solve_abs_core.elem_len'</span>);
1391       <span class="keyword">end</span>
1392    <span class="keyword">end</span>
1393 
1394    <span class="comment">% meas_select already handles selecting from the valid measurements</span>
1395    <span class="comment">% we want the same for the elem_data, so we only work on modifying the legal values</span>
1396    <span class="comment">% Note that c2f_background's elements are added to this list if opt.c2f_background_fixed == 1</span>
1397    <span class="keyword">if</span> ~isfield(opt, <span class="string">'elem_fixed'</span>) <span class="comment">% give a safe default, if none has been provided</span>
1398       opt.elem_fixed = [];
1399    <span class="keyword">elseif</span> iscell(opt.elem_fixed) <span class="comment">% if its a cell-array, we convert it to absolute</span>
1400      <span class="comment">% numbers in elem_data</span>
1401      <span class="comment">%  -- requires: opt.elem_len to already be constructed if it was missing</span>
1402       offset=0;
1403       ef=[];
1404       <span class="keyword">for</span> i=1:length(opt.elem_fixed)
1405          ef = [ef, opt.elem_fixed{i} + offset];
1406          offset = offset + opt.elem_len{i};
1407       <span class="keyword">end</span>
1408       opt.elem_fixed = ef;
1409    <span class="keyword">end</span>
1410 
1411    <span class="comment">% allow a cell array of jacobians</span>
1412    <span class="keyword">if</span> ~isfield(opt, <span class="string">'jacobian'</span>)
1413       opt.jacobian = imdl.fwd_model.jacobian;
1414    <span class="keyword">elseif</span> isfield(imdl.fwd_model, <span class="string">'jacobian'</span>)
1415       imdl.fwd_model
1416       imdl
1417       error(<span class="string">'inv_model.fwd_model.jacobian and inv_model.inv_solve_abs_core.jacobian should not both exist: it''s ambiguous'</span>);
1418    <span class="keyword">end</span>
1419    <span class="comment">% defaul hyperparameter is 1</span>
1420    <span class="keyword">if</span> ~isfield(opt, <span class="string">'hyperparameter'</span>)
1421       opt.hyperparameter = {[]};
1422       <span class="keyword">for</span> i=1:length(opt.elem_working)
1423          opt.hyperparameter{i} = 1;
1424       <span class="keyword">end</span>
1425    <span class="keyword">end</span>
1426    <span class="comment">% if the user didn't put these into cell arrays, do</span>
1427    <span class="comment">% so here so there is less error checking later in</span>
1428    <span class="comment">% the code</span>
1429    <span class="keyword">for</span> i = {<span class="string">'elem_len'</span>, <span class="string">'prior_data'</span>, <span class="string">'jacobian'</span>, <span class="string">'hyperparameter'</span>}
1430      <span class="comment">% MATLAB voodoo: deincapsulate a cell containing a</span>
1431      <span class="comment">% string, then use that to access a struct eleemnt</span>
1432      x = opt.(i{1});
1433      <span class="keyword">if</span> ~iscell(x)
1434         opt.(i{1}) = {x};
1435      <span class="keyword">end</span>
1436    <span class="keyword">end</span>
1437    <span class="comment">% show what the hyperparameters are configured to when logging</span>
1438    <span class="keyword">if</span> opt.verbose &gt; 1
1439       fprintf(<span class="string">'  hyperparameters\n'</span>);
1440       <span class="keyword">for</span> i=1:length(opt.elem_working)
1441          <span class="keyword">if</span> isnumeric(opt.hyperparameter{i}) &amp;&amp; length(opt.hyperparameter{i}) == 1
1442             fprintf(<span class="string">'    %s: %0.4g\n'</span>,opt.elem_working{i}, opt.hyperparameter{i});
1443          <span class="keyword">elseif</span> isa(opt.hyperparameter{i}, <span class="string">'function_handle'</span>)
1444             fprintf(<span class="string">'    %s: @%s\n'</span>,opt.elem_working{i}, func2str(opt.hyperparameter{i}));
1445          <span class="keyword">elseif</span> ischar(opt.hyperparameter{i})
1446             fprintf(<span class="string">'    %s: @%s\n'</span>,opt.elem_working{i}, opt.hyperparameter{i});
1447          <span class="keyword">else</span>
1448             fprintf(<span class="string">'    %s: ...\n'</span>,opt.elem_working{i});
1449          <span class="keyword">end</span>
1450       <span class="keyword">end</span>
1451    <span class="keyword">end</span>
1452 
1453    <span class="comment">% REGULARIZATION RtR</span>
1454    <span class="comment">% for constructing the blockwise RtR matrix</span>
1455    <span class="comment">% can be: explicit matrix, blockwise matrix diagonal, or full blockwise matrix</span>
1456    <span class="comment">% blockwise matrices can be function ptrs or explicit</span>
1457    <span class="keyword">if</span> ~isfield(opt, <span class="string">'RtR_prior'</span>)
1458       <span class="keyword">if</span> isfield(imdl, <span class="string">'RtR_prior'</span>)
1459          opt.RtR_prior = {imdl.RtR_prior};
1460       <span class="keyword">else</span>
1461          opt.RtR_prior = {[]}; <span class="comment">% null matrix (all zeros)</span>
1462          warning(<span class="string">'missing imdl.inv_solve_abs_core.RtR_prior or imdl.RtR_prior: assuming NO regularization RtR=0'</span>);
1463       <span class="keyword">end</span>
1464    <span class="keyword">end</span>
1465    <span class="comment">% bit of a make work project but if its actually a full numeric matrix we</span>
1466    <span class="comment">% canoncialize it by breaking it up into the blockwise components</span>
1467    <span class="keyword">if</span> isnumeric(opt.RtR_prior)
1468       <span class="keyword">if</span> size(opt.RtR_prior, 1) ~= size(opt.RtR_prior, 2)
1469          error(<span class="string">'expecting square matrix for imdl.RtR_prior or imdl.inv_solve_abs_core.RtR_prior'</span>);
1470       <span class="keyword">end</span>
1471       <span class="keyword">if</span> length(opt.RtR_prior) == 1
1472          opt.RtR_prior = {opt.RtR_prior}; <span class="comment">% encapsulate directly into a cell array</span>
1473       <span class="keyword">else</span>
1474          RtR = opt.RtR_prior;
1475          opt.RtR_prior = {[]};
1476          esi = 0; eei = 0;
1477          <span class="keyword">for</span> i=1:length(opt.elem_len)
1478             esi = eei +1;
1479             eei = eei +opt.elem_len{i};
1480             esj = 0; eej = 0;
1481             <span class="keyword">for</span> j=1:length(opt.elem_len)
1482                esj = eej +1;
1483                eej = eej +opt.elem_len{j};
1484                opt.RtR_prior(i,j) = RtR(esi:eei, esj:eej);
1485             <span class="keyword">end</span>
1486          <span class="keyword">end</span>
1487       <span class="keyword">end</span>
1488    <span class="keyword">elseif</span> ~iscell(opt.RtR_prior) <span class="comment">% not a cell array? encapsulate it</span>
1489       opt.RtR_prior = {opt.RtR_prior};
1490    <span class="keyword">end</span>
1491    <span class="comment">% if not square then expand the block matrix</span>
1492    <span class="comment">% single row/column: this is our diagonal --&gt; expand to full blockwise matrix</span>
1493    <span class="keyword">if</span> any(size(opt.RtR_prior) ~= ([1 1]*length(opt.elem_len)))
1494       <span class="keyword">if</span> (size(opt.RtR_prior, 1) ~= 1) &amp;&amp; <span class="keyword">...</span>
1495          (size(opt.RtR_prior, 2) ~= 1)
1496          error(<span class="string">'odd imdl.RtR_prior or imdl.inv_solve_abs_core.RtR_prior, cannot figure out how to expand it blockwise'</span>);
1497       <span class="keyword">end</span>
1498       <span class="keyword">if</span> (size(opt.RtR_prior, 1) ~= length(opt.elem_len)) &amp;&amp; <span class="keyword">...</span>
1499          (size(opt.RtR_prior, 2) ~= length(opt.elem_len))
1500          error(<span class="string">'odd imdl.RtR_prior or imdl.inv_solve_abs_core.RtR_prior, not enough blockwise components vs. elem_working types'</span>);
1501       <span class="keyword">end</span>
1502       RtR_diag = opt.RtR_prior;
1503       opt.RtR_prior = {[]}; <span class="comment">% delete and start again</span>
1504       <span class="keyword">for</span> i=1:length(opt.elem_len)
1505          opt.RtR_prior(i,i) = RtR_diag(i);
1506       <span class="keyword">end</span>
1507    <span class="keyword">end</span>
1508 
1509    <span class="comment">% now sort out the hyperparameter for the &quot;R^T R&quot; (RtR) matrix</span>
1510    hp=opt.hyperparameter;
1511    <span class="keyword">if</span> size(hp,2) == 1 <span class="comment">% one column</span>
1512       hp = hp'; <span class="comment">% ... now one row</span>
1513    <span class="keyword">end</span>
1514    <span class="keyword">if</span> iscell(hp)
1515       <span class="comment">% if it's a cell array that matches size of the RtR, then we're done</span>
1516       <span class="keyword">if</span> all(size(hp) == size(opt.RtR_prior))
1517          opt.hyperparameter = hp;
1518       <span class="comment">% if the columns matches, then we can expand on the diangonal, everything else gets '1'</span>
1519       <span class="keyword">elseif</span> length(hp) == length(opt.RtR_prior)
1520          opt.hyperparameter = opt.RtR_prior;
1521          [opt.hyperparameter{:}] = deal(1); <span class="comment">% hp = 1 everywhere</span>
1522          opt.hyperparameter(logical(eye(size(opt.RtR_prior)))) = hp; <span class="comment">% assign to diagonal</span>
1523       <span class="keyword">else</span>
1524          error(<span class="string">'hmm, don''t understand this opt.hyperparameter cellarray'</span>);
1525       <span class="keyword">end</span>
1526    <span class="comment">% if it's a single hyperparameter, that's the value everywhere</span>
1527    <span class="keyword">elseif</span> isnumeric(hp)
1528       opt.hyperparameter = opt.RtR_prior;
1529       [opt.hyperparameter{:}] = deal({hp});
1530    <span class="keyword">else</span>
1531       error(<span class="string">'don''t understand this opt.hyperparameter'</span>);
1532    <span class="keyword">end</span>
1533 
1534    <span class="comment">% JACOBIAN CHAIN RULE conductivity -&gt; whatever</span>
1535    <span class="comment">% where x = conductivity at this iteration</span>
1536    <span class="comment">%       S = a scaling matrix, generally a diagonal matrix of size matching Jacobian columns</span>
1537    <span class="comment">% Jn = J * S;</span>
1538    <span class="comment">% if not provided, determine based on 'elem_working' type</span>
1539    <span class="keyword">if</span> ~isfield(opt, <span class="string">'calc_jacobian_scaling_func'</span>)
1540       pinv = strfind(opt.elem_working, <span class="string">'resistivity'</span>);
1541       plog = strfind(opt.elem_working, <span class="string">'log_'</span>);
1542       plog10 = strfind(opt.elem_working, <span class="string">'log10_'</span>);
1543       <span class="keyword">for</span> i = 1:length(opt.elem_working)
1544         prefix = <span class="string">''</span>;
1545         <span class="keyword">if</span> plog{i}
1546            prefix = <span class="string">'log'</span>;
1547         <span class="keyword">elseif</span> plog10{i}
1548            prefix = <span class="string">'log10'</span>;
1549         <span class="keyword">else</span>
1550            prefix = <span class="string">''</span>;
1551         <span class="keyword">end</span>
1552         <span class="keyword">if</span> pinv{i}
1553            prefix = [prefix <span class="string">'_inv'</span>];
1554         <span class="keyword">end</span>
1555         <span class="keyword">switch</span>(prefix)
1556           <span class="keyword">case</span> <span class="string">''</span>
1557              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub41" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>;  <span class="comment">% S = f(x)</span>
1558           <span class="keyword">case</span> <span class="string">'log'</span>
1559              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub13" class="code" title="subfunction S = dx_dlogx(x);">dx_dlogx</a>;   <span class="comment">% S = f(x)</span>
1560           <span class="keyword">case</span> <span class="string">'log10'</span>
1561              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub14" class="code" title="subfunction S = dx_dlog10x(x);">dx_dlog10x</a>; <span class="comment">% S = f(x)</span>
1562           <span class="keyword">case</span> <span class="string">'_inv'</span>
1563              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub15" class="code" title="subfunction S = dx_dy(x);">dx_dy</a>;      <span class="comment">% S = f(x)</span>
1564           <span class="keyword">case</span> <span class="string">'log_inv'</span>
1565              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub16" class="code" title="subfunction S = dx_dlogy(x);">dx_dlogy</a>;   <span class="comment">% S = f(x)</span>
1566           <span class="keyword">case</span> <span class="string">'log10_inv'</span>
1567              opt.calc_jacobian_scaling_func{i} = @<a href="#_sub17" class="code" title="subfunction S = dx_dlog10y(x);">dx_dlog10y</a>; <span class="comment">% S = f(x)</span>
1568           <span class="keyword">otherwise</span>
1569              error(<span class="string">'oops'</span>);
1570        <span class="keyword">end</span>
1571      <span class="keyword">end</span>
1572    <span class="keyword">end</span>
1573 
1574    <span class="keyword">if</span> ~isfield(opt, <span class="string">'update_img_func'</span>)
1575       opt.update_img_func = @<a href="#_sub40" class="code" title="subfunction out = null_func(in, varargin);">null_func</a>; <span class="comment">% img = f(img, opt)</span>
1576    <span class="keyword">end</span>
1577 
1578    <span class="keyword">if</span> ~isfield(opt, <span class="string">'return_working_variables'</span>)
1579       opt.return_working_variables = 0;
1580    <span class="keyword">end</span>
1581 
1582 <a name="_sub36" href="#_subfunctions" class="code">function check_matrix_sizes(J, W, hp2RtR, dv, de, opt)</a>
1583    <span class="comment">% assuming our equation looks something like</span>
1584    <span class="comment">% dx = (J'*W*J + hp2RtR)\(J'*dv + hp2RtR*de);</span>
1585    <span class="comment">% check that all the matrix sizes are correct</span>
1586    ne = size(de,1);
1587    nv = size(dv,1);
1588    <span class="keyword">if</span> size(de,2) ~= 1
1589       error(<span class="string">'de cols (%d) not equal 1'</span>, size(de,2));
1590    <span class="keyword">end</span>
1591    <span class="keyword">if</span> size(dv,2) ~= 1
1592       error(<span class="string">'dv cols (%d) not equal 1'</span>, size(dv,2));
1593    <span class="keyword">end</span>
1594    <span class="keyword">if</span> opt.calc_meas_icov &amp;&amp; <span class="keyword">...</span>
1595       any(size(W) ~= [nv nv])
1596       error(<span class="string">'W size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(W), nv, nv);
1597    <span class="keyword">end</span>
1598    <span class="keyword">if</span> any(size(J) ~= [nv ne])
1599       error(<span class="string">'J size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(J), nv, ne);
1600    <span class="keyword">end</span>
1601    <span class="keyword">if</span> opt.calc_RtR_prior &amp;&amp; <span class="keyword">...</span>
1602       any(size(hp2RtR) ~= [ne ne])
1603       error(<span class="string">'hp2RtR size (%d rows, %d cols) is incorrect (%d rows, %d cols)'</span>, size(hp2RtR), ne, ne);
1604    <span class="keyword">end</span>
1605 
1606 <a name="_sub37" href="#_subfunctions" class="code">function dx = update_dx(J, W, hp2RtR, dv, de, opt)</a>
1607    <span class="keyword">if</span>(opt.verbose &gt; 1)
1608       fprintf( <span class="string">'    calc step size dx\n'</span>);
1609    <span class="keyword">end</span>
1610 
1611    <span class="comment">% don't penalize for fixed elements</span>
1612    de(opt.elem_fixed) = 0;
1613 
1614    <span class="comment">% TODO move this outside the inner loop of the iterations, it only needs to be done once</span>
1615    <a href="#_sub36" class="code" title="subfunction check_matrix_sizes(J, W, hp2RtR, dv, de, opt)">check_matrix_sizes</a>(J, W, hp2RtR, dv, de, opt)
1616 
1617    <span class="comment">% zero out the appropriate things so that we can get a dx=0 for the elem_fixed</span>
1618    J(:,opt.elem_fixed) = 0;
1619    de(opt.elem_fixed,:) = 0;
1620    hp2RtR(opt.elem_fixed,:) = 0;
1621    V=opt.elem_fixed;
1622    N=size(hp2RtR,1)+1;
1623    hp2RtR(N*(V-1)+1) = 1; <span class="comment">% set diagonals to 1 to avoid divide by zero</span>
1624    <span class="comment">% do the update step direction calculation</span>
1625    dx = feval(opt.update_func, J, W, hp2RtR, dv, de);
1626 
1627    <span class="comment">% check that our elem_fixed stayed fixed</span>
1628    <span class="keyword">if</span> any(dx(opt.elem_fixed) ~= 0)
1629       error(<span class="string">'elem_fixed did''t give dx=0 at update_dx'</span>)
1630    <span class="keyword">end</span>
1631 
1632    <span class="keyword">if</span>(opt.verbose &gt; 1)
1633       fprintf(<span class="string">'      ||dx||=%0.3g\n'</span>, norm(dx));
1634       es = 0; ee = 0;
1635       <span class="keyword">for</span> i=1:length(opt.elem_working)
1636           es = ee +1; ee = ee + opt.elem_len{i};
1637           nd = norm(dx(es:ee));
1638           fprintf( <span class="string">'      ||dx_%d||=%0.3g (%s)\n'</span>,i, nd, opt.elem_working{i});
1639       <span class="keyword">end</span>
1640    <span class="keyword">end</span>
1641 
1642 <a name="_sub38" href="#_subfunctions" class="code">function dx = GN_update(J, W, hp2RtR, dv, de)</a>
1643    <span class="comment">% the actual update</span>
1644    dx = (J'*W*J + hp2RtR)\(J'*dv + hp2RtR*de);
1645 
1646 <span class="comment">% for each argument, returns 1 if the function depends on it, 0 otherwise</span>
1647 <span class="comment">% 'zero' arguments do not need to be calculated since they don't get used</span>
1648 <a name="_sub39" href="#_subfunctions" class="code">function args = function_depends_upon(func, argn)</a>
1649    <span class="comment">% build function call</span>
1650    str = sprintf(<span class="string">'%s('</span>,func2str(func));
1651    args = zeros(argn,1);
1652    <span class="keyword">for</span> i = 1:argn-1
1653       str = [str sprintf(<span class="string">'a(%d),'</span>,i)];
1654    <span class="keyword">end</span>
1655    str = [str sprintf(<span class="string">'a(%d))'</span>,argn)];
1656    <span class="comment">% baseline</span>
1657    a = ones(argn,1)*2;
1658    x = eval(str);
1659    <span class="comment">% now check for a difference at each argument</span>
1660    <span class="keyword">for</span> i = 1:argn
1661       a = ones(argn,1)*2;
1662       a(i) = 0;
1663       y = eval(str);
1664       <span class="keyword">if</span> any(x ~= y)
1665          args(i) = 1;
1666       <span class="keyword">end</span>
1667    <span class="keyword">end</span>
1668 
1669 <span class="comment">% this function just passes data from its input to its output</span>
1670 <a name="_sub40" href="#_subfunctions" class="code">function out = null_func(in, varargin);</a>
1671    out = in;
1672 
1673 <span class="comment">% this function always returns one</span>
1674 <a name="_sub41" href="#_subfunctions" class="code">function [out, x, y, z] = ret1_func(varargin);</a>
1675    out = 1;
1676    x = [];
1677    y = [];
1678    z = [];
1679 
1680 <span class="comment">% if required, expand the coarse-to-fine matrix to cover the background of the image</span>
1681 <span class="comment">% this is removed at the end of the iterations</span>
1682 <a name="_sub42" href="#_subfunctions" class="code">function [inv_model, opt] = append_c2f_background(inv_model, opt)</a>
1683     <span class="comment">% either there is already a background</span>
1684     <span class="comment">% or none is required --&gt; -1 means we go to work building one</span>
1685     <span class="keyword">if</span> opt.c2f_background &gt;= 0
1686       <span class="keyword">return</span>
1687     <span class="keyword">end</span>
1688     <span class="comment">% check that all elements get assigned a conductivity</span>
1689     <span class="comment">% through the c2f conversion</span>
1690     c2f = inv_model.fwd_model.coarse2fine; <span class="comment">% coarse-to-fine mesh mapping</span>
1691     nf = size(inv_model.fwd_model.elems,1); <span class="comment">% number of fine elements</span>
1692     nc = size(c2f,2); <span class="comment">% number of coarse elements</span>
1693     <span class="comment">% ... each element of fel aught to sum to '1' since the</span>
1694     <span class="comment">% elem_data is being assigned from a continuous unit</span>
1695     <span class="comment">% surface value</span>
1696     <span class="comment">% now, find any fine elements that are not fully</span>
1697     <span class="comment">% mapped between the two meshes (&lt;1) w/in a tolerance</span>
1698     <span class="comment">% related to the number of additions in the summation</span>
1699     fel = sum(c2f,2); <span class="comment">% collapse mapping onto the fwd_model elements</span>
1700     n = find(fel &lt; 1 - (1e3+nc)*eps);
1701     <span class="comment">% ... 1e3 is a fudge factor since we don't care too much</span>
1702     <span class="comment">%     about small area mapping errors</span>
1703     <span class="comment">% if we do have some unassigned elements,</span>
1704     <span class="comment">% expand c2f and add a background element to the 'elem_data'</span>
1705     <span class="keyword">if</span> length(n) ~= 0
1706       <span class="keyword">if</span>(opt.verbose &gt; 1)
1707         fprintf(<span class="string">'  c2f: adding background conductivity to %d\n    fwd_model elements not covered by rec_model\n'</span>, length(n));
1708       <span class="keyword">end</span>
1709       c2f(n,nc+1) = 1 - fel(n);
1710       inv_model.fwd_model.coarse2fine = c2f;
1711       opt.c2f_background = nc+1;
1712       <span class="keyword">if</span> opt.c2f_background_fixed
1713          <span class="comment">% TODO assumes conductivity/resistivity is the *first* parameterization</span>
1714          opt.elem_fixed(end+1) = nc+1;
1715       <span class="keyword">end</span>
1716     <span class="keyword">end</span>
1717     <span class="comment">% TODO assumes conductivity/resistivity is the *first* parameterization</span>
1718     opt.elem_len(1) = {size(c2f,2)}; <span class="comment">% elem_len +1</span>
1719 
1720 <a name="_sub43" href="#_subfunctions" class="code">function [img, opt] = strip_c2f_background(img, opt, indent)</a>
1721     <span class="keyword">if</span> nargin &lt; 3
1722        indent = <span class="string">''</span>;
1723     <span class="keyword">end</span>
1724     <span class="comment">% nothing to do?</span>
1725     <span class="keyword">if</span> opt.c2f_background &lt;= 0
1726       <span class="keyword">return</span>;
1727     <span class="keyword">end</span>
1728 
1729     <span class="comment">% if there are multiple 'params' (parametrizations), we assume its the first</span>
1730     <span class="comment">% TODO -- this isn't a great assumption but it'll work for now,</span>
1731     <span class="comment">%         we should add a better (more general) mechanism</span>
1732     in = img.current_params;
1733     out = opt.elem_output;
1734     <span class="keyword">if</span> iscell(in)
1735        in = in{1};
1736     <span class="keyword">end</span>
1737     <span class="keyword">if</span> iscell(out)
1738        out = out{1};
1739     <span class="keyword">end</span>
1740 
1741     <span class="comment">% go about cleaning up the background</span>
1742     e = opt.c2f_background;
1743     <span class="comment">% take backgtround elements and convert to output</span>
1744     <span class="comment">% 'params' (resistivity, etc)</span>
1745     bg = <a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(img.elem_data(e), in, out);
1746     img.elem_data_background = bg;
1747     <span class="comment">% remove elements from elem_data &amp; c2f</span>
1748     img.elem_data(e) = [];
1749     img.fwd_model.coarse2fine(:,e) = [];
1750     <span class="comment">% remove our element from the lists</span>
1751     opt.c2f_background = 0;
1752     ri = find(opt.elem_fixed == e);
1753     opt.elem_fixed(ri) = [];
1754     <span class="keyword">if</span> isfield(img, <span class="string">'params_sel'</span>)
1755        <span class="keyword">for</span> i = 1:length(img.params_sel)
1756           t = img.params_sel{i};
1757           ti = find(t == e);
1758           t(ti) = []; <span class="comment">% rm 'e' from the list of params_sel</span>
1759           ti = find(t &gt; e);
1760           t(ti) = t(ti)-1; <span class="comment">% down-count element indices greater than our deleted one</span>
1761           img.params_sel{i} = t;
1762        <span class="keyword">end</span>
1763     <span class="keyword">end</span>
1764 
1765     <span class="comment">% show what we got for a background value</span>
1766     <span class="keyword">if</span>(opt.verbose &gt; 1)
1767        bg = img.elem_data_background;
1768        bg = <a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(bg, in, <span class="string">'resistivity'</span>);
1769        fprintf(<span class="string">'%s  background conductivity: %0.1f Ohm.m\n'</span>, indent, bg);
1770     <span class="keyword">end</span>
1771 
1772 <a name="_sub44" href="#_subfunctions" class="code">function b = has_params(s)</a>
1773 b = false;
1774 <span class="keyword">if</span> isstruct(s)
1775    b = any(ismember(fieldnames(s),<a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>));
1776 <span class="keyword">end</span>
1777 
1778 <span class="comment">% wrapper function for to_base_types</span>
1779 <a name="_sub45" href="#_subfunctions" class="code">function out = map_img_base_types(img)</a>
1780   out = <a href="#_sub46" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(img.current_params);
1781 
1782 <span class="comment">% convert from know types to their base types</span>
1783 <span class="comment">% A helper function for getting to a basic paramterization</span>
1784 <span class="comment">% prior to any required scaling, etc.</span>
1785 <a name="_sub46" href="#_subfunctions" class="code">function type = to_base_types(type)</a>
1786   <span class="keyword">if</span> ~iscell(type)
1787      type = {type};
1788   <span class="keyword">end</span>
1789   <span class="keyword">for</span> i = 1:length(type);
1790      type(i) = {strrep(type{i}, <span class="string">'log_'</span>, <span class="string">''</span>)};
1791      type(i) = {strrep(type{i}, <span class="string">'log10_'</span>, <span class="string">''</span>)};
1792      type(i) = {strrep(type{i}, <span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>)};
1793      type(i) = {strrep(type{i}, <span class="string">'apparent_resistivity'</span>, <span class="string">'voltage'</span>)};
1794   <span class="keyword">end</span>
1795 
1796 <a name="_sub47" href="#_subfunctions" class="code">function img = map_img(img, out);</a>
1797    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img-pre'</span>);
1798    <span class="keyword">try</span> in = img.current_params;
1799    <span class="keyword">catch</span> in = {<span class="string">'conductivity'</span>};
1800    <span class="keyword">end</span>
1801    <span class="comment">% make cell array of strings</span>
1802    <span class="keyword">if</span> isstr(in)
1803       in = {in};
1804       img.current_params = in;
1805    <span class="keyword">end</span>
1806    <span class="keyword">if</span> isstr(out)
1807       out = {out};
1808    <span class="keyword">end</span>
1809 
1810    <span class="comment">% if we have mixed data, check that we have a selector to differentiate between them</span>
1811    <span class="keyword">if</span> ~isfield(img, <span class="string">'params_sel'</span>)
1812       <span class="keyword">if</span> length(in(:)) == 1
1813          img.params_sel = {1:size(img.elem_data,1)};
1814       <span class="keyword">else</span>
1815          error(<span class="string">'found multiple parametrizations (params) but no params_sel cell array in img'</span>);
1816       <span class="keyword">end</span>
1817    <span class="keyword">end</span>
1818 
1819    <span class="comment">% create data?! we don't know how</span>
1820    <span class="keyword">if</span> length(out(:)) &gt; length(in(:))
1821       error(<span class="string">'missing data (more out types than in types)'</span>);
1822    <span class="keyword">elseif</span> length(out(:)) &lt; length(in(:))
1823       <span class="comment">% delete data: we can do that</span>
1824       <span class="comment">% TODO we could genearlize this into a reorganizing tool BUT we're just</span>
1825       <span class="comment">% interested in something that works, so if we have more than one out(:),</span>
1826       <span class="comment">% we don't know what to do currently and error out</span>
1827       <span class="keyword">if</span> length(out(:)) ~= 1
1828          error(<span class="string">'map_img can convert ALL parameters or select a SINGLE output type from multiple input types'</span>);
1829       <span class="keyword">end</span>
1830       inm  = <a href="#_sub46" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(in);
1831       outm = <a href="#_sub46" class="code" title="subfunction type = to_base_types(type)">to_base_types</a>(out);
1832       del = sort(find(~strcmp(outm(1), inm(:))), <span class="string">'descend'</span>); <span class="comment">% we do this loop backwards in the hopes of avoiding shuffling data that is about to be deleted</span>
1833       <span class="keyword">if</span> length(del)+1 ~= length(in)
1834          error(<span class="string">'Confused about what to remove from the img. You''ll need to sort the parametrizations out yourself when removing data.'</span>);
1835       <span class="keyword">end</span>
1836       <span class="keyword">for</span> i = del(:)' <span class="comment">% delete each of the extra indices</span>
1837          ndel = length(img.params_sel{i}); <span class="comment">% number of deleted elements</span>
1838          <span class="keyword">for</span> j = i+1:length(img.params_sel)
1839             img.params_sel{j} = img.params_sel{j} - ndel;
1840          <span class="keyword">end</span>
1841          img.elem_data(img.params_sel{i}) = []; <span class="comment">% rm elem_data</span>
1842          img.params_sel(i) = []; <span class="comment">% rm params_sel</span>
1843          img.current_params(i) = []; <span class="comment">% rm current_params</span>
1844       <span class="keyword">end</span>
1845       in = img.current_params;
1846    <span class="keyword">end</span>
1847 
1848    <span class="comment">% the sizes now match, we can do the mapping</span>
1849    <span class="keyword">for</span> i = 1:length(out(:))
1850       <span class="comment">% map the data</span>
1851       x = img.elem_data(img.params_sel{i});
1852       x = <a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in{i}, out{i});
1853       img.elem_data(img.params_sel{i}) = x;
1854       img.current_params{i} = out{i};
1855    <span class="keyword">end</span>
1856    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(img.elem_data, <span class="string">'img-post'</span>);
1857 
1858    <span class="comment">% clean up params_sel/current_params if we only have one parametrization</span>
1859    <span class="keyword">if</span> length(img.current_params(:)) == 1
1860       img.current_params = img.current_params{1};
1861       img = rmfield(img, <span class="string">'params_sel'</span>); <span class="comment">% unnecessary since we know its all elem_data</span>
1862    <span class="keyword">end</span>
1863 
1864 <a name="_sub48" href="#_subfunctions" class="code">function x = map_data(x, in, out)</a>
1865    <span class="comment">% check that in and out are single strings, not lists of strings</span>
1866    <span class="keyword">if</span> ~isstr(in)
1867       <span class="keyword">if</span> iscell(in) &amp;&amp; (length(in(:)) == 1)
1868          in = in{1};
1869       <span class="keyword">else</span>
1870          error(<span class="string">'expecting single string for map_data() &quot;in&quot; type'</span>);
1871       <span class="keyword">end</span>
1872    <span class="keyword">end</span>
1873    <span class="keyword">if</span> ~isstr(out)
1874       <span class="keyword">if</span> iscell(out) &amp;&amp; (length(out(:)) == 1)
1875          out = out{1};
1876       <span class="keyword">else</span>
1877          error(<span class="string">'expecting single string for map_data() &quot;out&quot; type'</span>);
1878       <span class="keyword">end</span>
1879    <span class="keyword">end</span>
1880 
1881    <span class="comment">% quit early if there is nothing to do</span>
1882    <span class="keyword">if</span> strcmp(in, out) <span class="comment">% in == out</span>
1883       <span class="keyword">return</span>; <span class="comment">% do nothing</span>
1884    <span class="keyword">end</span>
1885 
1886    <span class="comment">% resistivity to conductivity conversion</span>
1887    <span class="comment">% we can't get here if in == out</span>
1888    <span class="comment">% we've already checked for log convserions on input or output</span>
1889    <span class="keyword">if</span> any(strcmp(in,  {<span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>})) &amp;&amp; <span class="keyword">...</span>
1890       any(strcmp(out, {<span class="string">'resistivity'</span>, <span class="string">'conductivity'</span>}))
1891       x = 1./x; <span class="comment">% conductivity &lt;-&gt; resistivity</span>
1892    <span class="comment">% log conversion</span>
1893    <span class="keyword">elseif</span> any(strcmp({in(1:3), out(1:3)}, <span class="string">'log'</span>))
1894       <span class="comment">% log_10 x -&gt; x</span>
1895       <span class="keyword">if</span> strcmp(in(1:6), <span class="string">'log10_'</span>)
1896          <span class="keyword">if</span> any(x &gt;= log10(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
1897          x = <a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(10.^x, in(7:end), out);
1898       <span class="comment">% ln x -&gt; x</span>
1899       <span class="keyword">elseif</span> strcmp(in(1:4), <span class="string">'log_'</span>)
1900          <span class="keyword">if</span> any(x &gt;= log(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
1901          x = <a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(exp(x), in(5:end), out);
1902       <span class="comment">% x -&gt; log_10 x</span>
1903       <span class="keyword">elseif</span> strcmp(out(1:6), <span class="string">'log10_'</span>)
1904          <span class="keyword">if</span> any(x &lt;= 0 + eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
1905          x = log10(<a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in, out(7:end)));
1906       <span class="comment">% x -&gt; ln x</span>
1907       <span class="keyword">elseif</span> strcmp(out(1:4), <span class="string">'log_'</span>)
1908          <span class="keyword">if</span> any(x &lt;= 0 + eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
1909          x = log(<a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(x, in, out(5:end)));
1910       <span class="keyword">else</span>
1911          error(sprintf(<span class="string">'unknown conversion (log conversion?) %s - &gt; %s'</span>, in, out));
1912       <span class="keyword">end</span>
1913    <span class="keyword">else</span>
1914       error(<span class="string">'unknown conversion %s -&gt; %s'</span>, in, out);
1915    <span class="keyword">end</span>
1916    x(x == +inf) = +realmax;
1917    x(x == -inf) = -realmax;
1918    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(x, <span class="string">'map_data-post'</span>);
1919 
1920 <a name="_sub49" href="#_subfunctions" class="code">function b = map_meas(b, N, in, out)</a>
1921    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(b, <span class="string">'map_meas-pre'</span>);
1922    <span class="keyword">if</span> strcmp(in, out) <span class="comment">% in == out</span>
1923       <span class="keyword">return</span>; <span class="comment">% do nothing</span>
1924    <span class="keyword">end</span>
1925 
1926    <span class="comment">% resistivity to conductivity conversion</span>
1927    <span class="comment">% we can't get here if in == out</span>
1928    <span class="keyword">if</span>     strcmp(in, <span class="string">'voltage'</span>) &amp;&amp; strcmp(out, <span class="string">'apparent_resistivity'</span>)
1929       <span class="keyword">if</span> N == 1
1930          error(<span class="string">'missing apparent resistivity conversion factor N'</span>);
1931       <span class="keyword">end</span>
1932       b = N * b; <span class="comment">% voltage -&gt; apparent resistivity</span>
1933    <span class="keyword">elseif</span> strcmp(in, <span class="string">'apparent_resistivity'</span>) &amp;&amp; strcmp(out, <span class="string">'voltage'</span>)
1934       <span class="keyword">if</span> N == 1
1935          error(<span class="string">'missing apparent resistivity conversion factor N'</span>);
1936       <span class="keyword">end</span>
1937       b = N \ b; <span class="comment">% apparent resistivity -&gt; voltage</span>
1938    <span class="comment">% log conversion</span>
1939    <span class="keyword">elseif</span> any(strcmp({in(1:3), out(1:3)}, <span class="string">'log'</span>))
1940       <span class="comment">% log_10 b -&gt; b</span>
1941       <span class="keyword">if</span> strcmp(in(1:6), <span class="string">'log10_'</span>)
1942          <span class="keyword">if</span> any(b &gt; log10(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
1943          b = <a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(10.^b, N, in(7:end), out);
1944       <span class="comment">% ln b -&gt; b</span>
1945       <span class="keyword">elseif</span> strcmp(in(1:4), <span class="string">'log_'</span>)
1946          <span class="keyword">if</span> any(b &gt; log(realmax)-eps) warning(<span class="string">'loss of precision -&gt; inf'</span>); <span class="keyword">end</span>
1947          b = <a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(exp(b), N, in(5:end), out);
1948       <span class="comment">% b -&gt; log_10 b</span>
1949       <span class="keyword">elseif</span> strcmp(out(1:6), <span class="string">'log10_'</span>)
1950          <span class="keyword">if</span> any(b &lt;= 0+eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
1951          b = log10(<a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(b, N, in, out(7:end)));
1952       <span class="comment">% b -&gt; ln b</span>
1953       <span class="keyword">elseif</span> strcmp(out(1:4), <span class="string">'log_'</span>)
1954          <span class="keyword">if</span> any(b &lt;= 0+eps) warning(<span class="string">'loss of precision -&gt; -inf'</span>); <span class="keyword">end</span>
1955          b = log(<a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(b, N, in, out(5:end)));
1956       <span class="keyword">else</span>
1957          error(sprintf(<span class="string">'unknown conversion (log conversion?) %s - &gt; %s'</span>, in, out));
1958       <span class="keyword">end</span>
1959    <span class="keyword">else</span>
1960       error(<span class="string">'unknown conversion %s -&gt; %s'</span>, in, out);
1961    <span class="keyword">end</span>
1962    <a href="#_sub25" class="code" title="subfunction err_if_inf_or_nan(x, str);">err_if_inf_or_nan</a>(b, <span class="string">'map_meas-post'</span>);
1963 
1964 <a name="_sub50" href="#_subfunctions" class="code">function x=range(y)</a>
1965 x=max(y)-min(y);
1966 
1967 <a name="_sub51" href="#_subfunctions" class="code">function do_unit_test(solver)</a>
1968    <span class="keyword">if</span> nargin == 0
1969      solver = <span class="string">'inv_solve_abs_core'</span>;
1970    <span class="keyword">end</span>
1971    <a href="#_sub56" class="code" title="subfunction do_unit_test_rec_mv(solver)">do_unit_test_rec_mv</a>(solver);
1972    <a href="#_sub52" class="code" title="subfunction do_unit_test_sub">do_unit_test_sub</a>;
1973    <a href="#_sub55" class="code" title="subfunction do_unit_test_rec1(solver)">do_unit_test_rec1</a>(solver);
1974 <span class="comment">%pass = pass &amp; do_unit_test_rec2(solver);</span>
1975 <span class="comment">% TODO the ..._rec2 unit test is very, very slow... what can we do to speed it up... looks like the perturbations get kinda borked when using the line_search_onm2</span>
1976 
1977 <span class="comment">% test sub-functions</span>
1978 <span class="comment">% map_meas, map_data</span>
1979 <span class="comment">% jacobian scalings</span>
1980 <a name="_sub52" href="#_subfunctions" class="code">function do_unit_test_sub</a>
1981 d = 1;
1982 <span class="keyword">while</span> d ~= 1 &amp; d ~= 0
1983   d = rand(1);
1984 <span class="keyword">end</span>
1985 disp(<span class="string">'TEST: map_data()'</span>);
1986 elem_types = {<span class="string">'conductivity'</span>, <span class="string">'log_conductivity'</span>, <span class="string">'log10_conductivity'</span>, <span class="keyword">...</span>
1987               <span class="string">'resistivity'</span>,  <span class="string">'log_resistivity'</span>,  <span class="string">'log10_resistivity'</span>};
1988 expected = [d         log(d)         log10(d)      1./d      log(1./d)      log10(1./d); <span class="keyword">...</span>
1989             exp(d)    d              log10(exp(d)) 1./exp(d) log(1./exp(d)) log10(1./exp(d)); <span class="keyword">...</span>
1990             10.^d     log(10.^d )    d             1./10.^d  log(1./10.^d ) log10(1./10.^d ); <span class="keyword">...</span>
1991             1./d      log(1./d  )    log10(1./d)   d         log(d)         log10(d); <span class="keyword">...</span>
1992             1./exp(d) log(1./exp(d)) log10(1./exp(d)) exp(d) d              log10(exp(d)); <span class="keyword">...</span>
1993             1./10.^d  log(1./10.^d)  log10(1./10.^d)  10.^d  log(10.^d)     d ];
1994 <span class="keyword">for</span> i = 1:length(elem_types)
1995   <span class="keyword">for</span> j = 1:length(elem_types)
1996     <a href="#_sub53" class="code" title="subfunction test_map_data(data, in, out, expected)">test_map_data</a>(d, elem_types{i}, elem_types{j}, expected(i,j));
1997   <span class="keyword">end</span>
1998 <span class="keyword">end</span>
1999 
2000 disp(<span class="string">'TEST: map_meas()'</span>);
2001 N = 1/15;
2002 Ninv = 1/N;
2003 <span class="comment">% function b = map_meas(b, N, in, out)</span>
2004 elem_types = {<span class="string">'voltage'</span>, <span class="string">'log_voltage'</span>, <span class="string">'log10_voltage'</span>, <span class="keyword">...</span>
2005               <span class="string">'apparent_resistivity'</span>,  <span class="string">'log_apparent_resistivity'</span>,  <span class="string">'log10_apparent_resistivity'</span>};
2006 expected = [d         log(d)         log10(d)      N*d      log(N*d)      log10(N*d); <span class="keyword">...</span>
2007             exp(d)    d              log10(exp(d)) N*exp(d) log(N*exp(d)) log10(N*exp(d)); <span class="keyword">...</span>
2008             10.^d     log(10.^d )    d             N*10.^d  log(N*10.^d ) log10(N*10.^d ); <span class="keyword">...</span>
2009             Ninv*d      log(Ninv*d  )    log10(Ninv*d)   d         log(d)         log10(d); <span class="keyword">...</span>
2010             Ninv*exp(d) log(Ninv*exp(d)) log10(Ninv*exp(d)) exp(d) d              log10(exp(d)); <span class="keyword">...</span>
2011             Ninv*10.^d  log(Ninv*10.^d)  log10(Ninv*10.^d)  10.^d  log(10.^d)     d ];
2012 <span class="keyword">for</span> i = 1:length(elem_types)
2013   <span class="keyword">for</span> j = 1:length(elem_types)
2014     <a href="#_sub54" class="code" title="subfunction test_map_meas(data, N, in, out, expected)">test_map_meas</a>(d, N, elem_types{i}, elem_types{j}, expected(i,j));
2015   <span class="keyword">end</span>
2016 <span class="keyword">end</span>
2017 
2018 disp(<span class="string">'TEST: Jacobian scaling'</span>);
2019 d = [d d]';
2020 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2021    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'conductivity'</span>), <span class="keyword">...</span>
2022    <a href="#_sub41" class="code" title="subfunction [out, x, y, z] = ret1_func(varargin);">ret1_func</a>(d), 1);
2023 
2024 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2025    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log_conductivity'</span>), <span class="keyword">...</span>
2026    <a href="#_sub13" class="code" title="subfunction S = dx_dlogx(x);">dx_dlogx</a>(d), diag(d));
2027 
2028 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2029    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log10_conductivity'</span>), <span class="keyword">...</span>
2030    <a href="#_sub14" class="code" title="subfunction S = dx_dlog10x(x);">dx_dlog10x</a>(d), diag(d)*log(10));
2031 
2032 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2033    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'resistivity'</span>), <span class="keyword">...</span>
2034    <a href="#_sub15" class="code" title="subfunction S = dx_dy(x);">dx_dy</a>(d), diag(-d.^2));
2035 
2036 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2037    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log_resistivity'</span>), <span class="keyword">...</span>
2038    <a href="#_sub16" class="code" title="subfunction S = dx_dlogy(x);">dx_dlogy</a>(d), diag(-d));
2039 
2040 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>( <span class="keyword">...</span>
2041    sprintf(<span class="string">'Jacobian scaling (%s)'</span>, <span class="string">'log10_resistivity'</span>), <span class="keyword">...</span>
2042    <a href="#_sub17" class="code" title="subfunction S = dx_dlog10y(x);">dx_dlog10y</a>(d), diag(-d)/log(10));
2043 
2044 
2045 <a name="_sub53" href="#_subfunctions" class="code">function test_map_data(data, in, out, expected)</a>
2046 <span class="comment">%fprintf('TEST: map_data(%s -&gt; %s)\n', in, out);</span>
2047    calc_val = <a href="#_sub48" class="code" title="subfunction x = map_data(x, in, out)">map_data</a>(data, in, out);
2048    str = sprintf(<span class="string">'map_data(%s -&gt; %s)'</span>, in, out);
2049    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(str, calc_val, expected)
2050 
2051 <a name="_sub54" href="#_subfunctions" class="code">function test_map_meas(data, N, in, out, expected)</a>
2052 <span class="comment">%fprintf('TEST: map_meas(%s -&gt; %s)\n', in, out);</span>
2053    calc_val = <a href="#_sub49" class="code" title="subfunction b = map_meas(b, N, in, out)">map_meas</a>(data, N, in, out);
2054    str = sprintf(<span class="string">'map_data(%s -&gt; %s)'</span>, in, out);
2055    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(str, calc_val, expected)
2056 
2057 
2058 <span class="comment">% a couple easy reconstructions</span>
2059 <span class="comment">% check c2f, apparent_resistivity, log_conductivity, verbosity don't error out</span>
2060 <a name="_sub55" href="#_subfunctions" class="code">function do_unit_test_rec1(solver)</a>
2061 <span class="comment">% -------------</span>
2062 <span class="comment">% ADAPTED FROM</span>
2063 <span class="comment">% Create simulation data $Id: inv_solve_abs_core.m 4941 2015-05-09 01:19:34Z aadler $</span>
2064 <span class="comment">%  http://eidors3d.sourceforge.net/tutorial/adv_image_reconst/basic_iterative.shtml</span>
2065 <span class="comment">% 3D Model</span>
2066 imdl= <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c2t4'</span>,16); <span class="comment">% 576 elements</span>
2067 imdl.solve = solver;
2068 imdl.reconst_type = <span class="string">'absolute'</span>;
2069 imdl.inv_solve_abs_core.prior_data = 1;
2070 imdl.inv_solve_abs_core.elem_prior = <span class="string">'conductivity'</span>;
2071 imdl.inv_solve_abs_core.elem_working = <span class="string">'log_conductivity'</span>;
2072 imdl.inv_solve_abs_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2073 imdl.inv_solve_abs_core.calc_solution_error = 0;
2074 imdl.inv_solve_abs_core.verbose = 0;
2075 <span class="comment">%show_fem(imdl.fwd_model);</span>
2076 imgsrc= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl.fwd_model, 1);
2077 <span class="comment">% set homogeneous conductivity and simulate</span>
2078 vh=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgsrc);
2079 <span class="comment">% set inhomogeneous conductivity and simulate</span>
2080 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2081 x= ctrs(:,1); y= ctrs(:,2);
2082 r1=sqrt((x+5).^2 + (y+5).^2); r2 = sqrt((x-85).^2 + (y-65).^2);
2083 imgsrc.elem_data(r1&lt;50)= 0.05;
2084 imgsrc.elem_data(r2&lt;30)= 100;
2085 imgp = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>);
2086 hh=clf; subplot(221); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgp,1); axis tight; title(<span class="string">'synthetic data, logC'</span>);
2087 <span class="comment">% inhomogeneous data</span>
2088 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2089 <span class="comment">% add noise</span>
2090 <span class="comment">%Add 30dB SNR noise to data</span>
2091 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2092 vi.meas = vi.meas + noise_level*randn(size(vi.meas));
2093 <span class="comment">% Reconstruct Images</span>
2094 img1= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2095 figure(hh); subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img1,1); axis tight; title(<span class="string">'#1 verbosity=default'</span>);
2096 <span class="comment">% -------------</span>
2097 disp(<span class="string">'TEST: previous solved at default verbosity'</span>);
2098 disp(<span class="string">'TEST: now solve same at verbosity=0 --&gt; should be silent'</span>);
2099 imdl.inv_solve_abs_core.verbose = 0;
2100 <span class="comment">%imdl.inv_solve_abs_core.meas_working = 'apparent_resistivity';</span>
2101 img2= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2102 figure(hh); subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2,1); axis tight; title(<span class="string">'#2 verbosity=0'</span>);
2103 max_err = max(abs((img1.elem_data - img2.elem_data)./(img1.elem_data)));
2104 
2105 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img2'</span>, max_err &gt;0.15, 0);
2106 <span class="keyword">if</span> max_err &gt; 0.15
2107   fprintf(<span class="string">'TEST:  img1 != img2 --&gt; FAIL %g %%\n'</span>, max_err);
2108 <span class="keyword">end</span>
2109 <span class="comment">% -------------</span>
2110 disp(<span class="string">'TEST: try coarse2fine mapping'</span>);
2111 imdl_tmp= <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b2t4'</span>,16); <span class="comment">% 256 elements</span>
2112 <span class="comment">% convert fwd_model into rec_model</span>
2113 fmdl = imdl_tmp.fwd_model;
2114 cmdl.type = fmdl.type;
2115 cmdl.name = fmdl.name;
2116 cmdl.nodes = fmdl.nodes;
2117 cmdl.elems = fmdl.elems;
2118 cmdl.gnd_node = 0;
2119 <span class="comment">% merge some elements</span>
2120 <span class="comment">% TODO</span>
2121 <span class="comment">% delete some other elements from around the boundary</span>
2122 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(cmdl);
2123 x= ctrs(:,1); y= ctrs(:,2);
2124 r=sqrt((x+5).^2 + (y+5).^2);
2125 cmdl.elems(y-x &gt; 150, :) = [];
2126 
2127 <span class="comment">% build c2f map</span>
2128 imdl.rec_model = cmdl;
2129 c2f = <a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping( f_mdl, c_mdl );">mk_coarse_fine_mapping</a>(imdl.fwd_model,cmdl);
2130 imdl.fwd_model.coarse2fine = c2f;
2131 <span class="comment">% solve</span>
2132 <span class="comment">%imdl.inv_solve_abs_core.verbose = 10;</span>
2133 img3= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2134 <span class="comment">%figure(hh); subplot(224); show_fem(cmdl,1); axis tight; title('#3 c2f');</span>
2135 figure(hh); subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img3,1); axis tight; title(<span class="string">'#3 c2f'</span>);
2136 <span class="comment">% check</span>
2137 e1 = c2f \ img1.elem_data; <span class="comment">% noisy and unstable... but its a crude check</span>
2138 e3 = img3.elem_data;
2139 err = abs((e1 - e3) ./ e1);
2140 err(abs(e1) &lt; 20) = 0;
2141 err_thres = 0.55;
2142 
2143 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img3'</span>, any(err &gt; err_thres), 0);
2144 <span class="keyword">if</span> any(err &gt; err_thres) <span class="comment">% maximum 15% error</span>
2145   ni = find(err &gt; err_thres);
2146   fprintf(<span class="string">'TEST:  img1 != img3 --&gt; FAIL max(err) = %0.2e on %d elements (thres=%0.2e)\n'</span>, <span class="keyword">...</span>
2147           max(err(ni)), length(ni), err_thres);
2148 <span class="keyword">end</span>
2149 
2150 <span class="comment">%imdl.inv_solve_abs_core.verbose = 1000;</span>
2151 imdl.inv_solve_abs_core.elem_output = <span class="string">'log10_resistivity'</span>; <span class="comment">% resistivity output works</span>
2152 img4= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2153 figure(hh); subplot(224); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img4,1); axis tight; title(<span class="string">'#4 c2f + log10 resistivity out'</span>);
2154 <span class="comment">% check</span>
2155 e4 = 1./(10.^img4.elem_data);
2156 err = abs((e1 - e4) ./ e1);
2157 err(abs(e1) &lt; 20) = 0;
2158 err_thres = 0.40;
2159 
2160 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img1 == img4'</span>, any(err &gt; err_thres), 0);
2161 <span class="keyword">if</span> any(err &gt; err_thres) <span class="comment">% maximum 15% error</span>
2162   ni = find(err &gt; err_thres);
2163   fprintf(<span class="string">'TEST:  img1 != img4 --&gt; FAIL max(err) = %0.2e on %d elements (thres=%0.2e)\n'</span>, <span class="keyword">...</span>
2164           max(err(ni)), length(ni), err_thres);
2165 <span class="keyword">end</span>
2166 
2167 <span class="comment">% a couple easy reconstructions with movement or similar</span>
2168 <a name="_sub56" href="#_subfunctions" class="code">function do_unit_test_rec_mv(solver)</a>
2169 disp(<span class="string">'TEST: conductivity and movement --&gt; baseline conductivity only'</span>);
2170 <span class="comment">% -------------</span>
2171 <span class="comment">% ADAPTED FROM</span>
2172 <span class="comment">% Create simulation data $Id: inv_solve_abs_core.m 4941 2015-05-09 01:19:34Z aadler $</span>
2173 <span class="comment">%  http://eidors3d.sourceforge.net/tutorial/adv_image_reconst/basic_iterative.shtml</span>
2174 <span class="comment">% 3D Model</span>
2175 imdl= <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c2t4'</span>,16); <span class="comment">% 576 elements</span>
2176 ne = length(imdl.fwd_model.electrode);
2177 nt = length(imdl.fwd_model.elems);
2178 imdl.solve = solver;
2179 imdl.reconst_type = <span class="string">'absolute'</span>;
2180 <span class="comment">% specify the units to work in</span>
2181 imdl.inv_solve_abs_core.meas_input   = <span class="string">'voltage'</span>;
2182 imdl.inv_solve_abs_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2183 imdl.inv_solve_abs_core.elem_prior   = {   <span class="string">'conductivity'</span>   };
2184 imdl.inv_solve_abs_core.prior_data   = {        1           };
2185 imdl.inv_solve_abs_core.elem_working = {<span class="string">'log_conductivity'</span>};
2186 imdl.inv_solve_abs_core.elem_output  = {<span class="string">'log10_conductivity'</span>};
2187 imdl.inv_solve_abs_core.calc_solution_error = 0;
2188 imdl.inv_solve_abs_core.verbose = 0;
2189 imdl.hyperparameter.value = 0.01;
2190 
2191 <span class="comment">% set homogeneous conductivity and simulate</span>
2192 imgsrc= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl.fwd_model, 1);
2193 vh=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(imgsrc);
2194 <span class="comment">% set inhomogeneous conductivity</span>
2195 ctrs= <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(imdl.fwd_model);
2196 x= ctrs(:,1); y= ctrs(:,2);
2197 r1=sqrt((x+5).^2 + (y+5).^2); r2 = sqrt((x-45).^2 + (y-35).^2);
2198 imgsrc.elem_data(r1&lt;50)= 0.05;
2199 imgsrc.elem_data(r2&lt;30)= 100;
2200 
2201 <span class="comment">% inhomogeneous data</span>
2202 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2203 <span class="comment">% add noise</span>
2204 <span class="comment">%Add 30dB SNR noise to data</span>
2205 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2206 vi.meas = vi.meas + noise_level*randn(size(vi.meas));
2207 
2208 <span class="comment">% show model</span>
2209 hh=clf; subplot(221); imgp = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgp,1); axis tight; title(<span class="string">'synth baseline, logC'</span>);
2210 
2211 <span class="comment">% Reconstruct Images</span>
2212 img0= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2213 figure(hh); subplot(222);
2214  img0 = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img0, <span class="string">'log10_conductivity'</span>);
2215  <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img0, 1); axis tight;
2216 
2217 disp(<span class="string">'TEST: conductivity + movement'</span>);
2218 imdl.fwd_model = rmfield(imdl.fwd_model, <span class="string">'jacobian'</span>);
2219 <span class="comment">% specify the units to work in</span>
2220 imdl.inv_solve_abs_core.elem_prior   = {   <span class="string">'conductivity'</span>   , <span class="string">'movement'</span>};
2221 imdl.inv_solve_abs_core.prior_data   = {        1           ,     0     };
2222 imdl.inv_solve_abs_core.RtR_prior    = {     @<a href="../../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>, @<a href="#_sub58" class="code" title="subfunction RtR = prior_movement_only(imdl);">prior_movement_only</a>};
2223 imdl.inv_solve_abs_core.elem_len     = {       nt           ,   ne*2    };
2224 imdl.inv_solve_abs_core.elem_working = {  <span class="string">'log_conductivity'</span>, <span class="string">'movement'</span>};
2225 imdl.inv_solve_abs_core.elem_output  = {<span class="string">'log10_conductivity'</span>, <span class="string">'movement'</span>};
2226 imdl.inv_solve_abs_core.jacobian     = { @<a href="../../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>  , @<a href="#_sub57" class="code" title="subfunction Jm = jacobian_movement_only (fwd_model, img);">jacobian_movement_only</a>};
2227 imdl.inv_solve_abs_core.hyperparameter = {   [1 1.1 0.9]    ,  sqrt(2e-3)     }; <span class="comment">% multiplied by imdl.hyperparameter.value</span>
2228 imdl.inv_solve_abs_core.verbose = 2;
2229 
2230 <span class="comment">% electrode positions before</span>
2231 nn = [imgsrc.fwd_model.electrode(:).nodes];
2232 elec_orig = imgsrc.fwd_model.nodes(nn,:);
2233 <span class="comment">% set 2% radial movement</span>
2234 nn = imgsrc.fwd_model.nodes;
2235 imgsrc.fwd_model.nodes = nn * [1-0.02 0; 0 1+0.02]; <span class="comment">% 1% compress X, 1% expansion Y, NOT conformal</span>
2236 <span class="comment">% electrode positions after</span>
2237 nn = [imgsrc.fwd_model.electrode(:).nodes];
2238 elec_mv = imgsrc.fwd_model.nodes(nn,:);
2239 
2240 <span class="comment">% inhomogeneous data</span>
2241 vi=<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( imgsrc );
2242 <span class="comment">% add noise</span>
2243 <span class="comment">%Add 30dB SNR noise to data</span>
2244 noise_level= std(vi.meas - vh.meas)/10^(30/20);
2245 <span class="comment">%vi.meas = vi.meas + noise_level*randn(size(vi.meas));</span>
2246 
2247 <span class="comment">% show model</span>
2248 nn = [imgsrc.fwd_model.electrode(1:4).nodes];
2249 figure(hh); subplot(223); imgp = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(imgsrc, <span class="string">'log10_conductivity'</span>); <a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>(imgp,elec_mv-elec_orig,10,1); axis tight; title(<span class="string">'synth mvmt, logC'</span>);
2250 
2251 <span class="comment">% Reconstruct Images</span>
2252 img1= <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vi);
2253 figure(hh); subplot(224);
2254  imgm = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img1, <span class="string">'movement'</span>);
2255  img1 = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img1, <span class="string">'log10_conductivity'</span>);
2256  <a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>(img1,reshape(imgm.elem_data,16,2), 10, 1); axis tight;
2257 
2258 <span class="comment">% TEST for mismatch on coductivity image</span>
2259 err = abs((img0.elem_data - img1.elem_data) ./ img0.elem_data);
2260 err(abs(img0.elem_data)/max(abs(img0.elem_data)) &lt; 0.50) = 0;
2261 err_thres = 0.40;
2262 
2263 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'img0 == img1 + mvmt'</span>, any(err &gt; err_thres), 0);
2264 
2265 <span class="keyword">if</span> any(err &gt; err_thres) <span class="comment">% maximum 15% error</span>
2266   ni = find(err &gt; err_thres);
2267   fprintf(<span class="string">'TEST:  img0 != img1 + mvmt --&gt; FAIL max(err) = %0.2e on %d elements (thres=%0.2e)\n'</span>, <span class="keyword">...</span>
2268           max(err(ni)), length(ni), err_thres);
2269 <span class="keyword">end</span>
2270 
2271 <span class="comment">% helper function: calculate jacobian movement by itself</span>
2272 <a name="_sub57" href="#_subfunctions" class="code">function Jm = jacobian_movement_only (fwd_model, img);</a>
2273   pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>(img.fwd_model);
2274   szJm = pp.n_elec * pp.n_dims; <span class="comment">% number of electrodes * dimensions</span>
2275   img = <a href="#_sub47" class="code" title="subfunction img = map_img(img, out);">map_img</a>(img, <span class="string">'conductivity'</span>); <span class="comment">% expect conductivity only</span>
2276   Jcm = <a href="../../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(fwd_model, img);
2277   Jm = Jcm(:,(end-szJm+1):end);
2278 <span class="comment">%% this plot shows we are grabing the right section of the Jacobian</span>
2279 <span class="comment">%  figure();</span>
2280 <span class="comment">%  subplot(311); imagesc(Jcm); axis ij equal tight; xlabel(sprintf('||Jcm||=%g',norm(Jcm))); colorbar;</span>
2281 <span class="comment">%  Jc = jacobian_adjoint(fwd_model, img);</span>
2282 <span class="comment">%  subplot(312); imagesc([Jc Jm]); axis ij equal tight; xlabel(sprintf('||[Jc Jm]||=%g',norm([Jc Jm]))); colorbar;</span>
2283 <span class="comment">%  dd = abs([Jc Jm]-Jcm); % difference</span>
2284 <span class="comment">%  subplot(313); imagesc(dd); axis ij equal tight; xlabel(sprintf('|| |[Jc Jm]-Jcm| ||=%g',norm(dd))); colorbar;</span>
2285 
2286 <a name="_sub58" href="#_subfunctions" class="code">function RtR = prior_movement_only(imdl);</a>
2287   imdl.image_prior.parameters(1) = 1; <span class="comment">% weighting of movement vs. conductivity ... but we're dropping conductivity here</span>
2288   pp = <a href="../../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>(imdl.fwd_model);
2289   szPm = pp.n_elec * pp.n_dims; <span class="comment">% number of electrodes * dimensions</span>
2290   RtR = <a href="prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>(imdl);
2291   RtR = RtR((end-szPm+1):<span class="keyword">end</span>,(end-szPm+1):end);
2292 
2293 <a name="_sub59" href="#_subfunctions" class="code">function do_unit_test_rec2(solver)</a>
2294 disp(<span class="string">'TEST: reconstruct a discontinuity'</span>);
2295 shape_str = [<span class="string">'solid top    = plane(0,0,0;0,1,0);\n'</span> <span class="keyword">...</span>
2296              <span class="string">'solid mainobj= top and orthobrick(-100,-200,-100;410,10,100) -maxh=20.0;\n'</span>];
2297 e0 = linspace(0,310,64)';
2298 elec_pos = [e0,0*e0,0*e0,1+0*e0,0*e0,0*e0];
2299 elec_shape= [0.1,0.1,1];
2300 elec_obj = <span class="string">'top'</span>;
2301 fmdl = <a href="../../../eidors/meshing/netgen/ng_mk_gen_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_gen_models(shape_str, elec_pos,  elec_shape, elec_obj, extra_ng_code);">ng_mk_gen_models</a>(shape_str, elec_pos, elec_shape, elec_obj);
2302 <span class="comment">%fmdl.nodes = fmdl.nodes(:,[1,3,2]);</span>
2303 <span class="comment">% spacing= [1 1 1 2 3 3 4 4 5 6 6 7 8 8 9 10 10 11 12 12 13 14 14 15 16 17];</span>
2304 <span class="comment">% multiples= [1 2 3 2 1 5/3 1 2  1 1 7/6 1 1 10/8 1 1 12/10 1 1 13/12 1 1 15/14 1 1 1];</span>
2305 <span class="comment">% fmdl.stimulation= stim_pattern_geophys( 64, 'Schlumberger', {'spacings', spacing,'multiples',multiples});</span>
2306 
2307 fmdl.stimulation= <a href="../../../eidors/models/stim_pattern_geophys.html" class="code" title="function [stim,S]= stim_pattern_geophys( n_elec, pat_type,  options )">stim_pattern_geophys</a>( 64, <span class="string">'Wenner'</span>, {<span class="string">'spacings'</span>, 1:32} );
2308 
2309 cmdl= <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([], 2.5+[-30,5,20,30:10:290,300,315,340], <span class="keyword">...</span>
2310                             -[0:5:10 17 30 50 75 100]);
2311 <span class="comment">% having a c2f on the coarse model f#$%s up the c2f calculator</span>
2312 cmdl= rmfield(cmdl, <span class="string">'coarse2fine'</span>);
2313 <span class="comment">% cmdl = mk_grid_model([], 2.5+[-50,-20,0:10:310,330,360], ...</span>
2314 <span class="comment">%                              -[0:2.5:10, 15:5:25,30:10:80,100,120]);</span>
2315 [c2f, b_c2f] = <a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping( f_mdl, c_mdl );">mk_coarse_fine_mapping</a>( fmdl, cmdl);
2316 <span class="comment">% c2f maps cmdl elements to fmdl elements, where there are no cmdl elements</span>
2317 <span class="comment">% b_c2f is the cmdl background element that is mapped to the fmdl elements</span>
2318 <span class="comment">% Note: adding a background element, this is now done inside the inv_solve_abs_GN solver if required</span>
2319 <span class="comment">%S= sum(c2f,2);</span>
2320 <span class="comment">% find fractional c2f elements</span>
2321 <span class="comment">%b= find(S&lt;0.9999);</span>
2322 <span class="comment">% find almost complete c2f elements</span>
2323 <span class="comment">%a= find(S&gt;=0.9999 &amp; S&lt;1);</span>
2324 <span class="comment">% fix potential rounding problems by normalizing c2f to sum to 1</span>
2325 <span class="comment">%c2f(a,:)= c2f(a,:)./repmat(S(a),1,size(c2f,2));</span>
2326 <span class="comment">% remove the entire element's mapping and assign it the background conductivity</span>
2327 <span class="comment">%c2f(b,:)= 0; c2f(b,end+1)= 1;</span>
2328 fmdl.coarse2fine= c2f;
2329 
2330 <span class="comment">% generate sythetic data</span>
2331 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,1);
2332 fm_pts = <a href="../../../eidors/models/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(fmdl);
2333 x_bary= fm_pts(:,1); z_bary= fm_pts(:,2);
2334 z_params= (min(fmdl.nodes(:,2)):max(fmdl.nodes(:,2)))';
2335 a = 0.36;
2336 b = 130;
2337 x_params= a*z_params+b;
2338 xlim=interp1(z_params,x_params,z_bary);
2339 img.elem_data(x_bary&gt;xlim)= 0.01;
2340 clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img); title(<span class="string">'model'</span>);
2341 
2342 <span class="comment">% img2= mk_image(fmdl,img.elem_data);</span>
2343 <span class="comment">% clf; show_fem(img2);</span>
2344 
2345 <span class="comment">% img = mk_image(fmdl,0+ mk_c2f_circ_mapping(fmdl,[100;-30;0;50])*100);</span>
2346 <span class="comment">% img.elem_data(img.elem_data==0)= 0.1;</span>
2347 dd  = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
2348 <span class="comment">% TODO add some noise!!!</span>
2349 
2350 imdl= <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'inv_model'</span>,<span class="string">'test'</span>);
2351 imdl.fwd_model= fmdl;
2352 imdl.rec_model= cmdl;
2353 imdl.fwd_model.normalize_measurements = 0;
2354 imdl.rec_model.normalize_measurements = 0;
2355 imdl.RtR_prior = @<a href="prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model );">prior_laplace</a>;
2356 <span class="comment">%imdl.RtR_prior = @prior_tikhonov;</span>
2357 imdl.solve = solver;
2358 imdl.reconst_type = <span class="string">'absolute'</span>;
2359 imdl.hyperparameter.value = 1e2; <span class="comment">% was 0.1</span>
2360 imdl.jacobian_bkgnd.value = 1;
2361 
2362 imdl.inv_solve_abs_core.elem_working = <span class="string">'log_conductivity'</span>;
2363 imdl.inv_solve_abs_core.meas_working = <span class="string">'apparent_resistivity'</span>;
2364 imdl.inv_solve_abs_core.dtol_iter = 4; <span class="comment">% default 1 -&gt; start checking on the first iter</span>
2365 imdl.inv_solve_abs_core.max_iterations = 20; <span class="comment">% default 10</span>
2366 
2367 <span class="comment">% the conversion to apparaent resistivity is now handled inside the solver</span>
2368 <span class="comment">%%img1= mk_image(fmdl,1);</span>
2369 <span class="comment">%%vh1= fwd_solve(img1);</span>
2370 <span class="comment">%%normalisation= 1./vh1.meas;</span>
2371 <span class="comment">%%I= speye(length(normalisation));</span>
2372 <span class="comment">%%I(1:size(I,1)+1:size(I,1)*size(I,1))= normalisation;</span>
2373 
2374 imdl.inv_solve_abs_core.calc_solution_error = 0;
2375 
2376 imdl.inv_solve_abs_core.verbose = 10;
2377 <span class="comment">%%imdl.inv_solve_abs_core.normalisation= I;</span>
2378 <span class="comment">%%imdl.inv_solve_abs_core.homogeneization= 1;</span>
2379 <span class="comment">% imdl.inv_solve_abs_core.fixed_background= 1; % the default now in _core</span>
2380 imdl.inv_solve_abs_core.line_search_args.perturb= [0 5*logspace(-7,-4,5)];
2381 <span class="comment">%imdl.inv_solve_abs_core.max_iterations= 10;</span>
2382 <span class="comment">%imdl.inv_solve_abs_core.plot_line_optimize = 1;</span>
2383 
2384 imdl.inv_solve_abs_core.elem_output = <span class="string">'log10_resistivity'</span>;
2385 imgr= <a href="inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">inv_solve_abs_core</a>(imdl, dd);
2386 
2387 <span class="comment">% save the result so we don't have to wait forever if we want to look at the result later</span>
2388 <span class="comment">%save('inv_solve_abs_core_rec2.mat', 'imgr');</span>
2389 
2390 imgGNd= imgr;
2391 <span class="comment">%imgGNd.fwd_model.coarse2fine= cmdl.coarse2fine;</span>
2392 <span class="comment">% removal of the background elem_data is now handled in the solver</span>
2393 <span class="comment">% conversion to output elem_data is now handled in the solver</span>
2394 <span class="comment">%imgGNd.elem_data= log10(imgGNd.res_data(1:end-1));</span>
2395 <span class="comment">%imgGNd.calc_colours.clim= 1.5;</span>
2396 <span class="comment">%imgGNd.calc_colours.ref_level= 1.5;</span>
2397 
2398 elec_posn= zeros(length(fmdl.electrode),3);
2399 <span class="keyword">for</span> i=1:length(fmdl.electrode)
2400     elec_posn(i,:)= mean(fmdl.nodes(fmdl.electrode(1,i).nodes,:),1);
2401 <span class="keyword">end</span>
2402 
2403 clf; <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgGNd,1);
2404 hold on; plot(elec_posn(:,1),elec_posn(:,3),<span class="string">'k*'</span>);
2405 axis tight; ylim([-100 0.5])
2406 xlabel(<span class="string">'X (m)'</span>,<span class="string">'fontsize'</span>,20,<span class="string">'fontname'</span>,<span class="string">'Times'</span>)
2407 ylabel(<span class="string">'Z (m)'</span>,<span class="string">'fontsize'</span>,20,<span class="string">'fontname'</span>,<span class="string">'Times'</span>)
2408 set(gca,<span class="string">'fontsize'</span>,20,<span class="string">'fontname'</span>,<span class="string">'Times'</span>);
2409 
2410 img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( imdl );
2411 img.elem_data= 1./(10.^imgr.elem_data);
2412 vCG= <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img); vCG = vCG.meas;
2413 
2414 I = 1; <span class="comment">% TODO FIXME -&gt; I is diag(1./vh) the conversion to apparent resistivity</span>
2415 <span class="comment">% TODO these plots are useful, get them built into the solver!</span>
2416 clf; plot(I*(dd.meas-vCG)); title(<span class="string">'data misfit'</span>);
2417 clf; hist(abs(I*(dd.meas-vCG)),50); title(<span class="string">'|data misfit|, histogram'</span>); xlabel(<span class="string">'|misfit|'</span>); ylabel(<span class="string">'count'</span>);
2418 clf; <a href="../../../eidors/graphics/matlab/show_pseudosection.html" class="code" title="function fwd_model= show_pseudosection( fwd_model, data, orientation)">show_pseudosection</a>( fmdl, I*dd.meas); title(<span class="string">'measurement data'</span>);
2419 clf; <a href="../../../eidors/graphics/matlab/show_pseudosection.html" class="code" title="function fwd_model= show_pseudosection( fwd_model, data, orientation)">show_pseudosection</a>( fmdl, I*vCG); title(<span class="string">'reconstruction data'</span>);
2420 clf; <a href="../../../eidors/graphics/matlab/show_pseudosection.html" class="code" title="function fwd_model= show_pseudosection( fwd_model, data, orientation)">show_pseudosection</a>( fmdl, (vCG-dd.meas)./dd.meas*100); title(<span class="string">'data misfit'</span>);</pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>