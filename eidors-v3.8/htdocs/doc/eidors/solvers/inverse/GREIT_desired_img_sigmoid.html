<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of GREIT_desired_img_sigmoid</title>
  <meta name="keywords" content="GREIT_desired_img_sigmoid">
  <meta name="description" content="GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">inverse</a> &gt; GREIT_desired_img_sigmoid.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/inverse&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>GREIT_desired_img_sigmoid
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT 
 PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)
   xyz     - array of centers of desired target images
               [2xN] - xy only
               [3xN] - xyz or, if radius = [], xyr
               [4xN] - xyzr (radius is ignored)
   radius  - the radius of the target on the desired image as a fraction
             of the model radius (half the larger dimension in xy)
   opt     - a struct with these fields:
      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may
                   have had some pixels/voxels removed (a rec_model that 
                   is not a complete rectangle/parallelepiped). 
      .steepness   [optional] a factor controling the amount of blur, see
                   below for details. Lower steepness gives more blur, but
                   if the value is too low, image may not reach the value 
                   of 1 at the center of the target. 
                   May be specified as a scalar, a [1xN] vector, or a
                   function handle with the signature:
                        func(pts)
                   where pts is either [2xN] or [3xN], dependig on the xyz
                   function input, e.g. @(xyz) 50./(xyz(3,:))
                   Default: 10./radius
      .desired_img_radius
                   [optional] Overwrites the radius input. May be 
                   specified as a scalar, a [1xN] vector or a function 
                   handle with the signature:
                        func(pts)
                   where pts is either [2xN] or [3xN], dependig on the xyz
                   function input, e.g. @(xyz) abs(xyz(3,:))/5

 The desired images approximate in each pixel the area integral of:
       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))
 where
       r   - position vector in 2D/3D space
       s   - opt.steepness
       r0  - target center
 For |r-r0| = radius, f(r) = 0.5.
 
 As of 2015-03-29, this is the default desired image function used by
 MK_GREIT_MODEL.

 See also: <a href="calc_GREIT_RM.html" class="code" title="function [RM, PJt, M] = calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">CALC_GREIT_RM</a>, MK_GREIT_MODEL, MK_PIXEL_SLICE</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function show_3d_slices(img, varargin);">show_3d_slices</a>	show_3d_slices(img, z_cuts, x_cuts, y_cuts, any_cuts)</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function PSF = desired_soln(xyz, radius, opt)</a></li><li><a href="#_sub2" class="code">function [X, Y, Z] = voxnodes(mdl)</a></li><li><a href="#_sub3" class="code">function [x,y,z,n] = interp_elem(mdl,e,radius, opt)</a></li><li><a href="#_sub4" class="code">function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a></li><li><a href="#_sub5" class="code">function [xyz, radius, opt] = parse_opt(xyz, radius, opt)</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)</a>
0002 <span class="comment">%GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</span>
0003 <span class="comment">% PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)</span>
0004 <span class="comment">%   xyz     - array of centers of desired target images</span>
0005 <span class="comment">%               [2xN] - xy only</span>
0006 <span class="comment">%               [3xN] - xyz or, if radius = [], xyr</span>
0007 <span class="comment">%               [4xN] - xyzr (radius is ignored)</span>
0008 <span class="comment">%   radius  - the radius of the target on the desired image as a fraction</span>
0009 <span class="comment">%             of the model radius (half the larger dimension in xy)</span>
0010 <span class="comment">%   opt     - a struct with these fields:</span>
0011 <span class="comment">%      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may</span>
0012 <span class="comment">%                   have had some pixels/voxels removed (a rec_model that</span>
0013 <span class="comment">%                   is not a complete rectangle/parallelepiped).</span>
0014 <span class="comment">%      .steepness   [optional] a factor controling the amount of blur, see</span>
0015 <span class="comment">%                   below for details. Lower steepness gives more blur, but</span>
0016 <span class="comment">%                   if the value is too low, image may not reach the value</span>
0017 <span class="comment">%                   of 1 at the center of the target.</span>
0018 <span class="comment">%                   May be specified as a scalar, a [1xN] vector, or a</span>
0019 <span class="comment">%                   function handle with the signature:</span>
0020 <span class="comment">%                        func(pts)</span>
0021 <span class="comment">%                   where pts is either [2xN] or [3xN], dependig on the xyz</span>
0022 <span class="comment">%                   function input, e.g. @(xyz) 50./(xyz(3,:))</span>
0023 <span class="comment">%                   Default: 10./radius</span>
0024 <span class="comment">%      .desired_img_radius</span>
0025 <span class="comment">%                   [optional] Overwrites the radius input. May be</span>
0026 <span class="comment">%                   specified as a scalar, a [1xN] vector or a function</span>
0027 <span class="comment">%                   handle with the signature:</span>
0028 <span class="comment">%                        func(pts)</span>
0029 <span class="comment">%                   where pts is either [2xN] or [3xN], dependig on the xyz</span>
0030 <span class="comment">%                   function input, e.g. @(xyz) abs(xyz(3,:))/5</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% The desired images approximate in each pixel the area integral of:</span>
0033 <span class="comment">%       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))</span>
0034 <span class="comment">% where</span>
0035 <span class="comment">%       r   - position vector in 2D/3D space</span>
0036 <span class="comment">%       s   - opt.steepness</span>
0037 <span class="comment">%       r0  - target center</span>
0038 <span class="comment">% For |r-r0| = radius, f(r) = 0.5.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% As of 2015-03-29, this is the default desired image function used by</span>
0041 <span class="comment">% MK_GREIT_MODEL.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% See also: CALC_GREIT_RM, MK_GREIT_MODEL, MK_PIXEL_SLICE</span>
0044 
0045 <span class="comment">% (C) 2015 Bartlomiej Grychtol - all rights reserved Swisstom AG.</span>
0046 <span class="comment">% License: GPL version 2 or 3</span>
0047 <span class="comment">% $Id: GREIT_desired_img_sigmoid.m 4986 2015-05-11 20:09:28Z aadler $</span>
0048 
0049 <span class="comment">% &gt;&gt; SWISSTOM CONTRIBUTION &lt;&lt;</span>
0050 
0051 <span class="keyword">if</span> ischar(xyz) &amp;&amp; strcmp(xyz,<span class="string">'UNIT_TEST'</span>), <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>, <span class="keyword">end</span>
0052 
0053 [xyzr, radius, opt] = <a href="#_sub5" class="code" title="subfunction [xyz, radius, opt] = parse_opt(xyz, radius, opt)">parse_opt</a>(xyz, radius, opt);
0054 
0055 copt.cache_obj = {xyzr, radius, opt.rec_model.nodes, opt.rec_model.elems, opt.steepness};
0056 copt.fstr = <span class="string">'GREIT_desired_img_sigmoid'</span>;
0057 PSF = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction PSF = desired_soln(xyz, radius, opt)">desired_soln</a>,{xyzr, radius, opt},copt);
0058 
0059 
0060 <span class="keyword">end</span>
0061 
0062 <span class="comment">%-------------------------------------------------------------------------%</span>
0063 <span class="comment">% The main function</span>
0064 <a name="_sub1" href="#_subfunctions" class="code">function PSF = desired_soln(xyz, radius, opt)</a>
0065    num_it = size(xyz,2);
0066     <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Composing desired images:'</span>,0,num_it);
0067     mdl = opt.rec_model;
0068     <span class="keyword">switch</span> opt.n_dim
0069         <span class="keyword">case</span> 3
0070             mdl.vox = [mdl.elems(1:6:<span class="keyword">end</span>,:) mdl.elems(6:6:<span class="keyword">end</span>,:)];
0071         <span class="keyword">case</span> 2
0072             mdl.vox = [mdl.elems(1:2:<span class="keyword">end</span>,:) mdl.elems(2:2:<span class="keyword">end</span>,:)];
0073     <span class="keyword">end</span>
0074     [Xnodes,Ynodes,Znodes] = <a href="#_sub2" class="code" title="subfunction [X, Y, Z] = voxnodes(mdl)">voxnodes</a>(mdl);
0075     
0076     <span class="keyword">for</span> i=1:size(xyz,2);
0077         th = log(1e4)/opt.steepness(i);
0078         <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(i,num_it);
0079         farel = <a href="#_sub4" class="code" title="subfunction farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)">far_elems</a>(Xnodes,Ynodes,Znodes, xyz(:,i), radius(i), th);
0080         el_idx = find(~farel);
0081         X = []; Y = []; Z = [];
0082         idx = []; factor = [];
0083         <span class="keyword">for</span> e = el_idx'
0084             [x,y,z] = <a href="#_sub3" class="code" title="subfunction [x,y,z,n] = interp_elem(mdl,e,radius, opt)">interp_elem</a>(mdl,e,radius(i), opt);
0085             X = [X ; x(:)]; Y = [Y ; y(:)]; Z = [Z ; z(:)];
0086             n = numel(x);
0087             idx = [idx; e*ones(n,1)];
0088             factor = [factor; ones(n,1)/n];
0089         <span class="keyword">end</span>
0090         D = sqrt(sum(bsxfun(@minus,[X Y Z],xyz(:,i)').^2, 2));
0091         x = D - radius(i);
0092         tmp = 1 ./ (1 + exp( opt.steepness(i) * x));
0093         PSF(:,i) = full(<a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(idx,1,tmp(:) .* factor,size(mdl.vox,1),1));
0094     <span class="keyword">end</span>
0095     <a href="../../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0096 <span class="keyword">end</span>
0097 
0098 <span class="comment">%-------------------------------------------------------------------------%</span>
0099 <span class="comment">% Generate internal points in elements</span>
0100 <a name="_sub2" href="#_subfunctions" class="code">function [X, Y, Z] = voxnodes(mdl)</a>
0101     x = mdl.nodes(:,1); X = x(mdl.vox);
0102     y = mdl.nodes(:,2); Y = y(mdl.vox);
0103     <span class="keyword">try</span>
0104         z = mdl.nodes(:,3); Z = z(mdl.vox);
0105     <span class="keyword">catch</span>
0106         Z = [];
0107     <span class="keyword">end</span>  
0108 <span class="keyword">end</span>
0109 
0110 <span class="comment">%-------------------------------------------------------------------------%</span>
0111 <span class="comment">% Generate internal points in elements</span>
0112 <a name="_sub3" href="#_subfunctions" class="code">function [x,y,z,n] = interp_elem(mdl,e,radius, opt)</a>
0113     maxsep = radius/5;
0114 
0115     minnode = min(mdl.nodes(mdl.vox(e,:),:));
0116     maxnode = max(mdl.nodes(mdl.vox(e,:),:));
0117     vec = {};
0118     <span class="keyword">for</span> d = 1:opt.n_dim
0119         sep = maxnode(d) - minnode(d);
0120         N = max(3, ceil(sep/maxsep)+1);
0121         v = linspace(minnode(d),maxnode(d),N);
0122         v(end) = [];
0123         v = v + .5*(maxnode(d)-minnode(d))/(N-1);
0124         vec{d} = v;
0125     <span class="keyword">end</span>
0126     <span class="keyword">switch</span> opt.n_dim
0127         <span class="keyword">case</span> 3
0128             [x, y, z] = ndgrid(vec{:});
0129         <span class="keyword">case</span> 2
0130             [x, y] = ndgrid(vec{:});
0131             z = [];
0132     <span class="keyword">end</span>
0133 <span class="keyword">end</span>
0134 
0135 <span class="comment">%-------------------------------------------------------------------------%</span>
0136 <span class="comment">% Find elements where the function value is negligable</span>
0137 <a name="_sub4" href="#_subfunctions" class="code">function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)</a>
0138     farel = false(size(Xnodes,1),1);
0139 
0140     nodes_test = Xnodes &lt; xyz(1) - radius - th;
0141     farel = farel | all(nodes_test,2);
0142     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0143     nodes_test = Xnodes &gt; xyz(1) + radius + th;
0144     farel = farel | all(nodes_test,2);
0145     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0146     nodes_test = Ynodes &lt; xyz(2) - radius - th;
0147     farel = farel | all(nodes_test,2);
0148     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0149     nodes_test = Ynodes &gt; xyz(2) + radius + th;
0150     farel = farel | all(nodes_test,2);
0151     <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0152     <span class="keyword">if</span> ~isempty(Znodes)
0153         nodes_test  = Znodes &gt; xyz(3) + radius + th;
0154         farel = farel | all(nodes_test,2);
0155         <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0156         nodes_test  = Znodes &lt; xyz(3) - radius - th;
0157         farel = farel | all(nodes_test,2);
0158         <span class="keyword">if</span> all(farel), <span class="keyword">return</span>, <span class="keyword">end</span>;
0159     <span class="keyword">end</span>
0160     idx = find(~farel);
0161 <span class="keyword">end</span>
0162 
0163 <span class="comment">%-------------------------------------------------------------------------%</span>
0164 <span class="comment">% Parse options</span>
0165 <a name="_sub5" href="#_subfunctions" class="code">function [xyz, radius, opt] = parse_opt(xyz, radius, opt)</a>
0166 
0167     scale_radius = false;
0168     <span class="keyword">if</span> isempty(radius)
0169         radius = xyz(<span class="keyword">end</span>,:);
0170         scale_radius = true;
0171         xyz(<span class="keyword">end</span>,:) = [];
0172     <span class="keyword">end</span>
0173     
0174     <span class="keyword">if</span> isfield(opt,<span class="string">'desired_img_radius'</span>)
0175        scale_radius = false;
0176        <span class="keyword">if</span> isnumeric(opt.desired_img_radius)
0177           radius = opt.desired_img_radius;
0178        <span class="keyword">end</span>
0179        <span class="keyword">if</span> isa(opt.desired_img_radius, <span class="string">'function_handle'</span>)
0180           radius = feval(opt.desired_img_radius,xyz);
0181        <span class="keyword">end</span>
0182     <span class="keyword">end</span>
0183         
0184     <span class="keyword">if</span> ~isfield(opt, <span class="string">'steepness'</span>)
0185         opt.steepness = 10./radius;
0186     <span class="keyword">elseif</span> isa(opt.steepness,<span class="string">'function_handle'</span>)
0187         opt.steepness = feval(opt.steepness,xyz);
0188     <span class="keyword">end</span>
0189     
0190     
0191     mdl = opt.rec_model; <span class="comment">% must exist</span>
0192     opt.n_dim = size(mdl.nodes,2);
0193     xyz = xyz(1:opt.n_dim, :); <span class="comment">% ingore z if model is 2D</span>
0194     
0195 
0196     opt.meshsz = [];
0197     <span class="keyword">try</span>
0198         <span class="keyword">for</span> i = 1:3
0199             opt.meshsz = [opt.meshsz min(mdl.nodes(:,i)) max(mdl.nodes(:,i))];
0200         <span class="keyword">end</span>
0201     <span class="keyword">end</span>
0202     
0203     opt.n_dim = length(opt.meshsz)/2;
0204     opt.meshsz = reshape(opt.meshsz,2,[])';
0205 
0206     opt.minpt = opt.meshsz(:,1);
0207     opt.maxpt = opt.meshsz(:,2);
0208     opt.range = opt.maxpt - opt.minpt;
0209     opt.maxrange = max(opt.range(1:2));
0210 
0211     <span class="comment">%rescale points to between -1 and 1 in the x-y plane</span>
0212     xyz = 2*bsxfun(@minus, xyz, mean(opt.meshsz,2))/opt.maxrange;
0213     mdl.nodes = 2*bsxfun(@minus, mdl.nodes, mean(opt.meshsz(1:size(mdl.nodes,2),:),2)')/opt.maxrange;
0214     opt.rec_model = mdl;
0215     <span class="keyword">if</span> scale_radius
0216         radius = radius / opt.maxrange;
0217     <span class="keyword">end</span>
0218 
0219     
0220     <span class="keyword">if</span> numel(opt.steepness) == 1
0221        opt.steepness = ones(1,size(xyz,2)) * opt.steepness;
0222     <span class="keyword">end</span>
0223     
0224     <span class="keyword">if</span> numel(radius) == 1
0225         radius = ones(1,size(xyz,2)) * radius;
0226     <span class="keyword">end</span>
0227 <span class="keyword">end</span>
0228 
0229 <span class="comment">%-------------------------------------------------------------------------%</span>
0230 <span class="comment">% UNIT_TEST</span>
0231 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0232     v = linspace(-1,1,32);
0233     mdl= <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],v,v,[0 .7 1:.2:2 2.3 3]);
0234     opt.rec_model = mdl;
0235     opt.steepness = @(xyz) 50./xyz(3,:);
0236     opt.desired_img_radius = @(xyz) xyz(3,:)/5;
0237     xyzr = zeros(5,4);
0238     xyzr(:,4) = .25;
0239     xyzr(:,3) = .5:.5:2.5;
0240     sol = <a href="GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>(xyzr',[],opt);
0241     img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,0);
0242     <span class="keyword">for</span> i = 1:5
0243         subplot(2,3,i)
0244         img.elem_data= sol(:,i);
0245         <a href="../../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function show_3d_slices(img, varargin);">show_3d_slices</a>(img,xyzr(i,3),xyzr(i,2),xyzr(i,1));
0246     <span class="keyword">end</span>
0247     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'UNIT_TEST: Showed %d images to verify'</span>,i,0);
0248 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>