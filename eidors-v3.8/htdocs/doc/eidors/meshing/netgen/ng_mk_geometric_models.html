<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ng_mk_geometric_models</title>
  <meta name="keywords" content="ng_mk_geometric_models">
  <meta name="description" content="NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">meshing</a> &gt; <a href="index.html">netgen</a> &gt; ng_mk_geometric_models.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/meshing/netgen&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ng_mk_geometric_models
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body
 and electrodes are defined as combinations of solid primitives. The 3-D
 surface intersection of the electrode and body volumes define the
 electrode surfaces.

[fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)

 INPUT:
  body_geometry      - Structure whose fields describe body geometries as
                       combinations of unions, intersections and 
                       complements of solid primitives. Cell array
                       should be used when describing several body 
                       geometries.

  electrode_geometry - Structure whose fields describe electrode
                       geometries as combinations of unions, intersections
                       and complements of solid primitives. Cell array
                       should be used when describing several electrode 
                       geometries.

 The following field names are available for geometry descriptions. Each 
 field is followed by the available subfields whose default values if left 
 unspecified are indicated between parentheses. 

 complement_flag:    If true, the desired geometry description is the
                     complement of the geometry description. (false)

 body_of_revolution: A body of revolution is described with the following
                     subfields: axis_point_a ([0; 0; 0]), axis_point_b 
                     ([0; 0; 1]), points (1 1; 1 2; 2 2; 2 1]),
                     segments ([1 2; 2 3; 3 4; 4 1]), complement_flag
                     (false).    

 cone:               A cone is described with the following subfields:
                     bottom_center ([0; 0; 0]), bottom_radius (1),
                     top_center ([0; 0; 1]), top_radius (0.5),
                     complement_flag (false).                    

 cylinder:           A cylinder is described with the following subfields:
                     bottom_center ([0; 0; 0]), top_center ([0; 0; 1]),
                     radius (1), complement_flag (false).

 ellipsoid:          An ellipsoid is described with the following
                     subfields: center ([0; 0; 0]), axis_a ([1; 0; 0]),
                     axis_b ([0; 1; 0]), axis_c ([0; 0; 1]),
                     complement_flag (false).

 elliptic_cylinder:  An elliptic cylinder is described with the following
                     subfields: bottom_center ([0; 0; 0]),
                     top_center ([0; 0; 1]), axis_a ([1; 0; 0]),
                     axis_b ([0; 1; 0]), complement_flag (false). 

 enter_body_flag:    This flag can be used only for electrode geometry
                     descriptions to indicate that the associated
                     electrode solid enters the body solids. It can only
                     be defined at the top level of each geometry
                     description. If this flag is true, it means that the
                     volume of the electrode intersecting with any body is
                     part of the electrode, otherwise it is part of a
                     body. (false)

 half_space          A half-space is described by the following subfields:
                     point ([0; 0; 0]), outward_normal_vector ([0; 0; 1]),
                     complement_flag (false).

 intersection:       This fields indicates to perform the intersection of
                     all subfields. Subfields: complement_flag (false).

 keep_material_flag: This flag can be used only for electrode geometry 
                     descriptions to indicate that the associated
                     electrode material should be kept in the final mesh.
                     It can only be defined at the top level of each
                     geometry description. If true, it means that the
                     volume of the electrode is meshed. Volume elements
                     that are part of the mesh are indicated in mat_idx
                     output argument. (false)

 max_edge_length:    This parameter is used to adjust the maximum size of
                     the element composing the mesh. It can only be used
                     at the top level of each geometry description. (inf)

 name:               This parameter is used to name the geometry
                     description.

 ortho_brick:        An ortho-brick is described by the following
                     subfields: opposite_corner_a ([0; 0; 0]),
                     opposite_corner_b ([1; 1; 1]), complement_flag
                     (false).

 parallelepiped:     A parallelepiped is described by the following
                     subfields: vertex ([0; 0; 0]), vector_a ([1; 0; 0]),
                     vector_b ([0; 1; 0]), vector_c ([0; 0; 1]),
                     complement_flag (false).

 point:              This parameter describes a point. It can only be used
                     at the top level of an electrode geometry
                     description. It must be the only field in the
                     structure. ([])

 sphere:             A sphere is described with the following subfields:
                     center ([0; 0; 0]), radius (1), complement_flag
                     (false).

 union:              This will perform the union of all its subfields.
                     There is an implicit union operator at the top level
                     of the geometry structure. Subfields: complement_flag
                     (false)

 OUTPUT:
  fmdl               - EIDORS forward model object.

  mat_idx            - Vector indicating for each mesh element the indices
                       of materials corresponding as separately defined
                       by input argument body_geometry.

 USAGE EXAMPLES:
 % 3D cylinder with radius 1. One plane of 16 electrodes with radius 0.1
   body_geometry.cylinder = struct;
   n_elect = 16;
   theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
   for i = 1:n_elect
     electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
     electrode_geometry{i}.sphere.radius = 0.1;
   end
   fmdl = ng_mk_geometric_models(body_geometry, electrode_geometry);</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>	CALL_NETGEN: call netgen to create a vol_file from a geo_file</li><li><a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>	NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</li><li><a href="../../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>	NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</li><li><a href="../../../eidors/meshing/ng_mk_common_model.html" class="code" title="function fmdl = ng_mk_common_model(mdl_type,mdl_shape, elec_pos, elec_shape);">ng_mk_common_model</a>	NG_MK_COMMON_MODEL: utility to create common models</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [fmdl_mat_idx] = mk_geometric_models(body_geometry, electrode_geometry)</a></li><li><a href="#_sub2" class="code">function radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub3" class="code">function point = assign_point(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub4" class="code">function point_list = assign_list_of_3D_points(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub5" class="code">function segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub6" class="code">function segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub7" class="code">function flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub8" class="code">function [extra_code extra_param] = parse_geometry_point(geometry)</a></li><li><a href="#_sub9" class="code">function [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)</a></li><li><a href="#_sub10" class="code">function [geo_code extra_code] = parse_geometry_body_of_extrusion(body_of_extrusion, operator_string)</a></li><li><a href="#_sub11" class="code">function [geo_code extra_code] = parse_geometry_body_of_revolution(body_of_revolution, operator_string)</a></li><li><a href="#_sub12" class="code">function geo_code = parse_geometry_cone(cone, operator_string)</a></li><li><a href="#_sub13" class="code">function geo_code = parse_geometry_cylinder(cylinder, operator_string)</a></li><li><a href="#_sub14" class="code">function geo_code = parse_geometry_ellipsoid(ellipsoid, operator_string)</a></li><li><a href="#_sub15" class="code">function geo_code = parse_geometry_elliptic_cylinder(elliptic_cylinder, operator_string)</a></li><li><a href="#_sub16" class="code">function geo_code = parse_geometry_half_space(half_space, operator_string)</a></li><li><a href="#_sub17" class="code">function geo_code = parse_geometry_ortho_brick(ortho_brick, operator_string)</a></li><li><a href="#_sub18" class="code">function geo_code = parse_geometry_parallelepiped(parallelepiped, operator_string)</a></li><li><a href="#_sub19" class="code">function geo_code = parse_geometry_sphere(sphere, operator_string)</a></li><li><a href="#_sub20" class="code">function write_geo_file(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param)</a></li><li><a href="#_sub21" class="code">function mat = read_mat_from_file(fid, nrows, ncols)</a></li><li><a href="#_sub22" class="code">function fmdl = read_vol_file(vol_fn, electrode_extra_param)</a></li><li><a href="#_sub23" class="code">function fmdl = complete_fmdl(fmdl, electrode_extra_param)</a></li><li><a href="#_sub24" class="code">function do_unit_test</a></li><li><a href="#_sub25" class="code">function [fmdl, opts] = do_test_number(tn)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)</a>
0002 <span class="comment">% NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</span>
0003 <span class="comment">% and electrodes are defined as combinations of solid primitives. The 3-D</span>
0004 <span class="comment">% surface intersection of the electrode and body volumes define the</span>
0005 <span class="comment">% electrode surfaces.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%[fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% INPUT:</span>
0010 <span class="comment">%  body_geometry      - Structure whose fields describe body geometries as</span>
0011 <span class="comment">%                       combinations of unions, intersections and</span>
0012 <span class="comment">%                       complements of solid primitives. Cell array</span>
0013 <span class="comment">%                       should be used when describing several body</span>
0014 <span class="comment">%                       geometries.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%  electrode_geometry - Structure whose fields describe electrode</span>
0017 <span class="comment">%                       geometries as combinations of unions, intersections</span>
0018 <span class="comment">%                       and complements of solid primitives. Cell array</span>
0019 <span class="comment">%                       should be used when describing several electrode</span>
0020 <span class="comment">%                       geometries.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% The following field names are available for geometry descriptions. Each</span>
0023 <span class="comment">% field is followed by the available subfields whose default values if left</span>
0024 <span class="comment">% unspecified are indicated between parentheses.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% complement_flag:    If true, the desired geometry description is the</span>
0027 <span class="comment">%                     complement of the geometry description. (false)</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% body_of_revolution: A body of revolution is described with the following</span>
0030 <span class="comment">%                     subfields: axis_point_a ([0; 0; 0]), axis_point_b</span>
0031 <span class="comment">%                     ([0; 0; 1]), points (1 1; 1 2; 2 2; 2 1]),</span>
0032 <span class="comment">%                     segments ([1 2; 2 3; 3 4; 4 1]), complement_flag</span>
0033 <span class="comment">%                     (false).</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% cone:               A cone is described with the following subfields:</span>
0036 <span class="comment">%                     bottom_center ([0; 0; 0]), bottom_radius (1),</span>
0037 <span class="comment">%                     top_center ([0; 0; 1]), top_radius (0.5),</span>
0038 <span class="comment">%                     complement_flag (false).</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% cylinder:           A cylinder is described with the following subfields:</span>
0041 <span class="comment">%                     bottom_center ([0; 0; 0]), top_center ([0; 0; 1]),</span>
0042 <span class="comment">%                     radius (1), complement_flag (false).</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% ellipsoid:          An ellipsoid is described with the following</span>
0045 <span class="comment">%                     subfields: center ([0; 0; 0]), axis_a ([1; 0; 0]),</span>
0046 <span class="comment">%                     axis_b ([0; 1; 0]), axis_c ([0; 0; 1]),</span>
0047 <span class="comment">%                     complement_flag (false).</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% elliptic_cylinder:  An elliptic cylinder is described with the following</span>
0050 <span class="comment">%                     subfields: bottom_center ([0; 0; 0]),</span>
0051 <span class="comment">%                     top_center ([0; 0; 1]), axis_a ([1; 0; 0]),</span>
0052 <span class="comment">%                     axis_b ([0; 1; 0]), complement_flag (false).</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% enter_body_flag:    This flag can be used only for electrode geometry</span>
0055 <span class="comment">%                     descriptions to indicate that the associated</span>
0056 <span class="comment">%                     electrode solid enters the body solids. It can only</span>
0057 <span class="comment">%                     be defined at the top level of each geometry</span>
0058 <span class="comment">%                     description. If this flag is true, it means that the</span>
0059 <span class="comment">%                     volume of the electrode intersecting with any body is</span>
0060 <span class="comment">%                     part of the electrode, otherwise it is part of a</span>
0061 <span class="comment">%                     body. (false)</span>
0062 <span class="comment">%</span>
0063 <span class="comment">% half_space          A half-space is described by the following subfields:</span>
0064 <span class="comment">%                     point ([0; 0; 0]), outward_normal_vector ([0; 0; 1]),</span>
0065 <span class="comment">%                     complement_flag (false).</span>
0066 <span class="comment">%</span>
0067 <span class="comment">% intersection:       This fields indicates to perform the intersection of</span>
0068 <span class="comment">%                     all subfields. Subfields: complement_flag (false).</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% keep_material_flag: This flag can be used only for electrode geometry</span>
0071 <span class="comment">%                     descriptions to indicate that the associated</span>
0072 <span class="comment">%                     electrode material should be kept in the final mesh.</span>
0073 <span class="comment">%                     It can only be defined at the top level of each</span>
0074 <span class="comment">%                     geometry description. If true, it means that the</span>
0075 <span class="comment">%                     volume of the electrode is meshed. Volume elements</span>
0076 <span class="comment">%                     that are part of the mesh are indicated in mat_idx</span>
0077 <span class="comment">%                     output argument. (false)</span>
0078 <span class="comment">%</span>
0079 <span class="comment">% max_edge_length:    This parameter is used to adjust the maximum size of</span>
0080 <span class="comment">%                     the element composing the mesh. It can only be used</span>
0081 <span class="comment">%                     at the top level of each geometry description. (inf)</span>
0082 <span class="comment">%</span>
0083 <span class="comment">% name:               This parameter is used to name the geometry</span>
0084 <span class="comment">%                     description.</span>
0085 <span class="comment">%</span>
0086 <span class="comment">% ortho_brick:        An ortho-brick is described by the following</span>
0087 <span class="comment">%                     subfields: opposite_corner_a ([0; 0; 0]),</span>
0088 <span class="comment">%                     opposite_corner_b ([1; 1; 1]), complement_flag</span>
0089 <span class="comment">%                     (false).</span>
0090 <span class="comment">%</span>
0091 <span class="comment">% parallelepiped:     A parallelepiped is described by the following</span>
0092 <span class="comment">%                     subfields: vertex ([0; 0; 0]), vector_a ([1; 0; 0]),</span>
0093 <span class="comment">%                     vector_b ([0; 1; 0]), vector_c ([0; 0; 1]),</span>
0094 <span class="comment">%                     complement_flag (false).</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% point:              This parameter describes a point. It can only be used</span>
0097 <span class="comment">%                     at the top level of an electrode geometry</span>
0098 <span class="comment">%                     description. It must be the only field in the</span>
0099 <span class="comment">%                     structure. ([])</span>
0100 <span class="comment">%</span>
0101 <span class="comment">% sphere:             A sphere is described with the following subfields:</span>
0102 <span class="comment">%                     center ([0; 0; 0]), radius (1), complement_flag</span>
0103 <span class="comment">%                     (false).</span>
0104 <span class="comment">%</span>
0105 <span class="comment">% union:              This will perform the union of all its subfields.</span>
0106 <span class="comment">%                     There is an implicit union operator at the top level</span>
0107 <span class="comment">%                     of the geometry structure. Subfields: complement_flag</span>
0108 <span class="comment">%                     (false)</span>
0109 <span class="comment">%</span>
0110 <span class="comment">% OUTPUT:</span>
0111 <span class="comment">%  fmdl               - EIDORS forward model object.</span>
0112 <span class="comment">%</span>
0113 <span class="comment">%  mat_idx            - Vector indicating for each mesh element the indices</span>
0114 <span class="comment">%                       of materials corresponding as separately defined</span>
0115 <span class="comment">%                       by input argument body_geometry.</span>
0116 <span class="comment">%</span>
0117 <span class="comment">% USAGE EXAMPLES:</span>
0118 <span class="comment">% % 3D cylinder with radius 1. One plane of 16 electrodes with radius 0.1</span>
0119 <span class="comment">%   body_geometry.cylinder = struct;</span>
0120 <span class="comment">%   n_elect = 16;</span>
0121 <span class="comment">%   theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];</span>
0122 <span class="comment">%   for i = 1:n_elect</span>
0123 <span class="comment">%     electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];</span>
0124 <span class="comment">%     electrode_geometry{i}.sphere.radius = 0.1;</span>
0125 <span class="comment">%   end</span>
0126 <span class="comment">%   fmdl = ng_mk_geometric_models(body_geometry, electrode_geometry);</span>
0127 
0128 <span class="comment">% (C) Herve Gagnon, 2015. Licenced under GPL v2 or v3</span>
0129 <span class="comment">% $Id: ng_mk_geometric_models.m 4811 2015-03-29 12:12:42Z aadler $</span>
0130 
0131 <span class="comment">% Check if function is called in UNIT_TEST mode.</span>
0132 <span class="keyword">if</span> (ischar(body_geometry) &amp;&amp; strcmp(body_geometry, <span class="string">'UNIT_TEST'</span>))
0133     <a href="#_sub24" class="code" title="subfunction do_unit_test">do_unit_test</a>; 
0134     <span class="keyword">return</span>; 
0135 <span class="keyword">end</span>
0136 
0137 <span class="comment">% Validate function parameters.</span>
0138 <span class="keyword">if</span> (isempty(body_geometry) || ~isstruct(body_geometry) &amp;&amp; ~iscell(body_geometry))
0139    error(<span class="string">'Parameter body_geometry must be a structure or a cell.'</span>);
0140 <span class="keyword">end</span>
0141 
0142 <span class="comment">% Check if parameter electrode_geometry is specified.</span>
0143 <span class="keyword">if</span> (nargin &lt; 2 || isempty(electrode_geometry))
0144     electrode_geometry = {};
0145 <span class="keyword">end</span>
0146 
0147 <span class="keyword">if</span> (~isstruct(electrode_geometry) &amp;&amp; ~iscell(electrode_geometry))
0148    error(<span class="string">'Parameter electrode_geometry must be a structure or a cell.'</span>);
0149 <span class="keyword">end</span>
0150 
0151 <span class="comment">% If parameters are not of cell type, convert them to cell.</span>
0152 <span class="keyword">if</span> (~iscell(body_geometry))
0153     body_geometry = {body_geometry};
0154 <span class="keyword">end</span>
0155 
0156 <span class="keyword">if</span> (~iscell(electrode_geometry))
0157     electrode_geometry = {electrode_geometry};
0158 <span class="keyword">end</span>
0159 
0160 <span class="comment">% Check if result is already in cache. Otherwise, compute and store in cache.</span>
0161 cache_obj = {body_geometry, electrode_geometry};
0162 
0163 fmdl_mat_idx = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, cache_obj, <span class="string">'ng_mk_geometric_models'</span>);
0164 
0165 <span class="keyword">if</span> (isempty(fmdl_mat_idx))
0166    fmdl_mat_idx = <a href="#_sub1" class="code" title="subfunction [fmdl_mat_idx] = mk_geometric_models(body_geometry, electrode_geometry)">mk_geometric_models</a>(body_geometry, electrode_geometry);
0167    <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, cache_obj, <span class="string">'ng_mk_geometric_models'</span>, fmdl_mat_idx);
0168 <span class="keyword">end</span>
0169 
0170 <span class="comment">% Reformat output arguments.</span>
0171 fmdl    = fmdl_mat_idx{1};
0172 mat_idx = fmdl_mat_idx{2};
0173 
0174 <a name="_sub1" href="#_subfunctions" class="code">function [fmdl_mat_idx] = mk_geometric_models(body_geometry, electrode_geometry)     </a>
0175     <span class="comment">% Find number of subdomains</span>
0176     n_body      = numel(body_geometry);
0177     n_electrode = numel(electrode_geometry);
0178 
0179     <span class="comment">% Allocate cell memory.</span>
0180     body_solid_code       = cell(size(body_geometry));
0181     body_extra_code       = cell(size(body_geometry));
0182     body_extra_param      = cell(size(body_geometry));
0183     electrode_solid_code  = cell(size(electrode_geometry));
0184     electrode_extra_code  = cell(size(electrode_geometry));
0185     electrode_extra_param = cell(size(electrode_geometry));
0186     
0187     <span class="comment">% Parse geometry for each body subdomain.</span>
0188     <span class="keyword">for</span> i = 1:n_body
0189         <span class="keyword">if</span> (isfield(body_geometry{i}, <span class="string">'point'</span>))
0190             error(<span class="string">'Field name &quot;point&quot; is not allowed for body geometry.'</span>);
0191         <span class="keyword">end</span>
0192         <span class="keyword">if</span> (isfield(body_geometry{i}, <span class="string">'enter_body_flag'</span>))
0193             error(<span class="string">'Field name &quot;enter_body_flag&quot; is not allowed for body geometry.'</span>);
0194         <span class="keyword">end</span>
0195         <span class="keyword">if</span> (isfield(body_geometry{i}, <span class="string">'keep_material_flag'</span>))
0196             error(<span class="string">'Field name &quot;keep_material_flag&quot; is not allowed for body geometry.'</span>);
0197         <span class="keyword">end</span>
0198         [body_solid_code{i} body_extra_code{i} body_extra_param{i}] = <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(body_geometry{i});  
0199     <span class="keyword">end</span>
0200     
0201     <span class="comment">% Parse geometry for each body subdomain.</span>
0202     <span class="keyword">for</span> i = 1:n_electrode
0203         [electrode_extra_code{i} electrode_extra_param{i}] = <a href="#_sub8" class="code" title="subfunction [extra_code extra_param] = parse_geometry_point(geometry)">parse_geometry_point</a>(electrode_geometry{i});
0204         <span class="keyword">if</span> (isempty(electrode_extra_param{i}.point))
0205             [electrode_solid_code{i} electrode_extra_code{i} electrode_extra_param{i}] = <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(electrode_geometry{i}); 
0206         <span class="keyword">end</span>
0207     <span class="keyword">end</span>
0208 
0209     <span class="comment">% Define temporary unique filenames.</span>
0210     fn_prefix = tempname;
0211     geo_fn    = [fn_prefix, <span class="string">'.geo'</span>];
0212     vol_fn    = [fn_prefix, <span class="string">'.vol'</span>];
0213    
0214      <span class="comment">% Add body names if unspecified.</span>
0215     <span class="keyword">for</span> i = 1:numel(body_solid_code)
0216         <span class="keyword">if</span> (isempty(body_extra_param{i}.name))
0217             body_extra_param{i}.name = sprintf(<span class="string">'body%04d'</span>, i);
0218         <span class="keyword">end</span>
0219     <span class="keyword">end</span>
0220     
0221     <span class="comment">% Add electrode names if unspecified.</span>
0222     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
0223         <span class="keyword">if</span> (isempty(electrode_extra_param{i}.name))
0224             electrode_extra_param{i}.name = sprintf(<span class="string">'electrode%04d'</span>, i);
0225         <span class="keyword">end</span>
0226     <span class="keyword">end</span>
0227 
0228     <span class="comment">% Write geo file for netgen.</span>
0229     <a href="#_sub20" class="code" title="subfunction write_geo_file(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param)">write_geo_file</a>(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param);
0230    
0231     <span class="comment">% Call netgen.</span>
0232     <a href="call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>(geo_fn, vol_fn);
0233  
0234     <span class="comment">% Read vol file generated by netgen.</span>
0235     fmdl_mat_idx{1} = <a href="#_sub22" class="code" title="subfunction fmdl = read_vol_file(vol_fn, electrode_extra_param)">read_vol_file</a>(vol_fn, electrode_extra_param);
0236     
0237     <span class="comment">% Delete temporary files.</span>
0238     <span class="keyword">if</span> ~<a href="../../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'ng_mk_geometric_models:keep_temp_files'</span>)
0239        delete(geo_fn);
0240        delete(vol_fn);
0241     <span class="keyword">end</span>
0242 
0243     <span class="comment">% Complete fmdl object.</span>
0244     fmdl_mat_idx{1} = <a href="#_sub23" class="code" title="subfunction fmdl = complete_fmdl(fmdl, electrode_extra_param)">complete_fmdl</a>(fmdl_mat_idx{1}, electrode_extra_param);
0245 
0246     <span class="comment">% Assign mat_idx value from fmdl.</span>
0247     fmdl_mat_idx{2} = fmdl_mat_idx{1}.mat_idx;
0248 
0249 <a name="_sub2" href="#_subfunctions" class="code">function radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)</a>
0250 
0251     radius = default_value;
0252     
0253     <span class="keyword">for</span> i = 1:n_structs
0254         value = struct(i).(field_name);
0255 
0256         <span class="keyword">if</span> (~isempty(value))
0257             <span class="keyword">if</span> (isscalar(value) &amp;&amp; isnumeric(value) &amp;&amp; isreal(value) &amp;&amp; value &gt; 0)
0258                 radius(i) = value;
0259             <span class="keyword">else</span> 
0260                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0261             <span class="keyword">end</span>
0262         <span class="keyword">end</span>
0263     <span class="keyword">end</span>
0264     
0265 <a name="_sub3" href="#_subfunctions" class="code">function point = assign_point(struct, n_structs, struct_name, field_name, default_value)</a>
0266         
0267     point = default_value;
0268     
0269     <span class="keyword">for</span> i = 1:n_structs
0270         value =  struct(i).(field_name);
0271 
0272         <span class="keyword">if</span> (~isempty(value))
0273             <span class="keyword">if</span> (numel(value) == 3 &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0274                 point(:, i) = value;
0275             <span class="keyword">else</span>
0276                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0277             <span class="keyword">end</span>
0278         <span class="keyword">end</span>
0279     <span class="keyword">end</span>
0280  
0281 <a name="_sub4" href="#_subfunctions" class="code">function point_list = assign_list_of_3D_points(struct, n_structs, struct_name, field_name, default_value)</a>
0282         
0283     point_list = cell(n_structs, 1);
0284     
0285     <span class="keyword">for</span> i = 1:n_structs
0286         
0287         point_list{i} = default_value;
0288         
0289         value = struct(i).(field_name);
0290 
0291         <span class="keyword">if</span> (~isempty(value))
0292             <span class="keyword">if</span> (size(value, 2) == 3 &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0293                 point_list{i} = value;
0294             <span class="keyword">else</span>
0295                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0296             <span class="keyword">end</span>
0297         <span class="keyword">end</span>
0298     <span class="keyword">end</span>
0299     
0300 <a name="_sub5" href="#_subfunctions" class="code">function segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)</a>
0301         
0302     segment_list = cell(n_structs, 1);
0303     
0304     <span class="keyword">for</span> i = 1:n_structs
0305         
0306         segment_list{i} = default_value;
0307         
0308         value = struct(i).(field_name);
0309 
0310         <span class="keyword">if</span> (~isempty(value))
0311             <span class="keyword">if</span> (size(value, 2) == 2 &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0312                 segment_list{i} = value;
0313             <span class="keyword">else</span>
0314                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0315             <span class="keyword">end</span>
0316         <span class="keyword">end</span>
0317     <span class="keyword">end</span> 
0318     
0319  <a name="_sub6" href="#_subfunctions" class="code">function segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)</a>
0320         
0321     segment_list = cell(n_structs, 1);
0322     
0323     <span class="keyword">for</span> i = 1:n_structs
0324         
0325         segment_list{i} = default_value;
0326         
0327         value = struct(i).(field_name);
0328 
0329         <span class="keyword">if</span> (~isempty(value))
0330             <span class="keyword">if</span> ((size(value, 2) == 2 || size(value, 2) == 3) &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0331                 segment_list{i} = value;
0332             <span class="keyword">else</span>
0333                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0334             <span class="keyword">end</span>
0335         <span class="keyword">end</span>
0336     <span class="keyword">end</span>    
0337     
0338 <a name="_sub7" href="#_subfunctions" class="code">function flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)</a>
0339 
0340     flag = default_value;
0341 
0342     <span class="keyword">for</span> i = 1:n_structs
0343         value = struct(i).(field_name);
0344  
0345         <span class="keyword">if</span> (~isempty(value))
0346             <span class="keyword">if</span> (isscalar(value) &amp;&amp; (islogical(value) || (isnumeric(value) &amp;&amp; <span class="keyword">...</span>
0347                                      isreal(value) &amp;&amp; (value == 0 || value == 1))))
0348                 flag(i) = value;
0349             <span class="keyword">else</span>
0350                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0351             <span class="keyword">end</span>
0352         <span class="keyword">end</span>
0353     <span class="keyword">end</span>
0354 
0355 <a name="_sub8" href="#_subfunctions" class="code">function [extra_code extra_param] = parse_geometry_point(geometry)</a>
0356 
0357     <span class="comment">% Initialize extra param values to default values.</span>
0358     extra_code                     = <span class="string">''</span>;
0359     extra_param.point              = [];
0360     extra_param.max_edge_length    = inf;
0361     extra_param.enter_body_flag    = false;
0362     extra_param.keep_material_flag = false;
0363     extra_param.name               = <span class="string">''</span>;
0364 
0365     <span class="comment">% Check if geometry is a point, return otherwise.</span>
0366     <span class="keyword">if</span> (isfield(geometry, <span class="string">'point'</span>))
0367         <span class="comment">% Check if a single point is defined.</span>
0368         <span class="keyword">if</span> (numel(geometry) ~= 1)
0369             error(<span class="string">'Field name &quot;point&quot; must define only a single point.'</span>);
0370         <span class="keyword">end</span>
0371         
0372         <span class="comment">% Get structure field names.</span>
0373         field_names = fieldnames(geometry);
0374         n_fields = numel(field_names);
0375         
0376         <span class="comment">% Check if it is the only field names.</span>
0377         <span class="keyword">if</span> (n_fields ~= 1)
0378             <span class="keyword">if</span> (isfield(geometry, <span class="string">'name'</span>))
0379                 extra_param.name = geometry.name;
0380             <span class="keyword">else</span>
0381                 error(<span class="string">'Field name &quot;point&quot; must be used as a single field.'</span>);
0382             <span class="keyword">end</span>
0383         <span class="keyword">end</span>
0384         
0385         <span class="comment">% Check point is 3D.</span>
0386         <span class="keyword">if</span> (numel(geometry.point) ~= 3)
0387             error(<span class="string">'geometry.point value is not valid.'</span>);
0388         <span class="keyword">end</span>
0389         
0390         <span class="comment">% Set returning values.</span>
0391         extra_param.point = geometry.point(:);
0392         
0393         extra_code = sprintf(<span class="string">'point(%g, %g, %g);\n'</span>, extra_param.point);
0394     <span class="keyword">end</span>
0395     
0396 <a name="_sub9" href="#_subfunctions" class="code">function [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)</a>
0397 
0398     <span class="comment">% Extra code is initialized empty;</span>
0399     extra_code = <span class="string">''</span>;
0400     
0401     <span class="comment">% Initialize extra param values to default values.</span>
0402     extra_param.max_edge_length     = inf;
0403     extra_param.enter_body_flag     = false;
0404     extra_param.keep_material_flag  = false;
0405     extra_param.name                = <span class="string">''</span>;
0406     
0407     <span class="comment">% If called from top_level, operators default to or.</span>
0408     <span class="keyword">if</span> (nargin == 1)
0409         top_level_flag = 1;
0410         field_operator_string = <span class="string">' or '</span>;
0411         element_operator_string = <span class="string">' or '</span>;
0412     <span class="keyword">else</span>
0413         top_level_flag = 0;
0414     <span class="keyword">end</span>
0415 
0416     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with (field: &quot;%s&quot;, element: &quot;%s&quot;).'</span>, field_operator_string, element_operator_string, 3);
0417     
0418     <span class="comment">% Validate that geometry is a non-empty structure.</span>
0419     <span class="keyword">if</span> (~isstruct(geometry) || isempty(geometry))
0420         error(<span class="string">'Parameter geometry must be a valid structure.'</span>);        
0421     <span class="keyword">else</span>
0422         <span class="comment">% Get number of geometries.</span>
0423         n_geometries = numel(geometry);
0424         
0425         <span class="comment">% Get structure field names.</span>
0426         field_names = fieldnames(geometry);
0427         n_fields = numel(field_names);
0428 
0429         <span class="comment">% Recursively parse all geometry fields.</span>
0430         geo_code = <span class="string">'('</span>;
0431         <span class="keyword">for</span> i = 1:n_geometries
0432             <span class="comment">% complement_flag field has to be processed first.</span>
0433             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'complement_flag'</span>) &amp;&amp; ~isempty(geometry(i).complement_flag) &amp;&amp; geometry(i).complement_flag)
0434                  geo_code = [geo_code <span class="string">'(not('</span>];
0435             <span class="keyword">else</span>
0436                  geo_code = [geo_code <span class="string">'('</span>];
0437             <span class="keyword">end</span>
0438             <span class="comment">% Process name field.</span>
0439             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'name'</span>))
0440                 <span class="keyword">if</span> (~top_level_flag)
0441                     error(<span class="string">'Field &quot;name&quot; can only be specified at the top level of the geometry description'</span>);
0442                 <span class="keyword">end</span>
0443                 extra_param.name = geometry(i).name;
0444 
0445                 <span class="keyword">if</span> (isempty(extra_param.name) || ~ischar(extra_param.name))
0446                     error(<span class="string">'name value is not valid.'</span>);
0447                 <span class="keyword">end</span>
0448             <span class="keyword">end</span>
0449            <span class="comment">% Process max_edge_length field.</span>
0450             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'max_edge_length'</span>))
0451                 <span class="keyword">if</span> (~top_level_flag)
0452                     error(<span class="string">'Field &quot;max_edge_length&quot; can only be specified at the top level of the geometry description'</span>);
0453                 <span class="keyword">end</span>
0454                 extra_param.max_edge_length = geometry(i).max_edge_length;
0455 
0456                 <span class="keyword">if</span> (isempty(extra_param.max_edge_length) || ~isscalar(extra_param.max_edge_length) || ~isnumeric(extra_param.max_edge_length) || ~isreal(extra_param.max_edge_length) || extra_param.max_edge_length &lt;= 0)
0457                     error(<span class="string">'max_edge_length value is not valid.'</span>);
0458                 <span class="keyword">end</span>
0459             <span class="keyword">end</span>
0460             <span class="comment">% Process enter_body_flag field.</span>
0461             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'enter_body_flag'</span>))
0462                 <span class="keyword">if</span> (~top_level_flag)
0463                     error(<span class="string">'Field &quot;enter_body_flag&quot; can only be specified at the top level of the geometry description'</span>);
0464                 <span class="keyword">end</span>
0465                 extra_param.enter_body_flag = geometry(i).enter_body_flag;
0466                 
0467                 <span class="keyword">if</span> (isempty(extra_param.enter_body_flag) || ~isscalar(extra_param.enter_body_flag) || (~islogical(extra_param.enter_body_flag) &amp;&amp; <span class="keyword">...</span>
0468                         (~isnumeric(extra_param.enter_body_flag) || ~isreal(extra_param.enter_body_flag) || (extra_param.enter_body_flag ~= 0 &amp;&amp; extra_param.enter_body_flag ~= 1))))
0469                     error(<span class="string">'Field &quot;enter_body_flag value&quot; is not valid.'</span>);
0470                 <span class="keyword">end</span>
0471             <span class="keyword">end</span>
0472             <span class="comment">% Process keep_material_flag field.</span>
0473             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'keep_material_flag'</span>))
0474                 <span class="keyword">if</span> (~top_level_flag)
0475                     error(<span class="string">'Field &quot;keep_material_flag&quot; can only be specified at the top level of the geometry description'</span>);
0476                 <span class="keyword">end</span>
0477                 extra_param.keep_material_flag = geometry(i).keep_material_flag;
0478                 
0479                 <span class="keyword">if</span> (isempty(extra_param.keep_material_flag) || ~isscalar(extra_param.keep_material_flag) || (~islogical(extra_param.keep_material_flag) &amp;&amp; <span class="keyword">...</span>
0480                         (~isnumeric(extra_param.keep_material_flag) || ~isreal(extra_param.keep_material_flag) || (extra_param.keep_material_flag ~= 0 &amp;&amp; extra_param.keep_material_flag ~= 1))))
0481                     error(<span class="string">'Field &quot;keep_material_flag&quot; value is not valid.'</span>);
0482                 <span class="keyword">end</span>
0483             <span class="keyword">end</span>  
0484             first_internal_term = 1;
0485             <span class="keyword">for</span> j = 1:n_fields
0486                 <span class="keyword">if</span> (~isempty(geometry(i).(field_names{j})) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'complement_flag'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'name'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'max_edge_length'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'keep_material_flag'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'enter_body_flag'</span>))
0487                     <span class="keyword">if</span> (first_internal_term)
0488                         first_internal_term = 0;
0489                     <span class="keyword">else</span>
0490                         geo_code = [geo_code field_operator_string];
0491                     <span class="keyword">end</span>
0492                     <span class="keyword">switch</span> (field_names{j})
0493                         <span class="keyword">case</span> <span class="string">'body_of_extrusion'</span>
0494                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0495                                         <a href="#_sub10" class="code" title="subfunction [geo_code extra_code] = parse_geometry_body_of_extrusion(body_of_extrusion, operator_string)">parse_geometry_body_of_extrusion</a>(geometry(i).(field_names{j}), field_operator_string);
0496                             geo_code   = [geo_code geo_code_temp];        
0497                             extra_code = [extra_code extra_code_temp];
0498                         <span class="keyword">case</span> <span class="string">'body_of_revolution'</span>
0499                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0500                                         <a href="#_sub11" class="code" title="subfunction [geo_code extra_code] = parse_geometry_body_of_revolution(body_of_revolution, operator_string)">parse_geometry_body_of_revolution</a>(geometry(i).(field_names{j}), field_operator_string);
0501                             geo_code   = [geo_code geo_code_temp];        
0502                             extra_code = [extra_code extra_code_temp];
0503                         <span class="keyword">case</span> <span class="string">'cone'</span>
0504                             geo_code = [geo_code <span class="keyword">...</span>
0505                                         <a href="#_sub12" class="code" title="subfunction geo_code = parse_geometry_cone(cone, operator_string)">parse_geometry_cone</a>(geometry(i).(field_names{j}), field_operator_string)];
0506                         <span class="keyword">case</span> <span class="string">'cylinder'</span>
0507                             geo_code = [geo_code <span class="keyword">...</span>
0508                                         <a href="#_sub13" class="code" title="subfunction geo_code = parse_geometry_cylinder(cylinder, operator_string)">parse_geometry_cylinder</a>(geometry(i).(field_names{j}), field_operator_string)];
0509                         <span class="keyword">case</span> <span class="string">'ellipsoid'</span>
0510                             geo_code = [geo_code <span class="keyword">...</span>
0511                                         <a href="#_sub14" class="code" title="subfunction geo_code = parse_geometry_ellipsoid(ellipsoid, operator_string)">parse_geometry_ellipsoid</a>(geometry(i).(field_names{j}), field_operator_string)];
0512                         <span class="keyword">case</span> <span class="string">'elliptic_cylinder'</span>
0513                             geo_code = [geo_code <span class="keyword">...</span>
0514                                         <a href="#_sub15" class="code" title="subfunction geo_code = parse_geometry_elliptic_cylinder(elliptic_cylinder, operator_string)">parse_geometry_elliptic_cylinder</a>(geometry(i).(field_names{j}), field_operator_string)];
0515                         <span class="keyword">case</span> <span class="string">'half_space'</span>
0516                             geo_code = [geo_code <span class="keyword">...</span>
0517                                         <a href="#_sub16" class="code" title="subfunction geo_code = parse_geometry_half_space(half_space, operator_string)">parse_geometry_half_space</a>(geometry(i).(field_names{j}), field_operator_string)];    
0518                         <span class="keyword">case</span> <span class="string">'ortho_brick'</span>
0519                             geo_code = [geo_code <span class="keyword">...</span>
0520                                         <a href="#_sub17" class="code" title="subfunction geo_code = parse_geometry_ortho_brick(ortho_brick, operator_string)">parse_geometry_ortho_brick</a>(geometry(i).(field_names{j}), field_operator_string)];
0521                         <span class="keyword">case</span> <span class="string">'parallelepiped'</span>
0522                             geo_code = [geo_code <span class="keyword">...</span>
0523                                         <a href="#_sub18" class="code" title="subfunction geo_code = parse_geometry_parallelepiped(parallelepiped, operator_string)">parse_geometry_parallelepiped</a>(geometry(i).(field_names{j}), field_operator_string)];       
0524                         <span class="keyword">case</span> <span class="string">'sphere'</span>
0525                             geo_code = [geo_code <span class="keyword">...</span>
0526                                         <a href="#_sub19" class="code" title="subfunction geo_code = parse_geometry_sphere(sphere, operator_string)">parse_geometry_sphere</a>(geometry(i).(field_names{j}), field_operator_string)];
0527                         <span class="keyword">case</span> <span class="string">'intersection'</span>
0528                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0529                                         <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(geometry(i).(field_names{j}), <span class="string">' and '</span>, field_operator_string);
0530                             geo_code   = [geo_code geo_code_temp];        
0531                             extra_code = [extra_code extra_code_temp];
0532                         <span class="keyword">case</span> <span class="string">'union'</span>
0533                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0534                                         <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(geometry(i).(field_names{j}), <span class="string">' or '</span>, field_operator_string);
0535                             geo_code   = [geo_code geo_code_temp];        
0536                             extra_code = [extra_code extra_code_temp];
0537                         <span class="keyword">otherwise</span>
0538                             error([<span class="string">'Field name &quot;%s&quot; is not valid for a geometry.\nAvailable field names for a geometry are: '</span><span class="keyword">...</span>
0539                                    <span class="string">'complement_flag, intersection, union, body_of_extrusion, body_of_revolution, cone, cylinder, ellipsoid, elliptic_cylinder, half_space, ortho_brick, parallelepiped, point, sphere, keep_material_flag, enter_body_flag, name, and max_edge_length.'</span>], field_names{j});
0540                     <span class="keyword">end</span>
0541                 <span class="keyword">end</span>
0542             <span class="keyword">end</span>
0543             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'complement_flag'</span>) &amp;&amp; ~isempty(geometry(i).complement_flag) &amp;&amp; geometry(i).complement_flag)
0544                 geo_code = [geo_code <span class="string">'))'</span>];
0545             <span class="keyword">else</span>
0546                 geo_code = [geo_code <span class="string">')'</span>];  
0547             <span class="keyword">end</span>
0548            
0549             <span class="keyword">if</span> (i &lt; n_geometries)
0550                 geo_code = [geo_code element_operator_string];         
0551             <span class="keyword">end</span>           
0552         <span class="keyword">end</span>
0553         geo_code = [geo_code <span class="string">')'</span>];  
0554     <span class="keyword">end</span>
0555     
0556     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ returned with (field: &quot;%s&quot;, element: &quot;%s&quot;).'</span>, field_operator_string, element_operator_string, 3);
0557  
0558 <a name="_sub10" href="#_subfunctions" class="code">function [geo_code extra_code] = parse_geometry_body_of_extrusion(body_of_extrusion, operator_string)</a>
0559 
0560     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
0561 
0562     <span class="keyword">if</span> (~isstruct(body_of_extrusion) || isempty(body_of_extrusion))
0563         error(<span class="string">'Parameter body_of_extrusion must be a valid structure.'</span>);        
0564     <span class="keyword">else</span>
0565         <span class="comment">% Get number of body_of_extrusion.</span>
0566         n_body_of_extrusions = numel(body_of_extrusion);
0567         
0568         <span class="comment">% Get structure field names.</span>
0569         field_names = fieldnames(body_of_extrusion);
0570         n_fields = numel(field_names);
0571         
0572         <span class="comment">% Assign default values.</span>
0573         vector_d            = [0; 1; 0]*ones(1, n_body_of_extrusions);
0574         profile_points{1}   = [1 1; 1 2; 2 2; 2 1];
0575         profile_segments{1} = [1 2; 2 3; 3 4; 4 1];
0576         path_points{1}      = [0 0 0; 0 0 1; 0 0 2; 0 0 3];
0577         path_segments{1}    = [1 2; 2 3; 3 4];
0578         complement_flag     = false(1, n_body_of_extrusions);
0579         
0580         <span class="comment">% Parse all structure fields.</span>
0581         <span class="keyword">for</span> i = 1:n_fields
0582             <span class="keyword">switch</span> (field_names{i})
0583                 <span class="keyword">case</span> <span class="string">'vector_d'</span>
0584                     vector_d = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, vector_d);
0585                 <span class="keyword">case</span> <span class="string">'profile_points'</span>
0586                     profile_points = <a href="#_sub5" class="code" title="subfunction segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, profile_points{1});
0587                 <span class="keyword">case</span> <span class="string">'profile_segments'</span>
0588                     profile_segments = <a href="#_sub6" class="code" title="subfunction segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_or_3D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, profile_segments{1});
0589                 <span class="keyword">case</span> <span class="string">'path_points'</span>
0590                     path_points = <a href="#_sub4" class="code" title="subfunction point_list = assign_list_of_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_3D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, path_points{1});
0591                 <span class="keyword">case</span> <span class="string">'path_segments'</span>
0592                     path_segments = <a href="#_sub6" class="code" title="subfunction segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_or_3D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, path_segments{1});
0593                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0594                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, complement_flag);
0595                 <span class="keyword">otherwise</span>
0596                     error([<span class="string">'Field name &quot;%s&quot; is not allowed for a body_of_extrusion!\nAllowed field names for a body_of_extrusion are: '</span> <span class="keyword">...</span>
0597                            <span class="string">'path_points, path_segments, profile_points, profile_segments, vector_d, and complement_flag.'</span>], field_names{i});
0598             <span class="keyword">end</span>
0599         <span class="keyword">end</span>
0600         
0601         <span class="comment">% Start geo code with an opening parenthesis.</span>
0602         geo_code = <span class="string">'('</span>;
0603         extra_code = <span class="string">''</span>;
0604         
0605         <span class="comment">% Add geo code for each body_of_extrusion.</span>
0606         <span class="keyword">for</span> i = 1:n_body_of_extrusions
0607             
0608             <span class="keyword">for</span> j = 1:size(path_segments{i}, 1)
0609                 <span class="keyword">if</span> (dot(vector_d(:,i), path_points{i}(path_segments{i}(j, 1), :) - path_points{i}(path_segments{i}(j, end), :)) ~= 0)
0610                     error(<span class="string">'vector_d and path must be perpendicular for a body of extrusion.'</span>);
0611                 <span class="keyword">end</span>
0612             <span class="keyword">end</span>
0613             
0614             n_points = size(profile_points{i}, 1);
0615             n_segments = size(profile_segments{i}, 1);
0616             
0617             <span class="keyword">if</span> (size(profile_segments{i}, 2) == 2)
0618                 extra_code = [extra_code sprintf(<span class="string">'curve2d Extrusion2DProfileCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0619                                          sprintf(<span class="string">'%g, %g ; '</span>, profile_points{i}') <span class="keyword">...</span>
0620                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0621                                          sprintf(<span class="string">'; 2, %g, %g '</span>, profile_segments{i}') <span class="keyword">...</span>
0622                                          sprintf(<span class="string">');\n\n'</span>)];
0623             <span class="keyword">else</span>
0624                 extra_code = [extra_code sprintf(<span class="string">'curve2d Extrusion2DProfileCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0625                                          sprintf(<span class="string">'%g, %g ; '</span>, profile_points{i}') <span class="keyword">...</span>
0626                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0627                                          sprintf(<span class="string">'; 3, %g, %g, %g '</span>, profile_segments{i}') <span class="keyword">...</span>
0628                                          sprintf(<span class="string">');\n\n'</span>)];
0629             <span class="keyword">end</span>
0630   
0631             n_points = size(path_points{i}, 1);
0632             n_segments = size(path_segments{i}, 1);
0633             
0634             <span class="keyword">if</span> (size(path_segments{i}, 2) == 2)
0635                 extra_code = [extra_code sprintf(<span class="string">'curve3d Extrusion3DPathCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0636                                          sprintf(<span class="string">'%g, %g, %g ; '</span>, path_points{i}') <span class="keyword">...</span>
0637                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0638                                          sprintf(<span class="string">'; 2, %g, %g '</span>, path_segments{i}') <span class="keyword">...</span>
0639                                          sprintf(<span class="string">');\n\n'</span>)];
0640             <span class="keyword">else</span>
0641                  extra_code = [extra_code sprintf(<span class="string">'curve3d Extrusion3DPathCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0642                                          sprintf(<span class="string">'%g, %g, %g ; '</span>, path_points{i}') <span class="keyword">...</span>
0643                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0644                                          sprintf(<span class="string">'; 3, %g, %g, %g '</span>, path_segments{i}') <span class="keyword">...</span>
0645                                          sprintf(<span class="string">');\n\n'</span>)];               
0646             <span class="keyword">end</span>
0647                                        
0648             <span class="keyword">if</span> (complement_flag(i))
0649                 geo_code = [geo_code <span class="string">'not '</span>];
0650             <span class="keyword">end</span>
0651             
0652             <span class="comment">% Check if path is closed.</span>
0653             <span class="keyword">if</span> (path_segments{i}(end) == path_segments{i}(1))
0654                 geo_code = [geo_code sprintf(<span class="string">'extrusion(Extrusion3DPathCurve%d ; Extrusion2DProfileCurve%d ; %g, %g, %g)'</span>, i, i, vector_d(:,i))];
0655             <span class="keyword">else</span>
0656                 <span class="comment">%error('Unclosed path are not yet supported for body of extrusion!');</span>
0657                 <span class="comment">%for j = 1: [1 1; 1 2; 2 2; 2 1];</span>
0658                 <span class="comment">%polyhedron1 = 'polyhedron(-1, 1, 0; -1, 2, 0; -2, 2, 0; -2, 1, 0; -1.5, 1.5, 0; -1.5, 1.5, 1 ;; 2, 1, 5; 3, 2, 5; 4, 3, 5; 1, 4, 5; 1, 2, 6; 2, 3, 6; 3, 4, 6; 4, 1, 6)';</span>
0659                 <span class="comment">%polyhedron2 = 'polyhedron(-1, 1, 3; -1, 2, 3; -2, 2, 3; -2, 1, 3; -1.5, 1.5, 3; -1.5, 1.5, 2 ;; 1, 2, 5; 2, 3, 5; 3, 4, 5; 4, 1, 5; 2, 1, 6; 3, 2, 6; 4, 3, 6; 1, 4, 6)';</span>
0660                 <span class="comment">%polyhedron1 = 'plane(0, 0, 3; 0, 0, 1)';</span>
0661                 <span class="comment">%polyhedron2 = 'plane(0, 0, 0; 0, 0, -1)';</span>
0662                 first_point  = path_points{i}(path_segments{i}(1, 1), :);
0663                 first_vector = first_point - path_points{i}(path_segments{i}(1, end), :);
0664                 last_point   = path_points{i}(path_segments{i}(<span class="keyword">end</span>, end), :);
0665                 last_vector  = last_point - path_points{i}(path_segments{i}(<span class="keyword">end</span>, 1), :);
0666                 geo_code = [geo_code sprintf(<span class="string">'(extrusion(Extrusion3DPathCurve%d ; Extrusion2DProfileCurve%d ; %g, %g, %g) and plane(%g, %g, %g; %g, %g, %g) and plane(%g, %g, %g; %g, %g, %g))'</span>, <span class="keyword">...</span>
0667                             i, i, vector_d(:,i), first_point, first_vector, last_point, last_vector)];
0668                 <span class="comment">%geo_code = [geo_code sprintf('(%s or %s)', polyhedron1, polyhedron2)];</span>
0669             <span class="keyword">end</span>
0670 
0671             <span class="keyword">if</span> (i &lt; n_body_of_extrusions)
0672                 geo_code = [geo_code operator_string];
0673             <span class="keyword">else</span>
0674                 geo_code = [geo_code <span class="string">')'</span>];             
0675             <span class="keyword">end</span>
0676         <span class="keyword">end</span>
0677     <span class="keyword">end</span>
0678     
0679     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
0680 
0681 <a name="_sub11" href="#_subfunctions" class="code">function [geo_code extra_code] = parse_geometry_body_of_revolution(body_of_revolution, operator_string)</a>
0682 
0683     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
0684 
0685     <span class="keyword">if</span> (~isstruct(body_of_revolution) || isempty(body_of_revolution))
0686         error(<span class="string">'Parameter body_of_revolution must be a valid structure.'</span>);        
0687     <span class="keyword">else</span>
0688         <span class="comment">% Get number of body_of_revolution.</span>
0689         n_body_of_revolutions = numel(body_of_revolution);
0690         
0691         <span class="comment">% Get structure field names.</span>
0692         field_names = fieldnames(body_of_revolution);
0693         n_fields = numel(field_names);
0694         
0695         <span class="comment">% Assign default values.</span>
0696         axis_point_a   = [0;0;0]*ones(1, n_body_of_revolutions);
0697         axis_point_b   = [0;0;1]*ones(1, n_body_of_revolutions);
0698         points{1}      = [1 1; 1 2; 2 2; 2 1];
0699         segments{1}    = [1 2; 2 3; 3 4; 4 1];
0700         complement_flag = false(1, n_body_of_revolutions);
0701         
0702         <span class="comment">% Parse all structure fields.</span>
0703         <span class="keyword">for</span> i = 1:n_fields
0704             <span class="keyword">switch</span> (field_names{i})
0705                 <span class="keyword">case</span> <span class="string">'axis_point_a'</span>
0706                     axis_point_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, axis_point_a);
0707                 <span class="keyword">case</span> <span class="string">'axis_point_b'</span>
0708                     axis_point_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, axis_point_b);
0709                 <span class="keyword">case</span> <span class="string">'points'</span>
0710                     points = <a href="#_sub5" class="code" title="subfunction segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_points</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, points{1});
0711                 <span class="keyword">case</span> <span class="string">'segments'</span>
0712                     segments = <a href="#_sub6" class="code" title="subfunction segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_or_3D_points</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, segments{1});
0713                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0714                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, complement_flag);
0715                 <span class="keyword">otherwise</span>
0716                     error([<span class="string">'Field name ''%s'' is not valid for a body_of_revolution.\Available field names for a body_of_revolution are: '</span> <span class="keyword">...</span>
0717                            <span class="string">'axis_point_a, axis_point_b, points, segments, and complement_flag.'</span>], field_names{i});
0718             <span class="keyword">end</span>
0719         <span class="keyword">end</span>
0720         
0721         <span class="comment">% Start geo code with an opening parenthesis.</span>
0722         geo_code = <span class="string">'('</span>;
0723         extra_code = <span class="string">''</span>;
0724         
0725         <span class="comment">% Add geo code for each body_of_revolution.</span>
0726         <span class="keyword">for</span> i = 1:n_body_of_revolutions
0727             
0728             n_points = size(points{i}, 1);
0729             n_segments = size(segments{i}, 1);
0730             
0731             <span class="keyword">if</span> (size(segments{i}, 2) == 2)
0732                 extra_code = [extra_code sprintf(<span class="string">'curve2d Revolution2DCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0733                                                sprintf(<span class="string">'%g, %g ; '</span>, points{i}') <span class="keyword">...</span>
0734                                                sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0735                                                sprintf(<span class="string">'; 2, %g, %g '</span>, segments{i}') <span class="keyword">...</span>
0736                                                sprintf(<span class="string">');\n\n'</span>)];
0737             <span class="keyword">else</span>
0738                 extra_code = [extra_code sprintf(<span class="string">'curve2d Revolution2DCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0739                                                sprintf(<span class="string">'%g, %g ; '</span>, points{i}') <span class="keyword">...</span>
0740                                                sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0741                                                sprintf(<span class="string">'; 3, %g, %g, %g '</span>, segments{i}') <span class="keyword">...</span>
0742                                                sprintf(<span class="string">');\n\n'</span>)];
0743             <span class="keyword">end</span>
0744             
0745             <span class="keyword">if</span> (complement_flag(i))
0746                 geo_code = [geo_code <span class="string">'not '</span>];
0747             <span class="keyword">end</span>
0748             
0749             geo_code = [geo_code sprintf(<span class="string">'revolution(%g, %g, %g ; %g, %g, %g ; Revolution2DCurve%d)'</span>, <span class="keyword">...</span>
0750                         axis_point_a(:, i), axis_point_b(:, i), i)];
0751 
0752             <span class="keyword">if</span> (i &lt; n_body_of_revolutions)
0753                 geo_code = [geo_code operator_string];
0754             <span class="keyword">else</span>
0755                 geo_code = [geo_code <span class="string">')'</span>];             
0756             <span class="keyword">end</span>
0757         <span class="keyword">end</span>
0758     <span class="keyword">end</span>
0759     
0760     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
0761     
0762 <a name="_sub12" href="#_subfunctions" class="code">function geo_code = parse_geometry_cone(cone, operator_string)</a>
0763 
0764     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
0765 
0766     <span class="keyword">if</span> (~isstruct(cone) || isempty(cone))
0767         error(<span class="string">'Parameter cone must be a valid structure.'</span>);        
0768     <span class="keyword">else</span>
0769         <span class="comment">% Get number of cones.</span>
0770         n_cones = numel(cone);
0771         
0772         <span class="comment">% Get structure field names.</span>
0773         field_names = fieldnames(cone);
0774         n_fields = numel(field_names);
0775         
0776         <span class="comment">% Assign default values.</span>
0777         top_radius      = 0.5*ones(1, n_cones);
0778         bottom_radius   = ones(1, n_cones);
0779         top_center      = [0;0;1]*ones(1, n_cones);
0780         bottom_center   = [0;0;0]*ones(1, n_cones);
0781         complement_flag = false(1, n_cones);
0782         
0783         <span class="comment">% Parse all structure fields.</span>
0784         <span class="keyword">for</span> i = 1:n_fields
0785             <span class="keyword">switch</span> (field_names{i})
0786                 <span class="keyword">case</span> <span class="string">'top_radius'</span>
0787                     top_radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, top_radius);
0788                 <span class="keyword">case</span> <span class="string">'bottom_radius'</span>
0789                     bottom_radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, bottom_radius);
0790                 <span class="keyword">case</span> {<span class="string">'top_center'</span>, <span class="string">'top_centre'</span>}
0791                     top_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, top_center);
0792                 <span class="keyword">case</span> {<span class="string">'bottom_center'</span>, <span class="string">'bottom_centre'</span>}
0793                     bottom_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, bottom_center);
0794                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0795                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, complement_flag);
0796                 <span class="keyword">otherwise</span>
0797                     error([<span class="string">'Field name ''%s'' is not valid for a cone.\Available field names for a cone are: '</span> <span class="keyword">...</span>
0798                            <span class="string">'bottom_center, bottom_radius, top_center, top_radius, and complement_flag.'</span>], field_names{i});
0799             <span class="keyword">end</span>
0800         <span class="keyword">end</span>
0801         
0802         <span class="comment">% Start geo code with an opening parenthesis.</span>
0803         geo_code = <span class="string">'('</span>;
0804 
0805         <span class="comment">% Add geo code for each cone.</span>
0806         <span class="keyword">for</span> i = 1:n_cones
0807             <span class="keyword">if</span> (complement_flag(i))
0808                 geo_code = [geo_code <span class="string">'not '</span>];
0809             <span class="keyword">end</span>
0810             
0811             n_vector = top_center(:,i) - bottom_center(:,i); 
0812             
0813             geo_code = [geo_code sprintf(<span class="string">'(cone(%g, %g, %g ; %g ; %g, %g, %g ; %g) and plane(%g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g))'</span>, <span class="keyword">...</span>
0814                         bottom_center(:,i), bottom_radius(i), top_center(:,i), top_radius(i), bottom_center(:,i), -n_vector, top_center(:,i), n_vector)];
0815 
0816             <span class="keyword">if</span> (i &lt; n_cones)
0817                 geo_code = [geo_code operator_string];
0818             <span class="keyword">else</span>
0819                 geo_code = [geo_code <span class="string">')'</span>];             
0820             <span class="keyword">end</span>
0821         <span class="keyword">end</span>
0822     <span class="keyword">end</span>
0823     
0824     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
0825     
0826 <a name="_sub13" href="#_subfunctions" class="code">function geo_code = parse_geometry_cylinder(cylinder, operator_string)</a>
0827 
0828     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
0829 
0830     <span class="keyword">if</span> (~isstruct(cylinder) || isempty(cylinder))
0831         error(<span class="string">'Parameter cylinder must be a valid structure.'</span>);        
0832     <span class="keyword">else</span>
0833         <span class="comment">% Get number of cylinders.</span>
0834         n_cylinders = numel(cylinder);
0835         
0836         <span class="comment">% Get structure field names.</span>
0837         field_names = fieldnames(cylinder);
0838         n_fields = numel(field_names);
0839         
0840         <span class="comment">% Assign default values.</span>
0841         radius          = ones(1, n_cylinders);
0842         top_center      = [0;0;1]*ones(1, n_cylinders);
0843         bottom_center   = [0;0;0]*ones(1, n_cylinders);
0844         complement_flag = false(1, n_cylinders);
0845         
0846         <span class="comment">% Parse all structure fields.</span>
0847         <span class="keyword">for</span> i = 1:n_fields
0848             <span class="keyword">switch</span> (field_names{i})
0849                 <span class="keyword">case</span> <span class="string">'radius'</span>
0850                     radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, radius);     
0851                 <span class="keyword">case</span> {<span class="string">'top_center'</span>, <span class="string">'top_centre'</span>}
0852                     top_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, top_center);
0853                 <span class="keyword">case</span> {<span class="string">'bottom_center'</span>, <span class="string">'bottom_centre'</span>}
0854                     bottom_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, bottom_center);
0855                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0856                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, complement_flag);
0857                 <span class="keyword">otherwise</span>
0858                     error([<span class="string">'Field name ''%s'' is not valid for a cylinder!\nAvailable field names for a cylinder are: '</span><span class="keyword">...</span>
0859                            <span class="string">'bottom_center, top_center, radius, and complement_flag.'</span>], field_names{i});
0860             <span class="keyword">end</span>
0861         <span class="keyword">end</span>
0862         
0863         <span class="comment">% Start geo code with an opening parenthesis.</span>
0864         geo_code = <span class="string">'('</span>;
0865 
0866         <span class="comment">% Add geo code for each cylinder.</span>
0867         <span class="keyword">for</span> i = 1:n_cylinders
0868             <span class="keyword">if</span> (complement_flag(i))
0869                 geo_code = [geo_code <span class="string">'not '</span>];
0870             <span class="keyword">end</span>
0871             
0872             n_vector = top_center(:,i) - bottom_center(:,i); 
0873             
0874             geo_code = [geo_code sprintf(<span class="string">'(cylinder(%g, %g, %g ; %g, %g, %g ; %g) and plane(%g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g))'</span>, <span class="keyword">...</span>
0875                         bottom_center(:,i), top_center(:,i), radius(i), bottom_center(:,i), -n_vector, top_center(:,i), n_vector)];
0876                     
0877             <span class="keyword">if</span> (i &lt; n_cylinders)
0878                 geo_code = [geo_code operator_string];
0879             <span class="keyword">else</span>
0880                 geo_code = [geo_code <span class="string">')'</span>];             
0881             <span class="keyword">end</span>
0882         <span class="keyword">end</span>
0883     <span class="keyword">end</span>
0884     
0885     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
0886     
0887 <a name="_sub14" href="#_subfunctions" class="code">function geo_code = parse_geometry_ellipsoid(ellipsoid, operator_string)</a>
0888 
0889     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
0890 
0891     <span class="keyword">if</span> (~isstruct(ellipsoid) || isempty(ellipsoid))
0892         error(<span class="string">'Parameter ellipsoid must be a valid structure.'</span>);        
0893     <span class="keyword">else</span>
0894         <span class="comment">% Get number of ellipsoids.</span>
0895         n_ellipsoids = numel(ellipsoid);
0896         
0897         <span class="comment">% Get structure field names.</span>
0898         field_names = fieldnames(ellipsoid);
0899         n_fields = numel(field_names);
0900   
0901         <span class="comment">% Assign default values.</span>
0902         axis_a          = [1;0;0]*ones(1, n_ellipsoids);
0903         axis_b          = [0;1;0]*ones(1, n_ellipsoids);
0904         axis_c          = [0;0;1]*ones(1, n_ellipsoids);
0905         center          = [0;0;0]*ones(1, n_ellipsoids);
0906         complement_flag = false(1, n_ellipsoids);
0907         
0908         <span class="comment">% Parse all structure fields.</span>
0909         <span class="keyword">for</span> i = 1:n_fields
0910             <span class="keyword">switch</span> (field_names{i})   
0911                 <span class="keyword">case</span> {<span class="string">'center'</span>, <span class="string">'centre'</span>}
0912                     center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, center);
0913                 <span class="keyword">case</span> <span class="string">'axis_a'</span>
0914                     axis_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, axis_a);
0915                 <span class="keyword">case</span> <span class="string">'axis_b'</span>
0916                     axis_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, axis_b);
0917                 <span class="keyword">case</span> <span class="string">'axis_c'</span>
0918                     axis_c = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, axis_c);
0919                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0920                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, complement_flag);
0921                 <span class="keyword">otherwise</span>
0922                      error([<span class="string">'Field name ''%s'' is not valid for an ellipsoid!\nAvailable field names for an ellipsoid are: '</span><span class="keyword">...</span>
0923                            <span class="string">'center, axis_a, axis_b, axis_c, and complement_flag.'</span>], field_names{i});
0924             <span class="keyword">end</span>
0925         <span class="keyword">end</span>
0926         
0927         <span class="comment">% Start geo code with an opening parenthesis.</span>
0928         geo_code = <span class="string">'('</span>;
0929 
0930         <span class="comment">% Add geo code for each ellipsoid.</span>
0931         <span class="keyword">for</span> i = 1:n_ellipsoids
0932             <span class="keyword">if</span> (dot(axis_a(:,i), axis_b(:,i)) ~= 0)
0933                 error(<span class="string">'axis_a and axis_b have to be perpendicular for an ellipsoid.'</span>);
0934             <span class="keyword">elseif</span> (dot(axis_a(:,i), axis_c(:,i)) ~= 0)
0935                 error(<span class="string">'axis_a and axis_c have to be perpendicular for an ellipsoid.'</span>);
0936             <span class="keyword">elseif</span> (dot(axis_b(:,i), axis_c(:,i)) ~= 0)
0937                 error(<span class="string">'axis_b and axis_c have to be perpendicular for an ellipsoid.'</span>);
0938             <span class="keyword">end</span>
0939             
0940             <span class="keyword">if</span> (complement_flag(i))
0941                 geo_code = [geo_code <span class="string">'not '</span>];
0942             <span class="keyword">end</span>
0943                 
0944             geo_code = [geo_code sprintf(<span class="string">'ellipsoid(%g, %g, %g ; %g, %g, %g ; %g, %g, %g ; %g, %g, %g)'</span>, <span class="keyword">...</span>
0945                         center(:,i), axis_a(:, i), axis_b(:,i) , axis_c(:,i))];
0946                     
0947             <span class="keyword">if</span> (i &lt; n_ellipsoids)
0948                 geo_code = [geo_code operator_string];
0949             <span class="keyword">else</span>
0950                 geo_code = [geo_code <span class="string">')'</span>];             
0951             <span class="keyword">end</span>
0952         <span class="keyword">end</span>
0953     <span class="keyword">end</span>
0954     
0955     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
0956       
0957 <a name="_sub15" href="#_subfunctions" class="code">function geo_code = parse_geometry_elliptic_cylinder(elliptic_cylinder, operator_string)</a>
0958 
0959     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
0960 
0961     <span class="keyword">if</span> (~isstruct(elliptic_cylinder) || isempty(elliptic_cylinder))
0962         error(<span class="string">'Parameter elliptic_cylinder must be a valid structure.'</span>);        
0963     <span class="keyword">else</span>
0964         <span class="comment">% Get number of elliptic_cylinders.</span>
0965         n_elliptic_cylinders = numel(elliptic_cylinder);
0966         
0967         <span class="comment">% Get structure field names.</span>
0968         field_names = fieldnames(elliptic_cylinder);
0969         n_fields = numel(field_names);
0970         
0971         <span class="comment">% Assign default values.</span>
0972         top_center      = [0;0;1]*ones(1, n_elliptic_cylinders);
0973         bottom_center   = [0;0;0]*ones(1, n_elliptic_cylinders);
0974         axis_a          = [1;0;0]*ones(1, n_elliptic_cylinders);
0975         axis_b          = [0;1;0]*ones(1, n_elliptic_cylinders);
0976         complement_flag = false(1, n_elliptic_cylinders);
0977         
0978         <span class="comment">% Parse all structure fields.</span>
0979         <span class="keyword">for</span> i = 1:n_fields
0980             <span class="keyword">switch</span> (field_names{i})   
0981                 <span class="keyword">case</span> {<span class="string">'top_center'</span>, <span class="string">'top_centre'</span>}
0982                     top_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, top_center);
0983                 <span class="keyword">case</span> {<span class="string">'bottom_center'</span>, <span class="string">'bottom_centre'</span>}
0984                     bottom_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, bottom_center);
0985                 <span class="keyword">case</span> <span class="string">'axis_a'</span>
0986                     axis_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, axis_a);
0987                 <span class="keyword">case</span> <span class="string">'axis_b'</span>
0988                     axis_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, axis_b);
0989                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0990                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, complement_flag);
0991                 <span class="keyword">otherwise</span>
0992                     error([<span class="string">'Field name ''%s'' is not valid for an elliptic cylinder!\nAvailable field names for an elliptic cylinder are: '</span><span class="keyword">...</span>
0993                            <span class="string">'bottom_center, top_center, axis_a, axis_b, and complement_flag.'</span>], field_names{i});
0994             <span class="keyword">end</span>
0995         <span class="keyword">end</span>
0996         
0997         <span class="comment">% Start geo code with an opening parenthesis.</span>
0998         geo_code = <span class="string">'('</span>;
0999 
1000         <span class="comment">% Add geo code for each cylinder.</span>
1001         <span class="keyword">for</span> i = 1:n_elliptic_cylinders
1002             <span class="keyword">if</span> (complement_flag(i))
1003                 geo_code = [geo_code <span class="string">'not '</span>];
1004             <span class="keyword">end</span>
1005             
1006             central_axis = top_center(:,i) - bottom_center(:,i);
1007             
1008             <span class="keyword">if</span> (dot(axis_a(:,i), axis_b(:,i)) ~= 0)
1009                 error(<span class="string">'axis_a and axis_b have to be perpendicular for an elliptic cylinder.'</span>);
1010             <span class="keyword">elseif</span> (dot(axis_a(:,i), central_axis(:,i)) ~= 0)
1011                 error(<span class="string">'axis_a and the central axis have to be perpendicular for an elliptic cylinder.'</span>);
1012             <span class="keyword">elseif</span> (dot(axis_b(:,i), central_axis(:,i)) ~= 0)
1013                 error(<span class="string">'axis_b and the central axis have to be perpendicular for an elliptic cylinder.'</span>);
1014             <span class="keyword">end</span>
1015             
1016             geo_code = [geo_code sprintf(<span class="string">'(ellipticcylinder(%g, %g, %g ; %g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g))'</span>, <span class="keyword">...</span>
1017                         bottom_center(:,i), axis_a(:,i), axis_b(:,i), bottom_center(:,i), -central_axis, top_center(:,i), central_axis)];
1018                     
1019             <span class="keyword">if</span> (i &lt; n_elliptic_cylinders)
1020                 geo_code = [geo_code operator_string];
1021             <span class="keyword">else</span>
1022                 geo_code = [geo_code <span class="string">')'</span>];             
1023             <span class="keyword">end</span>
1024         <span class="keyword">end</span>
1025     <span class="keyword">end</span>
1026     
1027     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
1028     
1029 <a name="_sub16" href="#_subfunctions" class="code">function geo_code = parse_geometry_half_space(half_space, operator_string)</a>
1030 
1031     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
1032 
1033     <span class="keyword">if</span> (~isstruct(half_space) || isempty(half_space))
1034         error(<span class="string">'Parameter half_space must be a valid structure.'</span>);        
1035     <span class="keyword">else</span>
1036         <span class="comment">% Get number of half_spaces.</span>
1037         n_half_spaces = numel(half_space);
1038         
1039         <span class="comment">% Get structure field names.</span>
1040         field_names = fieldnames(half_space);
1041         n_fields = numel(field_names);
1042         
1043         <span class="comment">% Assign default values.</span>
1044         point           = [0;0;0]*ones(1, n_half_spaces);
1045         outward_normal_vector  = [0;0;1]*ones(1, n_half_spaces);
1046         complement_flag = false(1, n_half_spaces);
1047         
1048         <span class="comment">% Parse all structure fields.</span>
1049         <span class="keyword">for</span> i = 1:n_fields
1050             <span class="keyword">switch</span> (field_names{i})  
1051                 <span class="keyword">case</span> <span class="string">'point'</span>
1052                     point = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(half_space, n_half_spaces, <span class="string">'half_space'</span>, field_names{i}, point);
1053                 <span class="keyword">case</span> <span class="string">'outward_normal_vector'</span>
1054                     outward_normal_vector = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(half_space, n_half_spaces, <span class="string">'half_space'</span>, field_names{i}, outward_normal_vector);
1055                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1056                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(half_space, n_half_spaces, <span class="string">'half_space'</span>, field_names{i}, complement_flag);
1057                 <span class="keyword">otherwise</span>
1058                     error([<span class="string">'Field name ''%s'' is not valid for a half_space!\Available field names for a half_space are: '</span> <span class="keyword">...</span>
1059                            <span class="string">'point, outward_normal_vector, and complement_flag.'</span>], field_names{i});
1060             <span class="keyword">end</span>
1061         <span class="keyword">end</span>
1062         
1063         <span class="comment">% Start geo code with an opening parenthesis.</span>
1064         geo_code = <span class="string">'('</span>;
1065 
1066         <span class="comment">% Add geo code for each half_space.</span>
1067         <span class="keyword">for</span> i = 1:n_half_spaces
1068             <span class="keyword">if</span> (complement_flag(i))
1069                 geo_code = [geo_code <span class="string">'not '</span>];
1070             <span class="keyword">end</span>
1071             
1072             geo_code = [geo_code sprintf(<span class="string">'plane(%g, %g, %g ; %g, %g, %g)'</span>, <span class="keyword">...</span>
1073                         point(:,i), outward_normal_vector(:,i))];
1074                     
1075             <span class="keyword">if</span> (i &lt; n_half_spaces)
1076                 geo_code = [geo_code operator_string];
1077             <span class="keyword">else</span>
1078                 geo_code = [geo_code <span class="string">')'</span>];             
1079             <span class="keyword">end</span>
1080         <span class="keyword">end</span>
1081     <span class="keyword">end</span>
1082     
1083     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
1084 
1085 <a name="_sub17" href="#_subfunctions" class="code">function geo_code = parse_geometry_ortho_brick(ortho_brick, operator_string)</a>
1086 
1087     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
1088 
1089     <span class="keyword">if</span> (~isstruct(ortho_brick) || isempty(ortho_brick))
1090         error(<span class="string">'Parameter ortho_brick must be a valid structure.'</span>);        
1091     <span class="keyword">else</span>
1092         <span class="comment">% Get number of ortho_bricks.</span>
1093         n_ortho_bricks = numel(ortho_brick);
1094         
1095         <span class="comment">% Get structure field names.</span>
1096         field_names = fieldnames(ortho_brick);
1097         n_fields = numel(field_names);
1098         
1099         <span class="comment">% Assign default values.</span>
1100         opposite_corner_a = [0;0;0]*ones(1, n_ortho_bricks);
1101         opposite_corner_b = [1;1;1]*ones(1, n_ortho_bricks);
1102         complement_flag   = zeros(1, n_ortho_bricks);
1103         
1104         <span class="comment">% Parse all structure fields.</span>
1105         <span class="keyword">for</span> i = 1:n_fields
1106             <span class="keyword">switch</span> (field_names{i})  
1107                 <span class="keyword">case</span> {<span class="string">'opposite_corner_a'</span>}
1108                     opposite_corner_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ortho_brick, n_ortho_bricks, <span class="string">'ortho_brick'</span>, field_names{i}, opposite_corner_a);
1109                 <span class="keyword">case</span> {<span class="string">'opposite_corner_b'</span>}
1110                     opposite_corner_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ortho_brick, n_ortho_bricks, <span class="string">'ortho_brick'</span>, field_names{i}, opposite_corner_b);
1111                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1112                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(ortho_brick, n_ortho_bricks, <span class="string">'ortho_brick'</span>, field_names{i}, complement_flag);
1113                 <span class="keyword">otherwise</span>
1114                     error([<span class="string">'Field name &quot;%s&quot; is not allowed for an ortho_brick!\nAllowed field names for an ortho_brick are: '</span> <span class="keyword">...</span>
1115                            <span class="string">'opposite_corner_a, opposite_corner_b, and complement_flag.'</span>], field_names{i});
1116             <span class="keyword">end</span>
1117         <span class="keyword">end</span>
1118         
1119         <span class="comment">% Start geo code with an opening parenthesis.</span>
1120         geo_code = <span class="string">'('</span>;
1121 
1122         <span class="comment">% Add geo code for each ortho_brick.</span>
1123         <span class="keyword">for</span> i = 1:n_ortho_bricks
1124             <span class="keyword">if</span> (complement_flag(i))
1125                 geo_code = [geo_code <span class="string">'not '</span>];
1126             <span class="keyword">end</span>
1127             
1128             geo_code = [geo_code sprintf(<span class="string">'orthobrick(%g, %g, %g ; %g, %g, %g)'</span>, <span class="keyword">...</span>
1129                         min([opposite_corner_a(:, i) opposite_corner_b(:, i)], [], 2), <span class="keyword">...</span>
1130                         max([opposite_corner_a(:, i) opposite_corner_b(:, i)], [], 2))];
1131                     
1132             <span class="keyword">if</span> (i &lt; n_ortho_bricks)
1133                 geo_code = [geo_code operator_string];
1134             <span class="keyword">else</span>
1135                 geo_code = [geo_code <span class="string">')'</span>];             
1136             <span class="keyword">end</span>
1137         <span class="keyword">end</span>
1138     <span class="keyword">end</span>
1139     
1140     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
1141     
1142 <a name="_sub18" href="#_subfunctions" class="code">function geo_code = parse_geometry_parallelepiped(parallelepiped, operator_string)</a>
1143 
1144     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
1145 
1146     <span class="keyword">if</span> (~isstruct(parallelepiped) || isempty(parallelepiped))
1147         error(<span class="string">'Parameter parallelepiped must be a valid structure.'</span>);        
1148     <span class="keyword">else</span>
1149         <span class="comment">% Get number of parallelepiped.</span>
1150         n_parallelepipeds = numel(parallelepiped);
1151         
1152         <span class="comment">% Get structure field names.</span>
1153         field_names = fieldnames(parallelepiped);
1154         n_fields = numel(field_names);
1155         
1156         <span class="comment">% Assign default values.</span>
1157         vertex          = [0;0;0]*ones(1, n_parallelepipeds);
1158         vector_a        = [1;0;0]*ones(1, n_parallelepipeds);
1159         vector_b        = [0;1;0]*ones(1, n_parallelepipeds);
1160         vector_c        = [0;0;1]*ones(1, n_parallelepipeds);
1161         complement_flag = zeros(1, n_parallelepipeds);
1162         
1163         <span class="comment">% Parse all structure fields.</span>
1164         <span class="keyword">for</span> i = 1:n_fields
1165             <span class="keyword">switch</span> (field_names{i})  
1166                 <span class="keyword">case</span> <span class="string">'vertex'</span>
1167                     vertex = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vertex);
1168                 <span class="keyword">case</span> <span class="string">'vector_a'</span>
1169                     vector_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vector_a);
1170                 <span class="keyword">case</span> <span class="string">'vector_b'</span>
1171                     vector_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vector_b);
1172                 <span class="keyword">case</span> <span class="string">'vector_c'</span>
1173                     vector_c = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vector_c);
1174                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1175                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, complement_flag);
1176                 <span class="keyword">otherwise</span>
1177                     error([<span class="string">'Field name &quot;%s&quot; is not allowed for a parallelepiped!\nAllowed field names for a parallelepiped are: '</span> <span class="keyword">...</span>
1178                            <span class="string">'vertex, vector_a, vector_b, vector_c, and complement_flag.'</span>], field_names{i});
1179             <span class="keyword">end</span>
1180         <span class="keyword">end</span>
1181         
1182         <span class="comment">% Start geo code with an opening parenthesis.</span>
1183         geo_code = <span class="string">'('</span>;
1184 
1185         <span class="comment">% Add geo code for each parallelepiped.</span>
1186         <span class="keyword">for</span> i = 1:n_parallelepipeds
1187             <span class="keyword">if</span> (complement_flag(i))
1188                 geo_code = [geo_code <span class="string">'not '</span>];
1189             <span class="keyword">end</span>
1190              
1191             <span class="comment">% Make sure all vectors are not coplanar.</span>
1192             <span class="keyword">if</span> (abs(dot(vector_a(:,i), cross(vector_b(:,i), vector_c(:,i)))) &lt; eps)
1193                 error(<span class="string">'parallelepiped(%d) description includes coplanar vectors.'</span>, i);
1194             <span class="keyword">end</span>
1195             
1196             <span class="comment">% Compute opposite vertex.</span>
1197             opposite_vertex = vertex(:,i) + vector_a(:,i) + vector_b(:,i) + vector_c(:,i);
1198             
1199             <span class="comment">% Compute normal vectors.</span>
1200             n_vector_ab = cross(vector_a(:,i), vector_b(:,i));
1201             n_vector_ac = cross(vector_a(:,i), vector_c(:,i));
1202             n_vector_bc = cross(vector_b(:,i), vector_c(:,i));
1203             
1204             <span class="comment">% Check normal vectors directions.</span>
1205             <span class="keyword">if</span> (dot(n_vector_ab, vector_c(:,i)) &lt; 0)
1206                 n_vector_ab = -n_vector_ab;
1207             <span class="keyword">end</span>
1208             <span class="keyword">if</span> (dot(n_vector_ac, vector_b(:,i)) &lt; 0)
1209                 n_vector_ac = -n_vector_ac;
1210             <span class="keyword">end</span>
1211             <span class="keyword">if</span> (dot(n_vector_bc, vector_a(:,i)) &lt; 0)
1212                 n_vector_bc = -n_vector_bc;
1213             <span class="keyword">end</span>
1214             
1215             geo_code = [geo_code sprintf([<span class="string">'(plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1216                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1217                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1218                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1219                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1220                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g))'</span>], <span class="keyword">...</span>
1221                         vertex(:,i), -n_vector_ab, <span class="keyword">...</span>
1222                         vertex(:,i), -n_vector_ac, <span class="keyword">...</span>
1223                         vertex(:,i), -n_vector_bc, <span class="keyword">...</span>
1224                         opposite_vertex, n_vector_ab, <span class="keyword">...</span>
1225                         opposite_vertex, n_vector_ac, <span class="keyword">...</span>
1226                         opposite_vertex, n_vector_bc)];
1227                     
1228             <span class="keyword">if</span> (i &lt; n_parallelepipeds)
1229                 geo_code = [geo_code operator_string];
1230             <span class="keyword">else</span>
1231                 geo_code = [geo_code <span class="string">')'</span>];             
1232             <span class="keyword">end</span>
1233         <span class="keyword">end</span>
1234     <span class="keyword">end</span>
1235     
1236     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
1237     
1238 <a name="_sub19" href="#_subfunctions" class="code">function geo_code = parse_geometry_sphere(sphere, operator_string)</a>
1239 
1240     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 3);
1241 
1242     <span class="keyword">if</span> (~isstruct(sphere) || isempty(sphere))
1243         error(<span class="string">'Parameter sphere must be a valid structure.'</span>);        
1244     <span class="keyword">else</span>
1245         <span class="comment">% Get number of spheres.</span>
1246         n_spheres = numel(sphere);
1247         
1248         <span class="comment">% Get structure field names.</span>
1249         field_names = fieldnames(sphere);
1250         n_fields = numel(field_names);
1251   
1252         <span class="comment">% Assign default values.</span>
1253         radius          = ones(1, n_spheres);
1254         center          = [0;0;0]*ones(1, n_spheres);
1255         complement_flag = false(1, n_spheres);
1256         
1257         <span class="comment">% Parse all structure fields.</span>
1258         <span class="keyword">for</span> i = 1:n_fields
1259             <span class="keyword">switch</span> (field_names{i})
1260                 <span class="keyword">case</span> {<span class="string">'center'</span>, <span class="string">'centre'</span>}
1261                     center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(sphere, n_spheres, <span class="string">'sphere'</span>, field_names{i}, center);
1262                 <span class="keyword">case</span> <span class="string">'radius'</span>
1263                     radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(sphere, n_spheres, <span class="string">'sphere'</span>, field_names{i}, radius);     
1264                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1265                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(sphere, n_spheres, <span class="string">'sphere'</span>, field_names{i}, complement_flag);
1266                 <span class="keyword">otherwise</span>
1267                     error([<span class="string">'Field name ''%s'' is not valid for a sphere.\nAvailable field names for a sphere are: '</span> <span class="keyword">...</span>
1268                            <span class="string">'center, radius, and complement_flag.'</span>], field_names{i});
1269             <span class="keyword">end</span>
1270         <span class="keyword">end</span>
1271         
1272         <span class="comment">% Start geo code with an opening parenthesis.</span>
1273         geo_code = <span class="string">'('</span>;
1274 
1275         <span class="comment">% Add geo code for each sphere.</span>
1276         <span class="keyword">for</span> i = 1:n_spheres
1277             <span class="keyword">if</span> (complement_flag(i))
1278                 geo_code = [geo_code <span class="string">'not '</span>];
1279             <span class="keyword">end</span>
1280                 
1281             geo_code = [geo_code sprintf(<span class="string">'sphere(%g, %g, %g ; %g)'</span>, <span class="keyword">...</span>
1282                         center(:,i), radius(i))];
1283                     
1284             <span class="keyword">if</span> (i &lt; n_spheres)
1285                 geo_code = [geo_code operator_string];
1286             <span class="keyword">else</span>
1287                 geo_code = [geo_code <span class="string">')'</span>];             
1288             <span class="keyword">end</span>
1289         <span class="keyword">end</span>
1290     <span class="keyword">end</span>
1291     
1292     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 3);
1293                              
1294 <a name="_sub20" href="#_subfunctions" class="code">function write_geo_file(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param)</a>
1295     
1296     <span class="comment">% Open geo file for writing.</span>
1297     fid = fopen(geo_fn, <span class="string">'w'</span>);
1298     
1299     <span class="keyword">if</span> (fid == -1)
1300         error(<span class="string">'Unable to open file %s for writing.'</span>, geo_fn);
1301     <span class="keyword">end</span>
1302     
1303     <span class="comment">% Write header for geo file.</span>
1304     fprintf(fid, <span class="string">'#Automatically generated by ng_mk_geometric_models\n\n'</span>);
1305     fprintf(fid, <span class="string">'algebraic3d\n\n'</span>);
1306     
1307     <span class="comment">% Assemble a string to represent the union of all bodies.</span>
1308     total_body_solid = <span class="string">'('</span>;
1309    
1310     <span class="keyword">for</span> i = 1:numel(body_solid_code)
1311         total_body_solid = [total_body_solid body_extra_param{i}.name];
1312 
1313         <span class="keyword">if</span> (i &lt; numel(body_solid_code))
1314             total_body_solid = [total_body_solid <span class="string">' or '</span>];
1315         <span class="keyword">else</span>
1316             total_body_solid = [total_body_solid <span class="string">')'</span>];             
1317         <span class="keyword">end</span>
1318     <span class="keyword">end</span>
1319     
1320     <span class="comment">% Assemble a string to represent the union of all electrodes entering the body.</span>
1321     total_electrode_solid = <span class="string">'('</span>;
1322     n_total_electrode_solid = 0;
1323    
1324     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1325         <span class="keyword">if</span> (electrode_extra_param{i}.enter_body_flag)
1326             <span class="keyword">if</span> (n_total_electrode_solid &gt; 0)
1327                 total_electrode_solid = [total_electrode_solid <span class="string">' or '</span>];
1328             <span class="keyword">end</span>
1329             total_electrode_solid = [total_electrode_solid electrode_extra_param{i}.name];
1330             n_total_electrode_solid = n_total_electrode_solid + 1;
1331         <span class="keyword">end</span>
1332     <span class="keyword">end</span>
1333     total_electrode_solid = [total_electrode_solid <span class="string">')'</span>];   
1334     
1335     <span class="comment">% Write body_extra_code and electrode_extra_code in geo file</span>
1336     <span class="keyword">for</span> i = 1:numel(body_extra_code)
1337         <span class="keyword">if</span> (~isempty(body_extra_code{i}))
1338             fprintf(fid, body_extra_code{i});
1339         <span class="keyword">end</span>
1340     <span class="keyword">end</span>
1341     <span class="keyword">for</span> i = 1:numel(electrode_extra_code)
1342         <span class="keyword">if</span> (~isempty(electrode_extra_code{i}))
1343             fprintf(fid, electrode_extra_code{i});
1344         <span class="keyword">end</span>
1345     <span class="keyword">end</span>
1346     fprintf(fid, <span class="string">'\n'</span>);
1347  
1348     <span class="comment">% Write electrode solids that enter the body in geo file.</span>
1349     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1350         <span class="keyword">if</span> (~isempty(electrode_solid_code{i}) &amp;&amp; electrode_extra_param{i}.enter_body_flag)
1351             fprintf(fid, <span class="string">'solid %s = %s;\n\n'</span>, electrode_extra_param{i}.name, electrode_solid_code{i});
1352         <span class="keyword">end</span>
1353     <span class="keyword">end</span>
1354     
1355     <span class="comment">% Write body solids in geo file.</span>
1356     <span class="keyword">for</span> i = 1:numel(body_solid_code)
1357         <span class="keyword">if</span> (n_total_electrode_solid == 0)
1358             fprintf(fid, <span class="string">'solid %s = %s;\n\n'</span>, body_extra_param{i}.name, body_solid_code{i});
1359         <span class="keyword">else</span>
1360             fprintf(fid, <span class="string">'solid %s = not %s and %s;\n\n'</span>, body_extra_param{i}.name, total_electrode_solid, body_solid_code{i});            
1361         <span class="keyword">end</span>
1362     <span class="keyword">end</span>
1363  
1364     <span class="comment">% Write electrode solids that do not enter the body in geo file.</span>
1365     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1366         <span class="keyword">if</span> (~isempty(electrode_solid_code{i}) &amp;&amp; ~electrode_extra_param{i}.enter_body_flag)
1367             fprintf(fid, <span class="string">'solid %s = not %s and %s;\n\n'</span>, electrode_extra_param{i}.name, total_body_solid, electrode_solid_code{i});
1368         <span class="keyword">end</span>
1369     <span class="keyword">end</span>
1370     
1371     <span class="comment">% Write electrode tlos in geo file.</span>
1372     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1373         <span class="keyword">if</span> (~isempty(electrode_solid_code{i}))
1374             <span class="keyword">if</span> (isinf(electrode_extra_param{i}.max_edge_length))
1375                 fprintf(fid, <span class="string">'tlo %s -col=[1,0,0] -material=%s;\n'</span>, electrode_extra_param{i}.name, electrode_extra_param{i}.name);
1376             <span class="keyword">else</span>
1377                 fprintf(fid, <span class="string">'tlo %s -col=[1,0,0] -material=%s -maxh=%g;\n'</span>, electrode_extra_param{i}.name, electrode_extra_param{i}.name, electrode_extra_param{i}.max_edge_length);          
1378             <span class="keyword">end</span>
1379         <span class="keyword">end</span>
1380     <span class="keyword">end</span>
1381     
1382     <span class="comment">% Write body tlos in geo file.</span>
1383     <span class="keyword">for</span> i = 1:numel(body_solid_code)
1384         <span class="keyword">if</span> (isinf(body_extra_param{i}.max_edge_length))
1385             fprintf(fid, <span class="string">'tlo %s -col=[0,1,0] -material=%s;\n'</span>, body_extra_param{i}.name, body_extra_param{i}.name);
1386         <span class="keyword">else</span>
1387             fprintf(fid, <span class="string">'tlo %s -col=[0,1,0] -material=%s -maxh=%g;\n'</span>, body_extra_param{i}.name, body_extra_param{i}.name, body_extra_param{i}.max_edge_length);            
1388         <span class="keyword">end</span>
1389     <span class="keyword">end</span>
1390     
1391     <span class="comment">% Close file.</span>
1392     fclose(fid);
1393 
1394 <a name="_sub21" href="#_subfunctions" class="code">function mat = read_mat_from_file(fid, nrows, ncols)</a>
1395     mat = fscanf(fid, <span class="string">'%g'</span>, [ncols, nrows])';
1396 
1397     <span class="comment">% Skip to next line.</span>
1398     <span class="keyword">if</span> (~isempty(fgetl(fid)))
1399         error(<span class="string">'Last line was only partialy read.'</span>);
1400     <span class="keyword">end</span>
1401     
1402 <a name="_sub22" href="#_subfunctions" class="code">function fmdl = read_vol_file(vol_fn, electrode_extra_param)</a>
1403 
1404     <span class="comment">% Open file for reading.</span>
1405     fid = fopen(vol_fn, <span class="string">'r'</span>);
1406 
1407     <span class="keyword">if</span> (fid == -1)
1408         error(<span class="string">'Unable to open file %s for reading.'</span>, vol_fn);
1409     <span class="keyword">end</span>
1410     
1411     <span class="comment">% Read a first line in vol file.</span>
1412     line = fgetl(fid);
1413    
1414     <span class="comment">% While no EOF or &quot;endmesh&quot; keyword is found.</span>
1415     <span class="keyword">while</span> (ischar(line) &amp;&amp; ~strcmp(line, <span class="string">'endmesh'</span>))
1416         
1417         <span class="comment">% Parse every line if not comment or empty line</span>
1418         <span class="keyword">if</span> (~isempty(line) &amp;&amp; line(1) ~= <span class="string">'#'</span>) <span class="comment">% Supposing '#' is always the first character of a comment line.</span>
1419             <span class="keyword">switch</span>(line)
1420                 <span class="keyword">case</span> <span class="string">'mesh3d'</span>   <span class="comment">% Nothing to do.</span>
1421                 <span class="keyword">case</span> <span class="string">'dimension'</span>
1422                     dimension = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1423                     <span class="keyword">if</span> (dimension ~= 3)
1424                         error(<span class="string">'unknown dimension %g in vol file.'</span>, dimension);
1425                     <span class="keyword">end</span>
1426                 <span class="keyword">case</span> <span class="string">'geomtype'</span>
1427                     geomtype = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1428                     <span class="keyword">if</span> (geomtype ~= 0)
1429                         error(<span class="string">'unknown %g geomtype in vol file.'</span>, geomtype);
1430                     <span class="keyword">end</span>
1431                 <span class="keyword">case</span> <span class="string">'surfaceelements'</span>
1432                     <span class="comment">% # surfnr    bcnr   domin  domout      np      p1      p2      p3</span>
1433                     n_surface_elements = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1434                     <span class="keyword">if</span> (n_surface_elements)
1435                         surface_elements   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_surface_elements, 8);
1436                     <span class="keyword">else</span>
1437                         error(<span class="string">'vol file contains no surface elements. There is probably something wrong with the provided geometry description.'</span>);    
1438                     <span class="keyword">end</span>
1439                 <span class="keyword">case</span> <span class="string">'volumeelements'</span>
1440                     <span class="comment">% #  matnr      np      p1      p2      p3      p4</span>
1441                     n_volume_elements = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1442                     <span class="keyword">if</span> (n_volume_elements)
1443                         volume_elements   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_volume_elements, 6);
1444                     <span class="keyword">else</span>
1445                         error(<span class="string">'vol file contains no volume elements. There is probably something wrong with the provided geometry description.'</span>);    
1446                     <span class="keyword">end</span>
1447                 <span class="keyword">case</span> <span class="string">'edgesegmentsgi2'</span>
1448                     <span class="comment">% # surfid  0   p1   p2   trignum1    trignum2   domin/surfnr1    domout/surfnr2   ednr1   dist1   ednr2   dist2</span>
1449                     n_edge_segments_sgi2 = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1450                     edge_segments_sgi2   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_edge_segments_sgi2, 12);
1451                 <span class="keyword">case</span> <span class="string">'points'</span>
1452                     <span class="comment">% #          X             Y             Z</span>
1453                     n_points = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1454                     <span class="keyword">if</span> (n_points)
1455                         points   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_points, 3);
1456                     <span class="keyword">else</span>
1457                         error(<span class="string">'vol file contains no points. There is probably something wrong with the provided geometry description.'</span>);                       
1458                     <span class="keyword">end</span>
1459                 <span class="keyword">case</span> <span class="string">'materials'</span>
1460                     n_materials = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1461                     <span class="keyword">if</span> (n_materials)
1462                         materials   = cell(n_materials, 2);
1463                         <span class="comment">% Read and parse each material line.</span>
1464                         <span class="keyword">for</span> i = 1:n_materials
1465                             material_line = fgetl(fid);
1466                             sscanf_result = sscanf(material_line, <span class="string">'%g%c%s'</span>)';
1467                             materials{i, 1} = sscanf_result(1);
1468                             materials{i, 2} = char(sscanf_result(3:end));
1469                         <span class="keyword">end</span>
1470                     <span class="keyword">else</span>
1471                         error(<span class="string">'vol file contains no materials. There is probably something wrong with the provided geometry description.'</span>);                             
1472                     <span class="keyword">end</span>
1473                 <span class="keyword">case</span> <span class="string">'face_colours'</span>
1474                     <span class="comment">% #   Surfnr     Red     Green     Blue</span>
1475                     n_face_colours = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1476                     face_colours   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_face_colours, 4);
1477                 <span class="keyword">otherwise</span>
1478                     error(<span class="string">'unknown &quot;%s&quot; line in vol file.'</span>, line);
1479             <span class="keyword">end</span>
1480         <span class="keyword">end</span>
1481         
1482         <span class="comment">% Read next line in vol file.</span>
1483         line = fgetl(fid);
1484     <span class="keyword">end</span>
1485     
1486     <span class="comment">% Close file.</span>
1487     fclose(fid);
1488     
1489     <span class="keyword">if</span> (~exist(<span class="string">'points'</span>, <span class="string">'var'</span>))
1490         error(<span class="string">'Point description is missing from vol file.'</span>);
1491     <span class="keyword">end</span>
1492  
1493     <span class="keyword">if</span> (~exist(<span class="string">'volume_elements'</span>, <span class="string">'var'</span>))
1494         error(<span class="string">'Volume element description is missing from vol file.'</span>);
1495     <span class="keyword">end</span>
1496     
1497     <span class="keyword">if</span> (~exist(<span class="string">'surface_elements'</span>, <span class="string">'var'</span>))
1498         error(<span class="string">'Surface element description is missing from vol file.'</span>);
1499     <span class="keyword">end</span>
1500     
1501     <span class="keyword">if</span> (~exist(<span class="string">'materials'</span>, <span class="string">'var'</span>))
1502         error(<span class="string">'Material description is missing from vol file.'</span>);
1503     <span class="keyword">end</span>
1504     
1505     <span class="comment">% Find electrode and body material indices.</span>
1506     electrode_material = [];
1507     <span class="keyword">for</span> i = 1:n_materials
1508         material_name   = materials{i, 2};
1509         material_number = materials{i, 1};
1510         
1511 <span class="comment">%         if (strncmp(material_name, 'electrode', 9))</span>
1512 <span class="comment">%             % Extract electrode number from material_name</span>
1513 <span class="comment">%             electrode_number = str2double(material_name(10:end));</span>
1514 <span class="comment">%             electrode_material(electrode_number) = material_number;</span>
1515 <span class="comment">%         end</span>
1516         <span class="keyword">for</span> j = 1:numel(electrode_extra_param)
1517             <span class="keyword">if</span> (strcmp(material_name, electrode_extra_param{j}.name))
1518                 electrode_material(j) = material_number;
1519             <span class="keyword">end</span>
1520         <span class="keyword">end</span>
1521     <span class="keyword">end</span>
1522    
1523     <span class="comment">% Remove electrode material if necessary</span>
1524     original_n_nodes     = size(points, 1);
1525     original_n_elements  = size(volume_elements, 1);
1526     original_n_surfaces  = size(surface_elements, 1);
1527     original_n_materials = size(materials, 1);
1528 
1529     <span class="keyword">for</span> i = 1:numel(electrode_material)
1530         <span class="keyword">if</span> (~electrode_extra_param{i}.keep_material_flag)
1531             <span class="comment">% Remove unwanted volume elements</span>
1532             volume_elements(volume_elements(:, 1) == electrode_material(i), :) = [];
1533 
1534             <span class="comment">% Remove unwanted surface elements</span>
1535             surface_elements(surface_elements(:, 3) == electrode_material(i) &amp; <span class="keyword">...</span>
1536                              surface_elements(:, 4) == 0 | <span class="keyword">...</span>
1537                              surface_elements(:, 4) == electrode_material(i) &amp; <span class="keyword">...</span>
1538                              surface_elements(:, 3) == 0, :) = [];
1539         <span class="keyword">end</span>
1540     <span class="keyword">end</span>
1541 
1542     <span class="comment">% Find nodes that are now unused.</span>
1543     unused_nodes = true(1, size(points, 1));
1544     unused_nodes(volume_elements(:, 3:6))  = false;
1545     unused_nodes(surface_elements(:, 6:8)) = false;     
1546 
1547     <span class="comment">% Remove unused points.</span>
1548     points(unused_nodes, :) = [];
1549 
1550     <span class="comment">% Compute new node indices after node removal.</span>
1551     new_node_index = (1:original_n_nodes) - cumsum(unused_nodes);   
1552 
1553     <span class="comment">% Update node indices for surface and volume elements.</span>
1554     surface_elements(:, 6:8) = new_node_index(surface_elements(:, 6:8));
1555     volume_elements(:, 3:6)  = new_node_index(volume_elements(:, 3:6));
1556 
1557     <span class="comment">% Find materials that are now unused.</span>
1558     unused_materials = true(1, size(materials, 1));
1559     unused_materials(volume_elements(:, 1)) = false;
1560 
1561     <span class="comment">% Remove unused materials.</span>
1562     materials(unused_materials, :) = [];
1563 
1564     <span class="comment">% Compute new material indices after material removal.</span>
1565     new_material_index = (1:original_n_materials) - cumsum(unused_materials);   
1566 
1567     <span class="comment">% Update material indices for volume elements.</span>
1568     volume_elements(:, 1)  = new_material_index(volume_elements(:, 1));
1569 
1570     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ Removed %d nodes, %d elements, %d surfaces and %d materials'</span>, <span class="keyword">...</span>
1571         original_n_nodes     - size(points, 1), <span class="keyword">...</span>
1572         original_n_elements  - size(volume_elements, 1), <span class="keyword">...</span>
1573         original_n_surfaces  - size(surface_elements, 1), <span class="keyword">...</span>
1574         original_n_materials - size(materials, 1), 3);
1575     
1576     <span class="comment">% Assign mesh data to fmdl structures.</span>
1577     fmdl.nodes            = points;
1578     fmdl.elems            = volume_elements(:, 3:6);
1579     fmdl.boundary         = surface_elements(:, 6:8);
1580     fmdl.boundary_numbers = surface_elements(:, 2);
1581     <span class="keyword">for</span> i=1:max(volume_elements(:,1))
1582        fmdl.mat_idx{i}    = find( volume_elements(:, 1) == i);
1583     <span class="keyword">end</span>
1584     fmdl.mat_name         = materials(:, 2);
1585     
1586     <span class="comment">% Find electrode surfaces and nodes.</span>
1587     <span class="keyword">for</span> i = 1:numel(electrode_material)
1588         <span class="comment">% Find surfaces that are part of the electrodes.</span>
1589         <span class="keyword">if</span> (electrode_extra_param{i}.keep_material_flag)
1590             electrode_boundary = <span class="keyword">...</span>
1591                sort(find(surface_elements(:, 3) == 0 &amp; <span class="keyword">...</span>
1592                          surface_elements(:, 4) == electrode_material(i) | <span class="keyword">...</span>
1593                          surface_elements(:, 4) == 0 &amp; <span class="keyword">...</span>
1594                          surface_elements(:, 3) == electrode_material(i)))';
1595         <span class="keyword">else</span>
1596             electrode_boundary = <span class="keyword">...</span>
1597                 sort(find(surface_elements(:, 3) == electrode_material(i) | <span class="keyword">...</span>
1598                           surface_elements(:, 4) == electrode_material(i)))';
1599         <span class="keyword">end</span>
1600      
1601         <span class="keyword">if</span> (isempty(electrode_boundary))
1602             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'WARNING: Electrode #%04d has been removed since it does not contact any body.'</span>, i, 2);
1603         <span class="keyword">else</span>
1604             fmdl.electrode(i).boundary = electrode_boundary;
1605             
1606             <span class="comment">% Find nodes that are part of the electrodes.</span>
1607             fmdl.electrode(i).nodes = <span class="keyword">...</span>
1608                 unique(fmdl.boundary(fmdl.electrode(i).boundary(:), :))';                          
1609 
1610             <span class="comment">% Assign default contact impedance.</span>
1611             fmdl.electrode(i).z_contact = 0.01;
1612             
1613             <span class="keyword">if</span> (~isempty(electrode_extra_param{i}.name))
1614                 fmdl.electrode(i).name = electrode_extra_param{i}.name;
1615             <span class="keyword">end</span>
1616         <span class="keyword">end</span>
1617     <span class="keyword">end</span>
1618 
1619 <a name="_sub23" href="#_subfunctions" class="code">function fmdl = complete_fmdl(fmdl, electrode_extra_param)</a>
1620  
1621     <span class="comment">% Find center point of domain.</span>
1622     domain_center  = (max(fmdl.nodes)-min(fmdl.nodes))/2 + min(fmdl.nodes);
1623     domain_centers = ones(size(fmdl.nodes, 1), 1)*domain_center;
1624     
1625     <span class="comment">% Find node closest to center for ground node.</span>
1626     [unused, min_idx] = min(sum((fmdl.nodes - domain_centers).^2, 2));
1627     fmdl.gnd_node     = min_idx(1);
1628 
1629     fmdl.np_fwd_solve.perm_sym = <span class="string">'{n}'</span>;
1630 
1631     fmdl.name = <span class="string">'ng_mk_geometric_models'</span>;
1632 
1633     fmdl.solve=      <span class="string">'eidors_default'</span>;
1634     fmdl.jacobian=   <span class="string">'eidors_default'</span>;
1635     fmdl.system_mat= <span class="string">'eidors_default'</span>;
1636 
1637     fmdl.normalize_measurements = 0;
1638     
1639     <span class="keyword">for</span> i = 1:numel(electrode_extra_param)
1640         <span class="keyword">if</span> (isfield(electrode_extra_param{i}, <span class="string">'point'</span>))
1641             <span class="comment">% Find center point of domain.</span>
1642             electrode_points = ones(size(fmdl.nodes, 1), 1)*electrode_extra_param{i}.point';
1643 
1644             <span class="comment">% Find node closest to the electrode point.</span>
1645             [unused, min_idx]       = min(sum((fmdl.nodes - electrode_points).^2, 2));
1646             fmdl.electrode(i).nodes = min_idx(1);
1647             fmdl.electrode(i).boundary = [];
1648 
1649             <span class="comment">% Assign default contact impedance.</span>
1650             fmdl.electrode(i).z_contact = 0.01;
1651         <span class="keyword">end</span>
1652     <span class="keyword">end</span>
1653 
1654     fmdl = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, fmdl);
1655 
1656 <a name="_sub24" href="#_subfunctions" class="code">function do_unit_test</a>
1657     <span class="keyword">for</span> tn = 1:<a href="#_sub25" class="code" title="subfunction [fmdl, opts] = do_test_number(tn)">do_test_number</a>(0)
1658         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'ng_mk_geometric_models: unit_test %02d'</span>, tn, 1);
1659         [fmdl, opts] = <a href="#_sub25" class="code" title="subfunction [fmdl, opts] = do_test_number(tn)">do_test_number</a>(tn);
1660         subplot(1,3,1)
1661         <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl);
1662         title(<span class="string">'show_fem'</span>, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
1663         subplot(1,3,2);
1664         <a href="../../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>(fmdl, opts);
1665         title({<span class="string">'show_fem_enhanced'</span>; <span class="string">'(default options)'</span>}, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
1666         subplot(1,3,3);
1667         opts.edge.color = [0 0 1];
1668         opts.edge.width = 0;
1669         opts.edge.significant.color = [1 0 0];
1670         opts.edge.significant.width = 1.5;
1671         opts.edge.significant.viewpoint_dependent.color = [0 1 0];
1672         opts.edge.significant.viewpoint_dependent.width = 1.5;
1673         <a href="../../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>(fmdl, opts);
1674         title({<span class="string">'show_fem_enhanced'</span>; <span class="string">'(with some options)'</span>}, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
1675         drawnow;
1676         <span class="comment">%pause</span>
1677     <span class="keyword">end</span>
1678 
1679 <a name="_sub25" href="#_subfunctions" class="code">function [fmdl, opts] = do_test_number(tn)</a>
1680     opts = struct;
1681     <span class="keyword">switch</span> tn
1682         <span class="comment">% Simple 3D cylinder. Radius = 1 with no electrodes</span>
1683         <span class="keyword">case</span> 1;
1684             body_geometry.cylinder = struct;
1685             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1686         <span class="comment">% Simple 3D cylinder. Radius = 1 with 16 spherical electrodes.</span>
1687         <span class="keyword">case</span> 2;
1688             body_geometry.cylinder = struct;
1689             n_elect = 16;
1690             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1691             <span class="keyword">for</span> i = 1:n_elect
1692                 electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
1693                 electrode_geometry{i}.sphere.radius = 0.1;
1694             <span class="keyword">end</span>
1695             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1696         <span class="comment">% Simple 3D cylinder. Radius = 1 with 16 cylindrical electrodes.</span>
1697         <span class="keyword">case</span> 3;
1698             body_geometry.cylinder = struct;
1699             n_elect = 16;
1700             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1701             <span class="keyword">for</span> i = 1:n_elect
1702                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1703                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1704                 electrode_geometry{i}.cylinder.radius = 0.1;
1705             <span class="keyword">end</span>
1706             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1707         <span class="keyword">case</span> 4;
1708             body_geometry.cylinder = struct;
1709             n_elect = 16;
1710             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1711             <span class="keyword">for</span> i = 1:n_elect
1712                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1713                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1714                 electrode_geometry{i}.cylinder.radius = 0.1;
1715                 electrode_geometry{i}.keep_material_flag = 1;
1716             <span class="keyword">end</span>
1717             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1718         <span class="keyword">case</span> 5;
1719             body_geometry.cylinder = struct;
1720             n_elect = 16;
1721             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1722             <span class="keyword">for</span> i = 1:n_elect
1723                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1724                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1725                 electrode_geometry{i}.cylinder.radius = 0.1;
1726                 electrode_geometry{i}.enter_body_flag = 1;
1727             <span class="keyword">end</span>
1728             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1729         <span class="keyword">case</span> 6;
1730             body_geometry.cylinder = struct;
1731             n_elect = 16;
1732             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1733             <span class="keyword">for</span> i = 1:n_elect
1734                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1735                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1736                 electrode_geometry{i}.cylinder.radius = 0.1;
1737                 electrode_geometry{i}.keep_material_flag = 1;
1738                 electrode_geometry{i}.enter_body_flag = 1;                
1739             <span class="keyword">end</span>
1740             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1741         <span class="keyword">case</span> 7;
1742             body_geometry.cylinder = struct;
1743             body_geometry.sphere.center = [0 0 1];
1744             n_elect = 16;
1745             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1746             <span class="keyword">for</span> i = 1:n_elect
1747                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1748                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1749                 electrode_geometry{i}.cylinder.radius = 0.1;
1750             <span class="keyword">end</span>
1751             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1752         <span class="keyword">case</span> 8;
1753             body_geometry.cylinder  = struct;
1754             body_geometry.sphere(1) = struct;  
1755             body_geometry.sphere(2).center = [0 0 1];         
1756             n_elect = 16;
1757             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1758             <span class="keyword">for</span> i = 1:n_elect
1759                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1760                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1761                 electrode_geometry{i}.cylinder.radius = 0.1;
1762             <span class="keyword">end</span>
1763             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);   
1764         <span class="keyword">case</span> 9;
1765             body_geometry.intersection.cylinder(1) = struct;
1766             body_geometry.intersection.cylinder(2).radius     = 0.5;
1767             body_geometry.intersection.cylinder(2).complement_flag = 1;   
1768             n_elect = 16;
1769             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1770             <span class="keyword">for</span> i = 1:n_elect
1771                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1772                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1773                 electrode_geometry{i}.cylinder.radius = 0.1;
1774             <span class="keyword">end</span>
1775             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1776         <span class="keyword">case</span> 10;
1777             body_geometry.intersection(1).sphere(1).radius     = 0.5;
1778             body_geometry.intersection(1).sphere(1).center     = [0 0 2];
1779             body_geometry.intersection(1).sphere(1).complement_flag = 1;
1780             body_geometry.intersection(1).sphere(2).center     = [0 0 2];
1781             body_geometry.intersection(2).cylinder(1).top_center = [0 0 2];
1782             body_geometry.intersection(2).cylinder(2).radius     = 0.5;
1783             body_geometry.intersection(2).cylinder(2).top_center = [0 0 2];
1784             body_geometry.intersection(2).cylinder(2).complement_flag = 1;   
1785             n_elect = 16;
1786             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1787             <span class="keyword">for</span> i = 1:n_elect
1788                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1789                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1790                 electrode_geometry{i}.cylinder.radius = 0.1;
1791             <span class="keyword">end</span>
1792             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1793         <span class="keyword">case</span> 11;
1794             body_geometry.intersection.union(1).sphere.radius = 0.5;
1795             body_geometry.intersection.union(1).sphere.center = [0 0 2];
1796             body_geometry.intersection.union(1).cylinder.radius = 0.5;
1797             body_geometry.intersection.union(1).cylinder.top_center = [0 0 2];
1798             body_geometry.intersection.union(1).complement_flag = 1;
1799             body_geometry.intersection.union(2).sphere.center = [0 0 2];
1800             body_geometry.intersection.union(2).cylinder.top_center = [0 0 2]; 
1801             n_elect = 16;
1802             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1803             <span class="keyword">for</span> i = 1:n_elect
1804                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1805                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1806                 electrode_geometry{i}.cylinder.radius = 0.1;
1807             <span class="keyword">end</span>
1808             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1809         <span class="keyword">case</span> 12;
1810             body_geometry.cone = struct; 
1811             n_elect = 16;
1812             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1813             <span class="keyword">for</span> i = 1:n_elect
1814                 electrode_geometry{i}.cylinder.top_center    = [0.85*cos(theta(i)) 0.85*sin(theta(i)) 0.5];
1815                 electrode_geometry{i}.cylinder.bottom_center = [0.65*cos(theta(i)) 0.65*sin(theta(i)) 0.5];
1816                 electrode_geometry{i}.cylinder.radius = 0.1;
1817             <span class="keyword">end</span>
1818             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1819         <span class="keyword">case</span> 13;
1820             body_geometry.cone = struct; 
1821             n_elect = 16;
1822             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1823             <span class="keyword">for</span> i = 1:n_elect
1824                 electrode_geometry{i}.sphere.center = [0.75*cos(theta(i)) 0.75*sin(theta(i)) 0.5];
1825                 electrode_geometry{i}.sphere.radius = 0.1;
1826             <span class="keyword">end</span>
1827             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1828         <span class="keyword">case</span> 14;
1829             body_geometry.cone(1).top_center = [0 0 1.5];
1830             body_geometry.cone(1).bottom_center = [0 0 0.5];
1831             body_geometry.cone(2).top_center = [0 0 -1.5];
1832             body_geometry.cone(2).bottom_center = [0 0 -0.5];
1833             body_geometry.cylinder.top_center    = [0, 0, 0.5];
1834             body_geometry.cylinder.bottom_center = [0, 0, -0.5];
1835             n_elect = 16;
1836             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1837             <span class="keyword">for</span> i = 1:n_elect
1838                 electrode_geometry{i}.sphere.center = [0.75*cos(theta(i)) 0.75*sin(theta(i)) 1.0];
1839                 electrode_geometry{i}.sphere.radius = 0.1;
1840                 electrode_geometry{i + n_elect}.sphere.center = [cos(theta(i)) sin(theta(i)) 0];
1841                 electrode_geometry{i + n_elect}.sphere.radius = 0.15;
1842                 electrode_geometry{i + 2*n_elect}.sphere.center = [0.75*cos(theta(i)) 0.75*sin(theta(i)) -1.0];
1843                 electrode_geometry{i + 2*n_elect}.sphere.radius = 0.1;
1844             <span class="keyword">end</span>
1845             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1846             opts.edge.significant.angle = 15;
1847         <span class="keyword">case</span> 15
1848             body_geometry.ortho_brick = struct;
1849             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1850         <span class="keyword">case</span> 16
1851             body_geometry.intersection.ortho_brick.opposite_corner_a = [0 0 0];
1852             body_geometry.intersection.ortho_brick.opposite_corner_b = [5 5 4];
1853             <span class="keyword">for</span> i = 1:4; 
1854                 <span class="keyword">for</span> j = 1:4; 
1855                     body_geometry.intersection.cylinder(i,j).radius = 0.15;
1856                     body_geometry.intersection.cylinder(i,j).top_center = [i, j, 4];
1857                     body_geometry.intersection.cylinder(i,j).bottom_center = [i, j, 2];
1858                     body_geometry.intersection.cylinder(i,j).complement_flag = 1;
1859                 <span class="keyword">end</span>; 
1860             <span class="keyword">end</span>;
1861             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);    
1862         <span class="keyword">case</span> 17
1863             body_geometry.intersection.ortho_brick.opposite_corner_a = [0 0 0];
1864             body_geometry.intersection.ortho_brick.opposite_corner_b = [5 5 4];
1865             <span class="keyword">for</span> i = 1:4; 
1866                 <span class="keyword">for</span> j = 1:4; 
1867                     body_geometry.intersection.cylinder(i, j).radius = 0.15;
1868                     body_geometry.intersection.cylinder(i, j).top_center    = [i, j, 4];
1869                     body_geometry.intersection.cylinder(i, j).bottom_center = [i, j, 2];
1870                     body_geometry.intersection.cylinder(i, j).complement_flag = 1;
1871                     electrode_geometry{i, j, 1}.cylinder.radius        = 0.2;
1872                     electrode_geometry{i, j, 1}.cylinder.top_center    = [i, j, 3.1];
1873                     electrode_geometry{i, j, 1}.cylinder.bottom_center = [i, j, 2.9];
1874                     electrode_geometry{i, j, 2}.cylinder.radius        = 0.2;
1875                     electrode_geometry{i, j, 2}.cylinder.top_center    = [i, j, 2.2];
1876                     electrode_geometry{i, j, 2}.cylinder.bottom_center = [i, j, 2.0];
1877                 <span class="keyword">end</span>; 
1878             <span class="keyword">end</span>;
1879             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1880         <span class="keyword">case</span> 18
1881             body_geometry.parallelepiped  = struct;
1882             body_geometry.max_edge_length = 0.15;
1883             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1884         <span class="keyword">case</span> 19
1885             body_geometry.parallelepiped.vertex   = [ 0;  0;  0];
1886             body_geometry.parallelepiped.vector_a = [ 1;  1;  0];
1887             body_geometry.parallelepiped.vector_b = [ 0;  1;  1];
1888             body_geometry.parallelepiped.vector_c = [ 1;  0;  1];
1889             body_geometry.max_edge_length = 0.15;
1890             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1891         <span class="keyword">case</span> 20
1892             body_geometry.intersection.ortho_brick.opposite_corner_a = [-15, -15, 0];
1893             body_geometry.intersection.ortho_brick.opposite_corner_b = [15, 15, 5];
1894             body_geometry.intersection.half_space.point = [0, 0, 5];
1895             body_geometry.intersection.half_space.outward_normal_vector = [-1, -1, 5];
1896             
1897             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1898         <span class="keyword">case</span> 21
1899             body_geometry.ellipsoid.axis_a = [1 0 0];
1900             body_geometry.ellipsoid.axis_b = [0 2 0];
1901             body_geometry.ellipsoid.axis_c = [0 0 3];
1902             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);   
1903         <span class="keyword">case</span> 22
1904             body_geometry.ellipsoid.axis_a = [1 0 0];
1905             body_geometry.ellipsoid.axis_b = [0 1 1];
1906             body_geometry.ellipsoid.axis_c = [0 -2 2];
1907             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);   
1908         <span class="keyword">case</span> 23
1909             body_geometry.elliptic_cylinder.top_center = [0, 0, 10];
1910             body_geometry.elliptic_cylinder.bottom_center = [0, 0, 0];           
1911             body_geometry.elliptic_cylinder.axis_a = [1 0 0];
1912             body_geometry.elliptic_cylinder.axis_b = [0 2 0];  
1913             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1914         <span class="keyword">case</span> 24
1915             body_geometry.elliptic_cylinder.top_center = [0, 5, 5];
1916             body_geometry.elliptic_cylinder.bottom_center = [0, 0, 0];           
1917             body_geometry.elliptic_cylinder.axis_a = [1 0 0];
1918             body_geometry.elliptic_cylinder.axis_b = [0 -2 2];  
1919             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1920         <span class="keyword">case</span> 25
1921             body_geometry.body_of_revolution = struct;
1922             body_geometry.max_edge_length = 0.15;
1923             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1924         <span class="keyword">case</span> 26
1925             body_geometry.body_of_revolution.points   = [1 1; 1 2; 2 1.5; 2 1];
1926             body_geometry.body_of_revolution.segments = [1 2; 2 3; 3 4; 4 1];
1927             body_geometry.max_edge_length = 0.15;
1928             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1929         <span class="keyword">case</span> 27
1930             n_points = 24;
1931             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];
1932             body_geometry.body_of_revolution.points   = 2 + [sin(theta) cos(theta)];
1933             body_geometry.body_of_revolution.segments = [(1:n_points)' [(2:n_points) 1]'];
1934             body_geometry.max_edge_length = 0.15;
1935             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1936         <span class="keyword">case</span> 28
1937             n_points = 24;
1938             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];
1939             body_geometry.body_of_revolution.points   = 2 + [sin(theta) cos(theta)];
1940             body_geometry.body_of_revolution.segments = [(1:2:n_points)' (2:2:n_points)' [(3:2:n_points) 1]'];
1941             body_geometry.max_edge_length = 0.15;
1942             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1943         <span class="keyword">case</span> 29
1944             body_geometry{1}.cylinder(1).radius        = 0.5;
1945             body_geometry{1}.cylinder(1).top_center    = [0 0 0.75];
1946             body_geometry{1}.cylinder(1).bottom_center = [0 0 0.25];
1947             body_geometry{1}.name                      = <span class="string">'Object'</span>;           
1948             body_geometry{2}.cylinder(2).radius        = 1;
1949             body_geometry{2}.name                      = <span class="string">'Tank'</span>;
1950             n_elect = 16;
1951             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1952             <span class="keyword">for</span> i = 1:n_elect
1953                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1954                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1955                 electrode_geometry{i}.cylinder.radius = 0.1;
1956             <span class="keyword">end</span>
1957             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1958         <span class="keyword">case</span> 30
1959             body_geometry{1}.sphere.radius     = 0.25;
1960             body_geometry{1}.sphere.center     = [0 0 0.5];
1961             body_geometry{1}.name              = <span class="string">'Sphere'</span>;
1962             body_geometry{2}.cylinder.radius   = 1;
1963             body_geometry{2}.name              = <span class="string">'Tank'</span>;           
1964             n_elect = 16;
1965             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1966             <span class="keyword">for</span> i = 1:n_elect
1967                 electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
1968                 electrode_geometry{i}.sphere.radius = 0.1;
1969             <span class="keyword">end</span>
1970             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1971        <span class="keyword">case</span> 31
1972             n_sphere = 8;
1973             theta = linspace(0, 2*pi, n_sphere+1); theta(end) = [];   
1974             <span class="keyword">for</span> i = 1:n_sphere
1975                 body_geometry{i}.sphere.radius   = 0.2;
1976                 body_geometry{i}.sphere.center   = [0.65*cos(theta(i)) 0.65*sin(theta(i)) 0.5];  
1977                 body_geometry{i}.max_edge_length = 0.025*(1 + rem(i,2));
1978                 body_geometry{i}.name            = sprintf(<span class="string">'Sphere%d'</span>, i);  
1979             <span class="keyword">end</span>        
1980             body_geometry{n_sphere+1}.cylinder.radius = 1;
1981             body_geometry{n_sphere+1}.name            = <span class="string">'Tank'</span>;  
1982             n_elect = 16;
1983             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1984             <span class="keyword">for</span> i = 1:n_elect
1985                 electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
1986                 electrode_geometry{i}.sphere.radius = 0.1;
1987                 electrode_geometry{i}.max_edge_length = 0.025*(1 + rem(i,2));
1988             <span class="keyword">end</span>
1989             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1990        <span class="keyword">case</span> 32
1991             body_geometry.cylinder = struct;
1992             n_elect = 16;
1993             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1994             <span class="keyword">for</span> i = 1:n_elect
1995                 electrode_geometry{i}.point = [cos(theta(i)) sin(theta(i)) 0.5];
1996             <span class="keyword">end</span>
1997             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1998        <span class="keyword">case</span> 33     
1999             body_geometry.cylinder = struct;
2000             n_elect = 16;
2001             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
2002             <span class="keyword">for</span> i = 1:n_elect
2003                 <span class="keyword">if</span> (rem(i,2))
2004                     electrode_geometry{i}.point = [cos(theta(i)) sin(theta(i)) 0.5];
2005                     electrode_geometry{i}.name  = sprintf(<span class="string">'Point_Electrode%d'</span>, ceil(i/2));
2006                 <span class="keyword">else</span>
2007                     electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
2008                     electrode_geometry{i}.sphere.radius = 0.1;
2009                     electrode_geometry{i}.name          = sprintf(<span class="string">'Circular_Electrode%d'</span>, floor(i/2));
2010                 <span class="keyword">end</span>
2011             <span class="keyword">end</span>
2012             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
2013        <span class="keyword">case</span> 34
2014             body_geometry.body_of_extrusion = struct;
2015             body_geometry.max_edge_length = 0.15;
2016             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
2017         <span class="keyword">case</span> 35
2018             body_geometry.body_of_extrusion.path_points   = [0 0 0; 0.25 0 1; 0.25 0 2; 0.25 0 3; 0 0 4];
2019             body_geometry.body_of_extrusion.path_segments = [1 2; 2 3; 3 4; 4 5];
2020             body_geometry.max_edge_length = 0.15;
2021             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
2022        <span class="keyword">case</span> 36
2023             n_points = 16;
2024             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];
2025             body_geometry.body_of_extrusion.profile_points   = 0.2*(2 + [0.75*sin(theta) cos(theta)]);
2026             body_geometry.body_of_extrusion.profile_segments = [(1:n_points)' [(2:n_points) 1]'];
2027             n_points = 32;
2028             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];          
2029             body_geometry.body_of_extrusion.path_points   = 1*(2 + [sin(theta) 1.5*cos(theta) zeros(n_points, 1)]);
2030             body_geometry.body_of_extrusion.path_segments = [(1:n_points)' [(2:n_points) 1]'];
2031             body_geometry.body_of_extrusion.vector_d      = [0; 0; 1];
2032             body_geometry.max_edge_length = 0.15;
2033             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry); 
2034         <span class="keyword">case</span> 0; fmdl = 36; <span class="comment">% Return maximum number of tests.</span>
2035         <span class="keyword">otherwise</span>;
2036             error(<span class="string">'Invalid test number.'</span>)
2037     <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>