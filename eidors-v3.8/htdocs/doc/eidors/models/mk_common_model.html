<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_common_model</title>
  <meta name="keywords" content="mk_common_model">
  <meta name="description" content="MK_COMMON_MODEL: make common EIT models">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_common_model.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_common_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_COMMON_MODEL: make common EIT models</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function inv_mdl= mk_common_model( str, n_elec, varargin ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MK_COMMON_MODEL: make common EIT models

 Utility function to create common EIT FEM models,
 so that users do not need to re-write common code

 Usage: 
      inv_mdl = mk_common_model( mdl_string, [n_elec/plane, n_planes])

 2D Models using distmesh (D = show distmesh graphics, d= no graphics)
   mk_common_model('a2d0c',16)  - 2D circ model using distmesh 
   mk_common_model('b2d1c',16)  - 2D circ model using distmesh ~ 1300 elems
   mk_common_model('d2d4c',16)  - 2D circ model using distmesh ~ 3200 elems
      a-j =&gt; mesh density
      2d  =&gt; 2d Distmesh model
      0-4 =&gt; element refinement
      c   =&gt; circular mesh
   mk_common_model('b2d1t2',16)  - 2D circ model using distmesh ~ 1300 elems
       deformed to T2 thorax shape

 2D Models using distmesh using fixed point electrodes (faster but worse refinement)
   mk_common_model('a2d0d',16)  - 2D circ model using distmesh 

 2D Models circular models:
   mk_common_model('a2C',16)   - 2D circ model (64 elems) with 16 elecs
   mk_common_model('b2C',16)   - 2D circ model (256 elems)
   mk_common_model('c2C',16)   - 2D circ model (576 elems)
   mk_common_model('d2C',16)   - 2D circ model (1024 elems)
   mk_common_model('e2C',16)   - 2D circ model (1600 elems)
   mk_common_model('f2C',16)   - 2D circ model (2304 elems)
   mk_common_model('g2C',16)   - 2D circ model (3136 elems)
   mk_common_model('h2C',16)   - 2D circ model (4096 elems)
   mk_common_model('i2C',16)   - 2D circ model (5184 elems)
   mk_common_model('j2C',16)   - 2D circ model (6400 elems)

   models with 'c' are point electrode models, 
   models with 'C' use the complete electrode model (with 2 nodes/elec)

   models ??c or ??c0 are rotated by zero.
   models ??c1, ??c2, ??c3 are rotated by 22.5, 45, 67.5 degrees

 2D Thorax models (levels 1 - 5 from shoulders to abdomen)
   mk_common_model('b2t2',16)  - 2D Thorax#2 (chest) (256 elems)
   mk_common_model('c2t4',16)  - 2D Thorax#3 (upper abdomen) (576 elems)
   - all t1-t5 are available for each a-f models

 2D square models:
   mk_common_model('a2s',8)   - 2D square model (4x4x2 elems) (max 8 elecs)
   mk_common_model('b2s',16)  - 2D square model (8x8x2 elems) (16 elecs)
   mk_common_model('c2s',16)  - 2D square model (16x16x2 elems)
   mk_common_model('d2s',16)  - 2D square model (24x24x2 elems)
   mk_common_model('e2s',16)  - 2D square model (32x32x2 elems)
   mk_common_model('f2s',16)  - 2D square model (40x40x2 elems)
   mk_common_model('g2s',16)  - 2D square model (56x56x2 elems)
   mk_common_model('h2s',16)  - 2D square model (80x80x2 elems)
   mk_common_model('i2s',16)  - 2D square model (96x96x2 elems)
   mk_common_model('j2s',16)  - 2D square model (144x144x2 elems)
   mk_common_model('k2s',16)  - 2D square model (200x200x2 elems)

   models ??c or ??c0 are rotated by zero.
   models ??c1, ??c2, ??c3 are rotated by 22.5, 45, 67.5 degrees

 3D Models:
   mk_common_model('n3r2',[16,2])  - NP's 3D model with 2 rings of 16 elecs

   mk_common_model('b3cr',[16,3])  - cylinder with 3 rings of 16 elecs
   mk_common_model('b3t2r',[16,1]) - t2 thorax shape with 1 ring of 16 elecs
   mk_common_model('b3cz2',[16,1]) - cylinder with 2 rows of 8
           zigzag pattern elecs. Stimulation treats this as 16x1 pattern
   mk_common_model('b3cp2',16)      - cylinder with 2 rows of 8
           elecs in 'planar' pattern. Stim treats this as 16x1 pattern

   mk_common_model('a3cr',16)      - 64 elems * 4 planes
   mk_common_model('b3cr',16)      - 256 elems * 10 planes 
   mk_common_model('c3cr',16)      - 576 elems * 20 planes
   mk_common_model('d3cr',16)      - 1024 elems * 40 planes
   mk_common_model('e3cr',16)      - 1600 elems * 60 planes
   mk_common_model('f3cr',16)      - 2304 elems * 80 planes</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/deprecated/get_3d_meas.html" class="code" title="function [voltageH,voltageV,indH,indV,df] = get_3d_meas(elec,vtx,V,Ib,no_pl);">get_3d_meas</a>	GET_3D_MEAS: extracts multiplane voltage measurements from a calculated</li><li><a href="../../eidors/deprecated/set_3d_currents.html" class="code" title="function [I,Ib] = set_3d_currents(protocol,elec,vtx,gnd_ind,no_pl);">set_3d_currents</a>	function [I,Ib]=set_3d_currents(protocol,elec,vtx,gnd_ind,no_pl);</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../eidors/meshing/distmesh/dm_2d_circ_pt_elecs.html" class="code" title="function fmdl = dm_2d_circ_pt_elecs( elec_pts, pfix, spacing);">dm_2d_circ_pt_elecs</a>	DM_2D_CIRC_PT_ELECS: Create circle mesh (or radius 1) refined with electrodes</li><li><a href="../../eidors/meshing/distmesh/dm_mk_elec_nodes.html" class="code" title="function [elec_nodes, refine_nodes] = dm_mk_elec_nodes( elec_posn,elec_width, refine_level);">dm_mk_elec_nodes</a>	DM_MK_ELEC_NODES: create node points for dm_mk_fwd_model</li><li><a href="../../eidors/meshing/distmesh/dm_mk_fwd_model.html" class="code" title="function [fwd_mdl]= dm_mk_fwd_model( fd, fh, nnodes, bbox, elec_nodes,refine_nodes, z_contact, name)">dm_mk_fwd_model</a>	DM_MK_FWD_MODEL: create a fwd_model object using distmesh</li><li><a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>	MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="thorax_geometry.html" class="code" title="function [out1, out2, out3 ] = thorax_geometry(in1,in2);">thorax_geometry</a>	THORAX_GEOMETRY: deform mesh to have a human thorax like shape</li><li><a href="valid_inv_model.html" class="code" title="function [pass, err_str] = valid_fwd_model(imdl)">valid_inv_model</a>	[pass, err_str] = valid_fwd_model(imdl)</li><li><a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="../../eidors/solvers/forward/system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="../../eidors/solvers/inverse/inv_solve_diff_GN_one_step.html" class="code" title="function img= inv_solve_diff_GN_one_step( inv_model, data1, data2)">inv_solve_diff_GN_one_step</a>	INV_SOLVE_DIFF_GN_ONE_STEP inverse solver using approach of Adler&Guardo 1996</li><li><a href="../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model );">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/deprecated/calc_noise_params.html" class="code" title="function params = calc_noise_params(imdl, vh, vi )">calc_noise_params</a>	params = GREIT_noise_params(imdl, homg_voltage, sig_voltage)</li><li><a href="../../eidors/deprecated/manchester_tomography.html" class="code" title="function manchester_tomography( example_no)">manchester_tomography</a>	Example to show reconstructions from</li><li><a href="../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../eidors/examples/compare_2d_algs.html" class="code" title="function [imgr, img]= compare_2d_algs(option,shape);">compare_2d_algs</a>	Compare different 2D reconstructions</li><li><a href="../../eidors/examples/compare_3d_algs.html" class="code" title="function imgr= compare_3d_algs( algno )">compare_3d_algs</a>	Compare different 3D reconstructions</li><li><a href="../../eidors/examples/ex_fwd2d_high_order.html" class="code" title="">ex_fwd2d_high_order</a>	ensure dev/m_crabb/forward_problem is on the path</li><li><a href="../../eidors/examples/ex_fwd3d_high_order.html" class="code" title="">ex_fwd3d_high_order</a>	Make common model, and make an image</li><li><a href="../../eidors/examples/image_2d_algs.html" class="code" title="">image_2d_algs</a>	Based on the 'bubble' data from Eidors2D, use several</li><li><a href="../../eidors/examples/moving_tank_objs.html" class="code" title="function imgs= moving_tank_objs(data_sel, inv_sel, options)">moving_tank_objs</a>	MOVING_TANK_OBJS: create movies of objects moving in tanks</li><li><a href="../../eidors/graphics/matlab/calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="../../eidors/graphics/matlab/crop_model.html" class="code" title="function [fmdl,c2f_idx]= crop_model( axis_handle, fcn_handle );">crop_model</a>	CROP_MODEL: Crop away parts of a fem model</li><li><a href="../../eidors/graphics/matlab/eidors_colourbar.html" class="code" title="function hh= eidors_colourbar(max_scale,ref_lev, cb_shrink_move, greyscale)">eidors_colourbar</a>	EIDORS_COLOURBAR - create an eidors colourbar with scaling to image</li><li><a href="../../eidors/graphics/matlab/mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../eidors/graphics/matlab/print_convert.html" class="code" title="function print_convert(filename, varargin)">print_convert</a>	PRINT_CONVERT: print figures with anti-aliasing and trim them</li><li><a href="../../eidors/graphics/matlab/show_3d_slices.html" class="code" title="function show_3d_slices(img, varargin);">show_3d_slices</a>	show_3d_slices(img, z_cuts, x_cuts, y_cuts, any_cuts)</li><li><a href="../../eidors/graphics/matlab/show_current.html" class="code" title="function quiv = show_current( img, vv )">show_current</a>	SHOW_CURRENT: show current or other quantity defined</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="../../eidors/interface/sigmatome2_filter.html" class="code" title="function [Filter, stim_pattern]= sigmatome2_filter(test);">sigmatome2_filter</a>	SIGMATOME2_FILTER:  Hardware filter and stim_patterns for Sigmatome II device</li><li><a href="../../eidors/meshing/calc_mesh_quality.html" class="code" title="function [Q mdl] = calc_mesh_quality(mdl, show)">calc_mesh_quality</a>	CALC_MESH_QUALITY Various measures of mesh quality.</li><li><a href="analytic_2d_circle.html" class="code" title="function V = analytic_2d_circle(I, params)">analytic_2d_circle</a>	V = analytic_2d_circle(J, [s_h, s_i, b, a, angl])</li><li><a href="data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>	ELEM_DIM: dimension of elements in space (are elements in 2D or 3D space)</li><li><a href="elem_select.html" class="code" title="function memb_frac = elem_select( fmdl, select_fcn )">elem_select</a>	ELEM_SELECT: select element fractions inside a function</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>	[fwd_model] = linear_reorder(fwd_model,ccw)</li><li><a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="mk_c2f_circ_mapping.html" class="code" title="function [mapping failed] = mk_c2f_circ_mapping( mdl, xyzr );">mk_c2f_circ_mapping</a>	MK_C2F_CIRC_MAPPING: create a mapping matrix from circles/spheres to FEM</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F</li><li><a href="num_elecs.html" class="code" title="function num = num_elecs( mdl );">num_elecs</a>	NUM_ELECS: number of electrodes attached to model</li><li><a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>	NUM_NODES: number of elemnts in a (fwd or inv model or image)</li><li><a href="select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="simulate_2d_movement.html" class="code" title="function [vh,vi,xyr_pt]= simulate_2d_movement( n_sims, fmdl, rad_pr, movefcn )">simulate_2d_movement</a>	SIMULATE_2D_MOVEMENT simulate rotational movement in 2D</li><li><a href="simulate_3d_movement.html" class="code" title="function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, fmdl, rad_pr,movefcn )">simulate_3d_movement</a>	SIMULATE_3D_MOVEMENT simulate rotational movement in 3D</li><li><a href="stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>	STIM_MEAS_LIST: mk stimulation pattern from list of electrodes</li><li><a href="test_GREIT_model.html" class="code" title="">test_GREIT_model</a>	</li><li><a href="tet_to_inequal.html" class="code" title="function [A,b]=tet_to_inequal(v,e)">tet_to_inequal</a>	[A,b]=tet_to_inequal(v)</li><li><a href="../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>	CALC_JACOBIAN_BKGND: calculate background image around</li><li><a href="../../eidors/solvers/forward/fem_1st_to_higher_order.html" class="code" title="function [boundary,elems,nodes]=fem_1st_to_higher_order(fwd_model)">fem_1st_to_higher_order</a>	FEM_1ST_TO_HIGH_ORDER:  Modify the FEM for high order FEM called as</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/solvers/forward/fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="../../eidors/solvers/forward/fwd_solve_apparent_resistivity.html" class="code" title="function data =fwd_solve_apparent_resistivity(fwd_model, img)">fwd_solve_apparent_resistivity</a>	fwd_solve_apparent_resistivity: fwd_solve output as apparent resistivity</li><li><a href="../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="../../eidors/solvers/forward/jacobian_perturb.html" class="code" title="function J= jacobian_perturb( fwd_model, img)">jacobian_perturb</a>	JACOBIAN_PERTURB: J= jacobian_perturb( fwd_model, img)</li><li><a href="../../eidors/solvers/forward/system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="../../eidors/solvers/forward/system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../eidors/solvers/get_img_data.html" class="code" title="function [img_data, n_images]= get_img_data(img)">get_img_data</a>	GET_IMG_DATA: get parameter data from eidors image object</li><li><a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../eidors/solvers/inverse/calc_TSVD_RM.html" class="code" title="function RM= calc_TSVD_RM(mdl,hp)">calc_TSVD_RM</a>	CALC_TSVD_RM: Calculated truncated Jacobian SVD reconstruction matrix</li><li><a href="../../eidors/solvers/inverse/calc_noise_figure.html" class="code" title="function [NF,SE] = calc_noise_figure( inv_model, hp, iterations)">calc_noise_figure</a>	CALC_NOISE_FIGURE: calculate the noise amplification (NF) of an algorithm</li><li><a href="../../eidors/solvers/inverse/inv_solve_TSVD.html" class="code" title="function sol = inv_solve_TSVD(inv_model, data1, data2)">inv_solve_TSVD</a>	INV_SOLVE_TSVD: inverse solver based on truncatated SVD</li><li><a href="../../eidors/solvers/inverse/inv_solve_abs_CG.html" class="code" title="function img= inv_solve_abs_CG( inv_model, data1);">inv_solve_abs_CG</a>	function img= inv_solve_abs_CG( inv_model, data1);</li><li><a href="../../eidors/solvers/inverse/inv_solve_abs_GN.html" class="code" title="function img= inv_solve_abs_GN( inv_model, data1);">inv_solve_abs_GN</a>	function img= inv_solve_abs_GN( inv_model, data1);</li><li><a href="../../eidors/solvers/inverse/inv_solve_abs_core.html" class="code" title="function img= inv_solve_abs_core( inv_model, data0);">inv_solve_abs_core</a>	INV_SOLVE_ABS_CORE Absolute solver using a generic iterative algorithm</li><li><a href="../../eidors/solvers/inverse/inv_solve_conj_grad.html" class="code" title="function img= inv_solve_conj_grad( inv_model, data1, data2)">inv_solve_conj_grad</a>	INV_SOLVE_CONJ_GRAD inverse solver based on the CG</li><li><a href="../../eidors/solvers/inverse/inv_solve_time_prior.html" class="code" title="function img= inv_solve_time_prior( inv_model, data1, data2)">inv_solve_time_prior</a>	INV_SOLVE_TIME_PRIOR inverse solver to account for time differences</li><li><a href="../../eidors/solvers/inverse/meas_icov_rm_elecs.html" class="code" title="function meas_icov = meas_icov_rm_elecs( imdl, elec_list)">meas_icov_rm_elecs</a>	MEAS_ICOV_RM_ELECS: remove electrodes from consideration</li><li><a href="../../eidors/solvers/inverse/prior_covar.html" class="code" title="function Reg= prior_covar( inv_model )">prior_covar</a>	PRIOR_COVAR image prior with distance-based interelement covar</li><li><a href="../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model );">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../eidors/tests/calc_jacobian_test.html" class="code" title="function ok= calc_jacobian_test">calc_jacobian_test</a>	Verify Jacobian Calculation by small derivative from forward problem</li><li><a href="../../eidors/tests/calc_model_prior_test.html" class="code" title="function ok= calc_model_prior_test;">calc_model_prior_test</a>	Verify model prior calcs</li><li><a href="../../eidors/tests/perturb_jacobian_test.html" class="code" title="">perturb_jacobian_test</a>	Perturbation Jacobians</li><li><a href="../../eidors/tests/test_c2f_jacobian.html" class="code" title="function test_c2f_jacobian">test_c2f_jacobian</a>	Test calc of jacobian given coarse to fine mapping</li><li><a href="../../eidors/tests/test_colour_direction.html" class="code" title="">test_colour_direction</a>	Test colour mapping</li><li><a href="../../eidors/tests/test_compl_elec_mdl.html" class="code" title="">test_compl_elec_mdl</a>	Test formation of complete electrode model</li><li><a href="../../eidors/tools/test_performance.html" class="code" title="function [r, params] =  test_performance( imdls, fmdl );">test_performance</a>	TEST_PERFORMANCE: test of difference reconstruction algorithms</li><li><a href="../../eidors/tools/test_performance_img.html" class="code" title="function [params_img] =  test_performance_img( imdls, fmdl );">test_performance_img</a>	TEST_PERFORMANCE: test of difference reconstruction algorithms</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function inv_mdl = distmesh_2d_model(str, n_elec, options);</a></li><li><a href="#_sub2" class="code">function inv2d = distmesh_2d_model_depr(str, n_elec, options);</a></li><li><a href="#_sub3" class="code">function inv2d= mk_2c_model( n_elec, n_circles, options )</a></li><li><a href="#_sub4" class="code">function inv2d= mk_2r_model( n_elec, xy_size, options)</a></li><li><a href="#_sub5" class="code">function inv2d= add_params_2d_mdl( params, n_elec, options);</a></li><li><a href="#_sub6" class="code">function inv3d = mk_3c_model( n_elec, xy_layers, z_layers, elec_space,</a></li><li><a href="#_sub7" class="code">function inv_mdl = mk_n3z_model( n_elec, options );</a></li><li><a href="#_sub8" class="code">function inv_mdl = mk_n3r2_model( n_elec, options );</a></li><li><a href="#_sub9" class="code">function inv3d= mk_b3r1_model( n_elec, options )</a></li><li><a href="#_sub10" class="code">function inv3d= mk_b3r2_model( n_elec, nr, options )</a></li><li><a href="#_sub11" class="code">function inv_mdl = rotate_model( inv_mdl, rotate_mdl);</a></li><li><a href="#_sub12" class="code">function inv_mdl = turn_model( inv_mdl, angle );</a></li><li><a href="#_sub13" class="code">function inv_mdl = mk_complete_elec_mdl( inv_mdl, layers);</a></li><li><a href="#_sub14" class="code">function do_unit_test</a></li><li><a href="#_sub15" class="code">function test_np_get_3d_meas</a></li><li><a href="#_sub16" class="code">function test_circ_models</a></li><li><a href="#_sub17" class="code">function test_3d_models</a></li><li><a href="#_sub18" class="code">function test_distmesh_models</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function inv_mdl= mk_common_model( str, n_elec, varargin )</a>
0002 <span class="comment">% MK_COMMON_MODEL: make common EIT models</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Utility function to create common EIT FEM models,</span>
0005 <span class="comment">% so that users do not need to re-write common code</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Usage:</span>
0008 <span class="comment">%      inv_mdl = mk_common_model( mdl_string, [n_elec/plane, n_planes])</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% 2D Models using distmesh (D = show distmesh graphics, d= no graphics)</span>
0011 <span class="comment">%   mk_common_model('a2d0c',16)  - 2D circ model using distmesh</span>
0012 <span class="comment">%   mk_common_model('b2d1c',16)  - 2D circ model using distmesh ~ 1300 elems</span>
0013 <span class="comment">%   mk_common_model('d2d4c',16)  - 2D circ model using distmesh ~ 3200 elems</span>
0014 <span class="comment">%      a-j =&gt; mesh density</span>
0015 <span class="comment">%      2d  =&gt; 2d Distmesh model</span>
0016 <span class="comment">%      0-4 =&gt; element refinement</span>
0017 <span class="comment">%      c   =&gt; circular mesh</span>
0018 <span class="comment">%   mk_common_model('b2d1t2',16)  - 2D circ model using distmesh ~ 1300 elems</span>
0019 <span class="comment">%       deformed to T2 thorax shape</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% 2D Models using distmesh using fixed point electrodes (faster but worse refinement)</span>
0022 <span class="comment">%   mk_common_model('a2d0d',16)  - 2D circ model using distmesh</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% 2D Models circular models:</span>
0025 <span class="comment">%   mk_common_model('a2C',16)   - 2D circ model (64 elems) with 16 elecs</span>
0026 <span class="comment">%   mk_common_model('b2C',16)   - 2D circ model (256 elems)</span>
0027 <span class="comment">%   mk_common_model('c2C',16)   - 2D circ model (576 elems)</span>
0028 <span class="comment">%   mk_common_model('d2C',16)   - 2D circ model (1024 elems)</span>
0029 <span class="comment">%   mk_common_model('e2C',16)   - 2D circ model (1600 elems)</span>
0030 <span class="comment">%   mk_common_model('f2C',16)   - 2D circ model (2304 elems)</span>
0031 <span class="comment">%   mk_common_model('g2C',16)   - 2D circ model (3136 elems)</span>
0032 <span class="comment">%   mk_common_model('h2C',16)   - 2D circ model (4096 elems)</span>
0033 <span class="comment">%   mk_common_model('i2C',16)   - 2D circ model (5184 elems)</span>
0034 <span class="comment">%   mk_common_model('j2C',16)   - 2D circ model (6400 elems)</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%   models with 'c' are point electrode models,</span>
0037 <span class="comment">%   models with 'C' use the complete electrode model (with 2 nodes/elec)</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%   models ??c or ??c0 are rotated by zero.</span>
0040 <span class="comment">%   models ??c1, ??c2, ??c3 are rotated by 22.5, 45, 67.5 degrees</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% 2D Thorax models (levels 1 - 5 from shoulders to abdomen)</span>
0043 <span class="comment">%   mk_common_model('b2t2',16)  - 2D Thorax#2 (chest) (256 elems)</span>
0044 <span class="comment">%   mk_common_model('c2t4',16)  - 2D Thorax#3 (upper abdomen) (576 elems)</span>
0045 <span class="comment">%   - all t1-t5 are available for each a-f models</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% 2D square models:</span>
0048 <span class="comment">%   mk_common_model('a2s',8)   - 2D square model (4x4x2 elems) (max 8 elecs)</span>
0049 <span class="comment">%   mk_common_model('b2s',16)  - 2D square model (8x8x2 elems) (16 elecs)</span>
0050 <span class="comment">%   mk_common_model('c2s',16)  - 2D square model (16x16x2 elems)</span>
0051 <span class="comment">%   mk_common_model('d2s',16)  - 2D square model (24x24x2 elems)</span>
0052 <span class="comment">%   mk_common_model('e2s',16)  - 2D square model (32x32x2 elems)</span>
0053 <span class="comment">%   mk_common_model('f2s',16)  - 2D square model (40x40x2 elems)</span>
0054 <span class="comment">%   mk_common_model('g2s',16)  - 2D square model (56x56x2 elems)</span>
0055 <span class="comment">%   mk_common_model('h2s',16)  - 2D square model (80x80x2 elems)</span>
0056 <span class="comment">%   mk_common_model('i2s',16)  - 2D square model (96x96x2 elems)</span>
0057 <span class="comment">%   mk_common_model('j2s',16)  - 2D square model (144x144x2 elems)</span>
0058 <span class="comment">%   mk_common_model('k2s',16)  - 2D square model (200x200x2 elems)</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%   models ??c or ??c0 are rotated by zero.</span>
0061 <span class="comment">%   models ??c1, ??c2, ??c3 are rotated by 22.5, 45, 67.5 degrees</span>
0062 <span class="comment">%</span>
0063 <span class="comment">% 3D Models:</span>
0064 <span class="comment">%   mk_common_model('n3r2',[16,2])  - NP's 3D model with 2 rings of 16 elecs</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%   mk_common_model('b3cr',[16,3])  - cylinder with 3 rings of 16 elecs</span>
0067 <span class="comment">%   mk_common_model('b3t2r',[16,1]) - t2 thorax shape with 1 ring of 16 elecs</span>
0068 <span class="comment">%   mk_common_model('b3cz2',[16,1]) - cylinder with 2 rows of 8</span>
0069 <span class="comment">%           zigzag pattern elecs. Stimulation treats this as 16x1 pattern</span>
0070 <span class="comment">%   mk_common_model('b3cp2',16)      - cylinder with 2 rows of 8</span>
0071 <span class="comment">%           elecs in 'planar' pattern. Stim treats this as 16x1 pattern</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%   mk_common_model('a3cr',16)      - 64 elems * 4 planes</span>
0074 <span class="comment">%   mk_common_model('b3cr',16)      - 256 elems * 10 planes</span>
0075 <span class="comment">%   mk_common_model('c3cr',16)      - 576 elems * 20 planes</span>
0076 <span class="comment">%   mk_common_model('d3cr',16)      - 1024 elems * 40 planes</span>
0077 <span class="comment">%   mk_common_model('e3cr',16)      - 1600 elems * 60 planes</span>
0078 <span class="comment">%   mk_common_model('f3cr',16)      - 2304 elems * 80 planes</span>
0079 
0080 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0081 <span class="comment">% $Id: mk_common_model.m 4872 2015-04-10 06:37:03Z alistair_boyle $</span>
0082 
0083 <span class="keyword">if</span> isstr(str) &amp;&amp; strcmp(str,<span class="string">'UNIT_TEST'</span>); <a href="#_sub14" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0084 
0085 
0086 options = {<span class="string">'no_meas_current'</span>,<span class="string">'no_rotate_meas'</span>};
0087 <span class="comment">% n_elec is number of [elec/ring n_rings]</span>
0088 <span class="keyword">if</span> nargin&lt;2
0089     n_elec= [16,1]; <span class="comment">% default</span>
0090 <span class="keyword">end</span>
0091 <span class="keyword">if</span> length(n_elec)==1
0092     n_elec= [n_elec,1]; <span class="comment">% default</span>
0093 <span class="keyword">end</span>
0094     
0095 <span class="keyword">if</span> length(str)&lt;3
0096    error(<span class="string">'format specified not recognized'</span>)
0097 <span class="keyword">end</span>
0098 
0099 <span class="keyword">if</span> strcmp(str(2:3),<span class="string">'2c'</span>) || strcmp(str(2:3),<span class="string">'2C'</span>)
0100 <span class="comment">% 2D circular models</span>
0101    <span class="keyword">switch</span> str(1)
0102       <span class="keyword">case</span> <span class="string">'a'</span>; layers=  4;
0103       <span class="keyword">case</span> <span class="string">'b'</span>; layers=  8;
0104       <span class="keyword">case</span> <span class="string">'c'</span>; layers= 12;
0105       <span class="keyword">case</span> <span class="string">'d'</span>; layers= 16;
0106       <span class="keyword">case</span> <span class="string">'e'</span>; layers= 20;
0107       <span class="keyword">case</span> <span class="string">'f'</span>; layers= 24;
0108       <span class="keyword">case</span> <span class="string">'g'</span>; layers= 28;
0109       <span class="keyword">case</span> <span class="string">'h'</span>; layers= 32;
0110       <span class="keyword">case</span> <span class="string">'i'</span>; layers= 36;
0111       <span class="keyword">case</span> <span class="string">'j'</span>; layers= 40;
0112       <span class="keyword">case</span> <span class="string">'k'</span>; layers= 44;
0113       <span class="keyword">case</span> <span class="string">'l'</span>; layers= 48;
0114       <span class="keyword">case</span> <span class="string">'m'</span>; layers= 52;
0115       <span class="keyword">otherwise</span>; error([<span class="string">'don`t know what to do with option=%s'</span>,str]);
0116    <span class="keyword">end</span>
0117 
0118    inv_mdl = <a href="#_sub3" class="code" title="subfunction inv2d= mk_2c_model( n_elec, n_circles, options )">mk_2c_model</a>( n_elec, layers, options );   
0119 
0120    <span class="keyword">if</span> length(str)==3; str= [str,<span class="string">'0'</span>];<span class="keyword">end</span>
0121       
0122    inv_mdl = <a href="#_sub11" class="code" title="subfunction inv_mdl = rotate_model( inv_mdl, rotate_mdl);">rotate_model</a>( inv_mdl, str2num(str(4)));
0123 
0124    <span class="keyword">if</span> str(3)==<span class="string">'C'</span> <span class="comment">% complete electrode model</span>
0125       inv_mdl = <a href="#_sub13" class="code" title="subfunction inv_mdl = mk_complete_elec_mdl( inv_mdl, layers);">mk_complete_elec_mdl</a>( inv_mdl, layers);
0126    <span class="keyword">end</span>
0127 
0128 <span class="keyword">elseif</span> lower(str(2:3))==<span class="string">'2d'</span>
0129    <span class="keyword">global</span> distmesh_do_graphics;
0130    <span class="keyword">if</span> str(3)==<span class="string">'d'</span>; distmesh_do_graphics= 0;
0131    <span class="keyword">else</span>          ; distmesh_do_graphics= 1;
0132    <span class="keyword">end</span>
0133 
0134    <span class="keyword">switch</span> str(5)
0135       <span class="keyword">case</span> <span class="string">'d'</span> <span class="comment">% Deprecated circle functions</span>
0136          inv_mdl= <a href="#_sub2" class="code" title="subfunction inv2d = distmesh_2d_model_depr(str, n_elec, options);">distmesh_2d_model_depr</a>(str, n_elec, options);
0137       <span class="keyword">case</span> <span class="string">'c'</span>
0138          inv_mdl= <a href="#_sub1" class="code" title="subfunction inv_mdl = distmesh_2d_model(str, n_elec, options);">distmesh_2d_model</a>(str, n_elec, options);
0139       <span class="keyword">case</span> <span class="string">'t'</span>
0140          inv_mdl= <a href="#_sub1" class="code" title="subfunction inv_mdl = distmesh_2d_model(str, n_elec, options);">distmesh_2d_model</a>(str, n_elec, options);
0141          inv_mdl.fwd_model = <a href="thorax_geometry.html" class="code" title="function [out1, out2, out3 ] = thorax_geometry(in1,in2);">thorax_geometry</a>( inv_mdl.fwd_model, str2num(str(6)));
0142       <span class="keyword">otherwise</span>;
0143          error([<span class="string">'can''t parse command string:'</span>, str]);
0144    <span class="keyword">end</span>
0145 <span class="keyword">elseif</span> str(2:3)==<span class="string">'2s'</span>
0146 <span class="comment">% 2D square models</span>
0147    <span class="keyword">if</span>     str(1)==<span class="string">'a'</span>; layers=  4;
0148    <span class="keyword">elseif</span> str(1)==<span class="string">'b'</span>; layers=  8;
0149    <span class="keyword">elseif</span> str(1)==<span class="string">'c'</span>; layers= 16;
0150    <span class="keyword">elseif</span> str(1)==<span class="string">'d'</span>; layers= 24;
0151    <span class="keyword">elseif</span> str(1)==<span class="string">'e'</span>; layers= 32;
0152    <span class="keyword">elseif</span> str(1)==<span class="string">'f'</span>; layers= 40;
0153    <span class="keyword">elseif</span> str(1)==<span class="string">'g'</span>; layers= 56;
0154    <span class="keyword">elseif</span> str(1)==<span class="string">'h'</span>; layers= 80;
0155    <span class="keyword">elseif</span> str(1)==<span class="string">'i'</span>; layers= 96;
0156    <span class="keyword">elseif</span> str(1)==<span class="string">'j'</span>; layers= 144;
0157    <span class="keyword">elseif</span> str(1)==<span class="string">'k'</span>; layers= 200;
0158    <span class="keyword">else</span>;  error(<span class="string">'don`t know what to do with option=%s'</span>,str);
0159    <span class="keyword">end</span>
0160 
0161    <span class="keyword">if</span> rem( layers, n_elec(1)/2)~=0; 
0162       error(<span class="string">'the %s model can`t support %d electrodes'</span>,str,n_elec(1));
0163    <span class="keyword">end</span>
0164    inv_mdl = <a href="#_sub4" class="code" title="subfunction inv2d= mk_2r_model( n_elec, xy_size, options)">mk_2r_model</a>( n_elec, layers, options);
0165 
0166 <span class="keyword">elseif</span> ( strcmp(str(2:3),<span class="string">'2t'</span>) || strcmp(str(2:3),<span class="string">'2T'</span>)) &amp;&amp; length(str)==4
0167    <span class="keyword">if</span>     str(1)==<span class="string">'a'</span>; layers=  4;
0168    <span class="keyword">elseif</span> str(1)==<span class="string">'b'</span>; layers=  8;
0169    <span class="keyword">elseif</span> str(1)==<span class="string">'c'</span>; layers= 12;
0170    <span class="keyword">elseif</span> str(1)==<span class="string">'d'</span>; layers= 16;
0171    <span class="keyword">elseif</span> str(1)==<span class="string">'e'</span>; layers= 20;
0172    <span class="keyword">elseif</span> str(1)==<span class="string">'f'</span>; layers= 24;
0173    <span class="keyword">elseif</span> str(1)==<span class="string">'g'</span>; layers= 28;
0174    <span class="keyword">elseif</span> str(1)==<span class="string">'h'</span>; layers= 32;
0175    <span class="keyword">elseif</span> str(1)==<span class="string">'i'</span>; layers= 36;
0176    <span class="keyword">elseif</span> str(1)==<span class="string">'j'</span>; layers= 40;
0177    <span class="keyword">else</span>;  error([<span class="string">'don`t know what to do with option(1)='</span>,str]);
0178    <span class="keyword">end</span>
0179 
0180    inv_mdl = <a href="#_sub3" class="code" title="subfunction inv2d= mk_2c_model( n_elec, n_circles, options )">mk_2c_model</a>( n_elec, layers, options );   
0181    inv_mdl = <a href="#_sub11" class="code" title="subfunction inv_mdl = rotate_model( inv_mdl, rotate_mdl);">rotate_model</a>( inv_mdl, 2); <span class="comment">% 45 degrees</span>
0182 
0183    <span class="keyword">if</span> length(str)==0; str= [str,<span class="string">' '</span>];<span class="keyword">end</span>
0184 
0185    <span class="keyword">if</span> str(3)==<span class="string">'T'</span> <span class="comment">% complete electrode model</span>
0186       inv_mdl = <a href="#_sub13" class="code" title="subfunction inv_mdl = mk_complete_elec_mdl( inv_mdl, layers);">mk_complete_elec_mdl</a>( inv_mdl, layers);
0187    <span class="keyword">end</span>
0188       
0189    inv_mdl.fwd_model = <a href="thorax_geometry.html" class="code" title="function [out1, out2, out3 ] = thorax_geometry(in1,in2);">thorax_geometry</a>( inv_mdl.fwd_model, str2num(str(4)));
0190 
0191 <span class="keyword">elseif</span> strcmp( str, <span class="string">'n3r2'</span>)
0192     inv_mdl = <a href="#_sub8" class="code" title="subfunction inv_mdl = mk_n3r2_model( n_elec, options );">mk_n3r2_model</a>( n_elec, options );
0193 <span class="keyword">elseif</span> strcmp( str, <span class="string">'n3z'</span>) || strcmp(str, <span class="string">'n3z2'</span>)
0194     inv_mdl = <a href="#_sub7" class="code" title="subfunction inv_mdl = mk_n3z_model( n_elec, options );">mk_n3z_model</a>( n_elec, options );
0195 <span class="keyword">elseif</span> strcmp( str(2:3), <span class="string">'3c'</span>) || strcmp(str(2:3),<span class="string">'3t'</span>)
0196    <span class="keyword">if</span>     str(1)==<span class="string">'a'</span>; xy_layers=  4; z_layers= linspace(-.5,.5,5);
0197    <span class="keyword">elseif</span> str(1)==<span class="string">'b'</span>; xy_layers=  8; z_layers= linspace(-.7,.7,11);
0198    <span class="keyword">elseif</span> str(1)==<span class="string">'c'</span>; xy_layers= 12; z_layers= linspace(-.9,.9,21);
0199    <span class="keyword">elseif</span> str(1)==<span class="string">'d'</span>; xy_layers= 16; z_layers= linspace(-1,1,41);
0200    <span class="keyword">elseif</span> str(1)==<span class="string">'e'</span>; xy_layers= 20; z_layers= linspace(-1.3,1.3,61);
0201    <span class="keyword">elseif</span> str(1)==<span class="string">'f'</span>; xy_layers= 24; z_layers= linspace(-1.6,1.6,81);
0202    <span class="keyword">else</span>;  error([<span class="string">'don`t know what to do with option(1)='</span>,str]);
0203    <span class="keyword">end</span>
0204 
0205    <span class="keyword">if</span> str(3)== <span class="string">'c'</span>
0206       elec_cfg_str= str(4:end);
0207    <span class="keyword">elseif</span> str(3) == <span class="string">'t'</span>
0208       elec_cfg_str= str(5:end);
0209    <span class="keyword">else</span>
0210       error([<span class="string">'don`t know what to do with option(3)='</span>,str]);
0211    <span class="keyword">end</span>
0212 
0213    elec_per_plane = n_elec(1);
0214    spacing=.5;
0215    <span class="keyword">if</span>     elec_cfg_str==<span class="string">'r'</span>;
0216       elec_conf= <span class="string">'planes'</span>;
0217       ne_1  = (n_elec(2)-1)/2;
0218       elec_space= [ne_1:-1:-ne_1]*spacing;
0219    <span class="keyword">elseif</span> elec_cfg_str==<span class="string">'z2'</span>;
0220       elec_conf= <span class="string">'zigzag'</span>;
0221       elec_space= [1,-1]*spacing/2;
0222    <span class="keyword">elseif</span> elec_cfg_str==<span class="string">'p2'</span>;
0223       elec_conf= <span class="string">'planes'</span>;
0224       elec_space= [1,-1]*spacing/2;
0225       elec_per_plane = n_elec(1)/2;
0226    <span class="keyword">else</span>;
0227       error([<span class="string">'don`t know what to do with option(4)='</span>,str]);
0228    <span class="keyword">end</span>
0229 
0230    inv_mdl = <a href="#_sub6" class="code" title="subfunction inv3d = mk_3c_model( n_elec, xy_layers, z_layers, elec_space, ">mk_3c_model</a>( n_elec, xy_layers, z_layers, elec_space, <span class="keyword">...</span>
0231                               elec_per_plane, elec_conf, options );
0232 
0233    <span class="keyword">if</span> str(3) == <span class="string">'t'</span> <span class="comment">% thorax models</span>
0234       inv_mdl = <a href="#_sub11" class="code" title="subfunction inv_mdl = rotate_model( inv_mdl, rotate_mdl);">rotate_model</a>( inv_mdl, 2); <span class="comment">% 45 degrees</span>
0235       inv_mdl.fwd_model = <a href="thorax_geometry.html" class="code" title="function [out1, out2, out3 ] = thorax_geometry(in1,in2);">thorax_geometry</a>( inv_mdl.fwd_model, str2num(str(4)));
0236    <span class="keyword">end</span>
0237 <span class="keyword">else</span>
0238     error([<span class="string">'Don`t know what to do with option='</span>,str]);
0239 <span class="keyword">end</span>
0240 
0241 inv_mdl.name= [<span class="string">'EIDORS common_model_'</span>,str]; 
0242 inv_mdl= <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'inv_model'</span>, inv_mdl);
0243 
0244 <span class="comment">% check we are giving back a good specimen</span>
0245 <a href="valid_inv_model.html" class="code" title="function [pass, err_str] = valid_fwd_model(imdl)">valid_inv_model</a>(inv_mdl);
0246     
0247 <a name="_sub1" href="#_subfunctions" class="code">function inv_mdl = distmesh_2d_model(str, n_elec, options);</a>
0248 <span class="comment">% This function is an interface to distmesh_2d_model for some common values</span>
0249 <span class="comment">% fmdl = dm_2d_circ_pt_elecs( elec_pts, pfix, spacing);</span>
0250 <span class="comment">%  params.base_spacing = spacing(1);</span>
0251 <span class="comment">%  params.refine_ratio = spacing(2);</span>
0252 <span class="comment">%  params.gradient     = spacing(3);</span>
0253    Elec_width= 4; <span class="comment">% 2 degrees - electrode width</span>
0254    <span class="keyword">switch</span> [str(1),str(4)]
0255       <span class="keyword">case</span> <span class="string">'j0'</span>; params = [ 55,0,100]./[1000,1,100];
0256       <span class="keyword">case</span> <span class="string">'i0'</span>; params = [ 67,0,100]./[1000,1,100];
0257       <span class="keyword">case</span> <span class="string">'h0'</span>; params = [ 77,0,100]./[1000,1,100];
0258       <span class="keyword">case</span> <span class="string">'g0'</span>; params = [ 87,0,100]./[1000,1,100];
0259       <span class="keyword">case</span> <span class="string">'f0'</span>; params = [100,0,100]./[1000,1,100];
0260       <span class="keyword">case</span> <span class="string">'e0'</span>; params = [120,0,100]./[1000,1,100];
0261       <span class="keyword">case</span> <span class="string">'d0'</span>; params = [150,0,100]./[1000,1,100];
0262       <span class="keyword">case</span> <span class="string">'c0'</span>; params = [200,0,100]./[1000,1,100];
0263       <span class="keyword">case</span> <span class="string">'b0'</span>; params = [270,0,100]./[1000,1,100];
0264       <span class="keyword">case</span> <span class="string">'a0'</span>; params = [500,0,100]./[1000,1,100];
0265 
0266       <span class="keyword">case</span> <span class="string">'j1'</span>; params = [ 21,3,5]./[1000,1,100];
0267       <span class="keyword">case</span> <span class="string">'i1'</span>; params = [ 23,3,5]./[1000,1,100];
0268       <span class="keyword">case</span> <span class="string">'h1'</span>; params = [ 26,3,5]./[1000,1,100];
0269       <span class="keyword">case</span> <span class="string">'g1'</span>; params = [ 30,3,5]./[1000,1,100];
0270       <span class="keyword">case</span> <span class="string">'f1'</span>; params = [ 35,3,5]./[1000,1,100];
0271       <span class="keyword">case</span> <span class="string">'e1'</span>; params = [ 39,3,5]./[1000,1,100];
0272       <span class="keyword">case</span> <span class="string">'d1'</span>; params = [ 54,3,5]./[1000,1,100];
0273       <span class="keyword">case</span> <span class="string">'c1'</span>; params = [100,3,5]./[1000,1,100];
0274       <span class="keyword">case</span> <span class="string">'b1'</span>; params = [180,3,5]./[1000,1,100];
0275       <span class="keyword">case</span> <span class="string">'a1'</span>; params = [400,3,5]./[1000,1,100];
0276 
0277       <span class="keyword">case</span> <span class="string">'j2'</span>; params = [ 12,5,3]./[1000,1,100];
0278       <span class="keyword">case</span> <span class="string">'i2'</span>; params = [ 14,5,3]./[1000,1,100];
0279       <span class="keyword">case</span> <span class="string">'h2'</span>; params = [ 16,5,3]./[1000,1,100];
0280       <span class="keyword">case</span> <span class="string">'g2'</span>; params = [ 19,5,3]./[1000,1,100];
0281       <span class="keyword">case</span> <span class="string">'f2'</span>; params = [ 21,5,3]./[1000,1,100];
0282       <span class="keyword">case</span> <span class="string">'e2'</span>; params = [ 39,5,3]./[1000,1,100];
0283       <span class="keyword">case</span> <span class="string">'d2'</span>; params = [ 50,5,3]./[1000,1,100];
0284       <span class="keyword">case</span> <span class="string">'c2'</span>; params = [100,5,3]./[1000,1,100];
0285       <span class="keyword">case</span> <span class="string">'b2'</span>; params = [200,5,3]./[1000,1,100];
0286       <span class="keyword">case</span> <span class="string">'a2'</span>; params = [500,5,3]./[1000,1,100];
0287 
0288       <span class="keyword">case</span> <span class="string">'j3'</span>; params = [  6,10,2]./[1000,1,100];
0289       <span class="keyword">case</span> <span class="string">'i3'</span>; params = [  7,10,2]./[1000,1,100];
0290       <span class="keyword">case</span> <span class="string">'h3'</span>; params = [  8,10,2]./[1000,1,100];
0291       <span class="keyword">case</span> <span class="string">'g3'</span>; params = [  9,10,2]./[1000,1,100];
0292       <span class="keyword">case</span> <span class="string">'f3'</span>; params = [ 10,10,2]./[1000,1,100];
0293       <span class="keyword">case</span> <span class="string">'e3'</span>; params = [ 13,10,2]./[1000,1,100];
0294       <span class="keyword">case</span> <span class="string">'d3'</span>; params = [ 20,10,2]./[1000,1,100];
0295       <span class="keyword">case</span> <span class="string">'c3'</span>; params = [ 70,10,2]./[1000,1,100];
0296       <span class="keyword">case</span> <span class="string">'b3'</span>; params = [150,10,2]./[1000,1,100];
0297       <span class="keyword">case</span> <span class="string">'a3'</span>; params = [250,10,2]./[1000,1,100];
0298 
0299 <span class="comment">% We set refinement 4==3. This is OK for this mdl density</span>
0300       <span class="keyword">case</span> <span class="string">'j4'</span>; params = [  6,10,2]./[1000,1,100];
0301       <span class="keyword">case</span> <span class="string">'i4'</span>; params = [  7,10,2]./[1000,1,100];
0302       <span class="keyword">case</span> <span class="string">'h4'</span>; params = [  8,10,2]./[1000,1,100];
0303       <span class="keyword">case</span> <span class="string">'g4'</span>; params = [  9,10,2]./[1000,1,100];
0304       <span class="keyword">case</span> <span class="string">'f4'</span>; params = [ 10,10,2]./[1000,1,100];
0305       <span class="keyword">case</span> <span class="string">'e4'</span>; params = [ 13,10,2]./[1000,1,100];
0306       <span class="keyword">case</span> <span class="string">'d4'</span>; params = [ 20,10,2]./[1000,1,100];
0307       <span class="keyword">case</span> <span class="string">'c4'</span>; params = [ 70,10,2]./[1000,1,100];
0308       <span class="keyword">case</span> <span class="string">'b4'</span>; params = [150,10,2]./[1000,1,100];
0309       <span class="keyword">case</span> <span class="string">'a4'</span>; params = [250,10,2]./[1000,1,100];
0310 
0311       <span class="keyword">otherwise</span>; error(<span class="string">'don`t know what to do with option=%s'</span>,str);
0312    <span class="keyword">end</span>
0313    ea = Elec_width/2 *(2*pi/360);
0314    <span class="keyword">for</span> i=1:n_elec(1); 
0315      ai = (i-1)/n_elec(1) * 2*pi;
0316      elec_pts{i} = [sin(ai+ea),cos(ai+ea);sin(ai-ea),cos(ai-ea)];
0317    <span class="keyword">end</span>
0318    fwd_mdl= <a href="../../eidors/meshing/distmesh/dm_2d_circ_pt_elecs.html" class="code" title="function fmdl = dm_2d_circ_pt_elecs( elec_pts, pfix, spacing);">dm_2d_circ_pt_elecs</a>( elec_pts, [], params);
0319    inv_mdl= <a href="#_sub5" class="code" title="subfunction inv2d= add_params_2d_mdl( params, n_elec, options);">add_params_2d_mdl</a>( fwd_mdl, n_elec(1), options);
0320 
0321 <span class="comment">% THIS FUNCTION IS DEPRECATED (from EIDORS 3.3)</span>
0322 <a name="_sub2" href="#_subfunctions" class="code">function inv2d = distmesh_2d_model_depr(str, n_elec, options);</a>
0323    <span class="keyword">switch</span> str(1)
0324       <span class="keyword">case</span> <span class="string">'a'</span>; n_nodes=  50;
0325       <span class="keyword">case</span> <span class="string">'b'</span>; n_nodes= 100;
0326       <span class="keyword">case</span> <span class="string">'c'</span>; n_nodes= 200;
0327       <span class="keyword">case</span> <span class="string">'d'</span>; n_nodes= 400;
0328       <span class="keyword">case</span> <span class="string">'e'</span>; n_nodes= 800;
0329       <span class="keyword">case</span> <span class="string">'f'</span>; n_nodes=1200;
0330       <span class="keyword">case</span> <span class="string">'g'</span>; n_nodes=1800;
0331       <span class="keyword">case</span> <span class="string">'h'</span>; n_nodes=2400;
0332       <span class="keyword">case</span> <span class="string">'i'</span>; n_nodes=3000;
0333       <span class="keyword">case</span> <span class="string">'j'</span>; n_nodes=4000;
0334       <span class="keyword">otherwise</span>; error(<span class="string">'don`t know what to do with option=%s'</span>,str);
0335    <span class="keyword">end</span>
0336  
0337    refine_level= abs(str(4))-<span class="string">'0'</span>;
0338 
0339    elec_width= .1;
0340    th=linspace(0,2*pi,n_elec(1)+1)';th(end)=[];
0341    elec_posn= [sin(th),cos(th)];
0342    [elec_nodes, refine_nodes] = <a href="../../eidors/meshing/distmesh/dm_mk_elec_nodes.html" class="code" title="function [elec_nodes, refine_nodes] = dm_mk_elec_nodes( elec_posn,elec_width, refine_level);">dm_mk_elec_nodes</a>( elec_posn, <span class="keyword">...</span>
0343           elec_width, refine_level);
0344    fd=inline(<span class="string">'sqrt(sum(p.^2,2))-1'</span>,<span class="string">'p'</span>);
0345    bbox = [-1,-1;1,1];
0346    z_contact = 0.01;
0347    fwd_mdl= <a href="../../eidors/meshing/distmesh/dm_mk_fwd_model.html" class="code" title="function [fwd_mdl]= dm_mk_fwd_model( fd, fh, nnodes, bbox, elec_nodes,refine_nodes, z_contact, name)">dm_mk_fwd_model</a>( fd, [], n_nodes, bbox, <span class="keyword">...</span>
0348                              elec_nodes, refine_nodes, z_contact);
0349 
0350    inv2d= <a href="#_sub5" class="code" title="subfunction inv2d= add_params_2d_mdl( params, n_elec, options);">add_params_2d_mdl</a>( fwd_mdl, n_elec(1), options);
0351 
0352 
0353 <a name="_sub3" href="#_subfunctions" class="code">function inv2d= mk_2c_model( n_elec, n_circles, options )</a>
0354 
0355     n_elec= n_elec(1);
0356     params= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>(n_circles, [], n_elec); 
0357     inv2d= <a href="#_sub5" class="code" title="subfunction inv2d= add_params_2d_mdl( params, n_elec, options);">add_params_2d_mdl</a>( params, n_elec, options);
0358    
0359 
0360 <a name="_sub4" href="#_subfunctions" class="code">function inv2d= mk_2r_model( n_elec, xy_size, options)</a>
0361     <span class="keyword">if</span> length(xy_size)==1; xy_size= xy_size*[1,1]; <span class="keyword">end</span>
0362     xy_size= xy_size+1;
0363 
0364     xvec = linspace(-1,1,xy_size(1));
0365     yvec = linspace(-1,1,xy_size(2));
0366     fmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],xvec,yvec);
0367 
0368     <span class="comment">% put 1/4 of elecs on each side</span>
0369     tb_elecs= linspace(1, xy_size(1), 1+2*n_elec(1)/4); 
0370     tb_elecs= tb_elecs(2:2:end);
0371     sd_elecs= linspace(1, xy_size(2), 1+2*n_elec(1)/4);
0372     sd_elecs= sd_elecs(2:2:end);
0373     
0374     el_nodes= [];
0375     <span class="comment">% Top nodes -left to right</span>
0376     bdy_nodes= (1:xy_size(1)) + xy_size(1)*(xy_size(2)-1); 
0377     el_nodes= [el_nodes, bdy_nodes(tb_elecs)];
0378     <span class="comment">% Right nodes - top to bottom</span>
0379     bdy_nodes= (1:xy_size(2))*xy_size(1); 
0380     el_nodes= [el_nodes, bdy_nodes(fliplr(sd_elecs))];
0381     <span class="comment">% Bottom nodes - right to left</span>
0382     bdy_nodes= 1:xy_size(1); 
0383     el_nodes= [el_nodes, bdy_nodes(fliplr(tb_elecs))];
0384     <span class="comment">% Left nodes - bottom to top</span>
0385     bdy_nodes= (0:xy_size(2)-1)*xy_size(1)+1; 
0386     el_nodes= [el_nodes, bdy_nodes(sd_elecs)];
0387 
0388 <span class="comment">%   trimesh(fmdl.elems,fmdl.nodes(:,1), fmdl.nodes(:,2));</span>
0389     <span class="keyword">for</span> i=1:n_elec(1)
0390        n= el_nodes(i);
0391        fmdl.electrode(i).nodes= n;
0392        fmdl.electrode(i).z_contact= .001; <span class="comment">% choose a low value</span>
0393 <span class="comment">%      plot(fmdl.nodes(n,1),fmdl.nodes(n,2),'*'); pause;</span>
0394     <span class="keyword">end</span>
0395     inv2d= <a href="#_sub5" class="code" title="subfunction inv2d= add_params_2d_mdl( params, n_elec, options);">add_params_2d_mdl</a>( fmdl, n_elec(1), options);
0396 
0397 <span class="comment">% params is the part of the fwd_model</span>
0398 <a name="_sub5" href="#_subfunctions" class="code">function inv2d= add_params_2d_mdl( params, n_elec, options);</a>
0399     n_rings= 1;
0400     [st, els]= <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(n_elec, n_rings, <span class="string">'{ad}'</span>,<span class="string">'{ad}'</span>, options, 10);
0401     params.stimulation= st;
0402     params.meas_select= els;
0403     params.solve=      <span class="string">'eidors_default'</span>;
0404     params.system_mat= <span class="string">'eidors_default'</span>;
0405     params.jacobian=   <span class="string">'eidors_default'</span>;
0406     params.normalize_measurements= 0;
0407     mdl_2d   = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, params);
0408 
0409     inv2d.solve=       <span class="string">'eidors_default'</span>;
0410     inv2d.hyperparameter.value = 3e-2;
0411     <span class="comment">%inv2d.hyperparameter.func = 'choose_noise_figure';</span>
0412     <span class="comment">%inv2d.hyperparameter.noise_figure= 1;</span>
0413     <span class="comment">%inv2d.hyperparameter.tgt_elems= 1:4;</span>
0414      inv2d.RtR_prior= <span class="string">'eidors_default'</span>;
0415     <span class="comment">%inv2d.RtR_prior= 'prior_gaussian_HPF';</span>
0416     inv2d.jacobian_bkgnd.value= 1;
0417     inv2d.reconst_type= <span class="string">'difference'</span>;
0418     inv2d.fwd_model= mdl_2d;
0419 
0420 <a name="_sub6" href="#_subfunctions" class="code">function inv3d = mk_3c_model( n_elec, xy_layers, z_layers, elec_space, </a><span class="keyword">...</span>
0421                               elec_per_plane, elec_conf, options );
0422 
0423     e_layers=[];
0424     <span class="keyword">for</span> es= elec_space;
0425        ff= abs(z_layers  -es);
0426        ff= find(ff==min(ff));
0427        e_layers= [e_layers,ff(1)];
0428     <span class="keyword">end</span>
0429 
0430     params= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>( xy_layers, z_layers, <span class="keyword">...</span>
0431            { elec_conf, elec_per_plane, e_layers} );
0432 
0433     [st, els]= <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(n_elec(1), n_elec(2), <span class="string">'{ad}'</span>,<span class="string">'{ad}'</span>, options, 10);
0434 
0435     params.stimulation= st;
0436     params.meas_select= els;
0437     params.solve=      <span class="string">'eidors_default'</span>;
0438     params.system_mat= <span class="string">'eidors_default'</span>;
0439     params.jacobian=   <span class="string">'eidors_default'</span>;
0440     params.normalize_measurements= 0;
0441     fm3d = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, params);
0442 
0443     inv3d.name=  <span class="string">'EIT inverse: 3D'</span>;
0444     inv3d.solve= <span class="string">'eidors_default'</span>;
0445     inv3d.RtR_prior= <span class="string">'eidors_default'</span>;
0446 <span class="comment">%     inv3d.inv_solve_time_prior.time_steps=   0;</span>
0447 <span class="comment">%     inv3d.prior_time_smooth.space_prior = @prior_noser;</span>
0448 <span class="comment">%     inv3d.prior_time_smooth.time_weight = 0;</span>
0449 <span class="comment">%     inv3d.inv_solve_time_prior.time_steps   = 0;</span>
0450 
0451     inv3d.hyperparameter.value = 3e-2;
0452     inv3d.reconst_type= <span class="string">'difference'</span>;
0453     inv3d.jacobian_bkgnd.value= 1;
0454     inv3d.fwd_model= fm3d;
0455 
0456 <a name="_sub7" href="#_subfunctions" class="code">function inv_mdl = mk_n3z_model( n_elec, options );</a>
0457    inv_mdl= <a href="#_sub8" class="code" title="subfunction inv_mdl = mk_n3r2_model( n_elec, options );">mk_n3r2_model</a>( n_elec, options);
0458    fwd_mdl= inv_mdl.fwd_model;
0459    renumber= [1:2:15; 18:2:32];
0460    fwd_mdl.electrode= fwd_mdl.electrode(renumber(:));
0461    n_rings= 1;
0462    [st, els]= <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(n_elec, n_rings, <span class="string">'{ad}'</span>,<span class="string">'{ad}'</span>, options, 10);
0463    fwd_mdl.stimulation= st;
0464    fwd_model.meas_select= els;
0465    inv_mdl.fwd_model= fwd_mdl;
0466    inv_mdl.name= <span class="string">'NP 3D model with zigzag electrodes'</span>;
0467 
0468 <a name="_sub8" href="#_subfunctions" class="code">function inv_mdl = mk_n3r2_model( n_elec, options );</a>
0469    <span class="keyword">if</span> ~isempty(n_elec) <span class="keyword">if</span>  ~all(n_elec == [16,2]);
0470       <span class="keyword">if</span> length(n_elec)~=2; n_elec= [n_elec(1),1]; <span class="keyword">end</span>
0471       warning(sprintf([<span class="string">'You have requested an &quot;n3&quot; model with [%d,%d] electrodes.'</span> <span class="keyword">...</span>
0472          <span class="string">'Note that these models always have 32 electrodes (16x2)'</span>], n_elec));
0473    <span class="keyword">end</span>; <span class="keyword">end</span>
0474    <span class="keyword">if</span> ~exist(<span class="string">'OCTAVE_VERSION'</span>);
0475       load( <span class="string">'datareal.mat'</span> );
0476    <span class="keyword">else</span>
0477       load( file_in_loadpath( <span class="string">'datareal.mat'</span> ));
0478    <span class="keyword">end</span>
0479    fmdl.nodes= vtx;
0480    fmdl.elems= simp;
0481    fmdl.boundary= <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( simp );
0482 
0483    fmdl.solve=      @<a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>;
0484    fmdl.jacobian=   @<a href="../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>;
0485    fmdl.system_mat= @<a href="../../eidors/solvers/forward/system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>;
0486    fmdl.normalize_measurements = 0;
0487 
0488    <span class="keyword">for</span> i=1:length(zc)
0489        electrodes(i).z_contact= zc(i);
0490        electrodes(i).nodes=     unique( elec(i,:) );
0491    <span class="keyword">end</span>
0492 
0493    fmdl.gnd_node=           gnd_ind;
0494    fmdl.electrode =         electrodes;
0495 
0496    fmdl.stimulation = <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,2,[0,1],[0,1], <span class="keyword">...</span>
0497              {<span class="string">'no_meas_current'</span>,<span class="string">'no_rotate_meas'</span>},-1);
0498 
0499    fmdl= <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, fmdl);
0500 
0501    inv_mdl.name=         <span class="string">'Nick Polydorides EIT inverse'</span>;
0502    inv_mdl.solve=       @<a href="../../eidors/solvers/inverse/inv_solve_diff_GN_one_step.html" class="code" title="function img= inv_solve_diff_GN_one_step( inv_model, data1, data2)">inv_solve_diff_GN_one_step</a>;
0503    inv_mdl.hyperparameter.value = 1e-2;
0504    inv_mdl.RtR_prior= @<a href="../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model );">prior_laplace</a>;
0505    inv_mdl.reconst_type= <span class="string">'difference'</span>;
0506    inv_mdl.jacobian_bkgnd.value= 1;
0507    inv_mdl.fwd_model= fmdl;
0508 
0509 
0510 <a name="_sub9" href="#_subfunctions" class="code">function inv3d= mk_b3r1_model( n_elec, options )</a>
0511     n_rings= 1;
0512     levels= [-.5:.1:.5]; 
0513     e_levels= 6; 
0514     nr= 8;
0515 
0516     params= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>( nr, levels, { <span class="string">'planes'</span>, n_elec, e_levels } );
0517     [st, els]= <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(n_elec, n_rings, <span class="string">'{ad}'</span>,<span class="string">'{ad}'</span>, options, 10);
0518 
0519     params.stimulation= st;
0520     params.meas_select= els;
0521     params.solve=      <span class="string">'fwd_solve_1st_order'</span>;
0522     params.system_mat= <span class="string">'system_mat_1st_order'</span>;
0523     params.jacobian=   <span class="string">'jacobian_adjoint'</span>;
0524     params.normalize_measurements= 0;
0525     mdl_3d = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, params);
0526 
0527     inv3d.name = <span class="string">'EIT inverse: 3D'</span>;
0528     inv3d.solve=       <span class="string">'inv_solve_diff_GN_one_step'</span>;
0529     <span class="comment">%inv3d.solve=       'aa_inv_conj_grad';</span>
0530     inv3d.hyperparameter.value = 1e-5;
0531     inv3d.RtR_prior= <span class="string">'prior_laplace'</span>;
0532     <span class="comment">%inv3d.RtR_prior= 'prior_gaussian_HPF';</span>
0533     inv3d.jacobian_bkgnd.value= 1;
0534     inv3d.reconst_type= <span class="string">'difference'</span>;
0535     inv3d.fwd_model= mdl_3d;
0536 
0537 <a name="_sub10" href="#_subfunctions" class="code">function inv3d= mk_b3r2_model( n_elec, nr, options )</a>
0538     n_rings= 2;
0539     z_axis = [0:.1:1];
0540     e_levels= [4,8]; 
0541     nr= 4;
0542     n_elec = 8;
0543    
0544     params= <a href="mk_circ_tank.html" class="code" title="function param= mk_circ_tank(rings, levels, elec_spec );">mk_circ_tank</a>( nr, z_axis, { <span class="string">'planes'</span>, n_elec, e_levels } );
0545     [st, els]= <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(n_elec, n_rings, <span class="string">'{ad}'</span>,<span class="string">'{ad}'</span>, options, 10);
0546 
0547     params.stimulation= st;
0548     params.meas_select= els;
0549     params.solve=      <span class="string">'fwd_solve_1st_order'</span>;
0550     params.system_mat= <span class="string">'system_mat_1st_order'</span>;
0551     params.jacobian=   <span class="string">'jacobian_adjoint'</span>;
0552     params.normalize_measurements= 0;
0553     mdl_3d = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, params);
0554     
0555     <span class="comment">% Specify number of levels in mesh for imaging slices</span>
0556     num_levs = length(e_levels);
0557     levels = inf*ones(num_levs,3);
0558     levels(:,3) = e_levels / (length(z_axis)-1);
0559     levels(:,4) = ones(num_levs,1);
0560     levels(:,5) = (1:num_levs)';    
0561     mdl_3d.levels = levels;
0562     
0563     inv3d.name = <span class="string">'EIT inverse: 3D'</span>;
0564     inv3d.solve=       <span class="string">'inv_solve_diff_GN_one_step'</span>;
0565     <span class="comment">%inv3d.solve=       'aa_inv_conj_grad';</span>
0566     inv3d.hyperparameter.value = 1e-5;
0567     inv3d.RtR_prior= <span class="string">'prior_laplace'</span>;
0568     <span class="comment">%inv3d.RtR_prior= 'prior_gaussian_HPF';</span>
0569     inv3d.jacobian_bkgnd.value= 1;
0570     inv3d.reconst_type= <span class="string">'difference'</span>;
0571     inv3d.fwd_model= mdl_3d;
0572 
0573 <span class="comment">% rotate model rotate_model/16 times around</span>
0574 <a name="_sub11" href="#_subfunctions" class="code">function inv_mdl = rotate_model( inv_mdl, rotate_mdl);</a>
0575     inv_mdl = <a href="#_sub12" class="code" title="subfunction inv_mdl = turn_model( inv_mdl, angle );">turn_model</a>( inv_mdl, pi/8*rotate_mdl );
0576 
0577     n_elec= length( inv_mdl.fwd_model.electrode );
0578     renum = rem(  rotate_mdl*n_elec/16 + (0:n_elec-1),n_elec)+1;
0579     renum = floor(renum); <span class="comment">% round is not quite right for all model</span>
0580                           <span class="comment">% cases, but no errors.</span>
0581     inv_mdl.fwd_model.electrode = <span class="keyword">...</span>
0582        inv_mdl.fwd_model.electrode( renum);
0583 
0584 <span class="comment">% rotate model rotate_model/16 times around</span>
0585 <a name="_sub12" href="#_subfunctions" class="code">function inv_mdl = turn_model( inv_mdl, angle );</a>
0586     nodes= inv_mdl.fwd_model.nodes;
0587     cos_rot = cos( angle );
0588     sin_rot = sin( angle );
0589     nodes(:,1)= inv_mdl.fwd_model.nodes(:,1:2)*[ cos_rot;-sin_rot];
0590     nodes(:,2)= inv_mdl.fwd_model.nodes(:,1:2)*[ sin_rot; cos_rot];
0591     inv_mdl.fwd_model.nodes= nodes;
0592 
0593 <a name="_sub13" href="#_subfunctions" class="code">function inv_mdl = mk_complete_elec_mdl( inv_mdl, layers);</a>
0594       inv_mdl = <a href="#_sub12" class="code" title="subfunction inv_mdl = turn_model( inv_mdl, angle );">turn_model</a>( inv_mdl, 2*pi/4/layers/2 );
0595 
0596       bdy= inv_mdl.fwd_model.boundary;
0597       <span class="keyword">for</span> i=1:length(inv_mdl.fwd_model.electrode);
0598          enode= inv_mdl.fwd_model.electrode(i).nodes;
0599          ff= find( enode== bdy(:,1) );
0600          inv_mdl.fwd_model.electrode(i).nodes = bdy(ff,:);
0601       <span class="keyword">end</span>
0602 
0603 <span class="comment">%%%%%%%%%%%%%%%%%%%%%% TESTS %%%%%%%%%%%%%%%%%%%%%%%</span>
0604 <a name="_sub14" href="#_subfunctions" class="code">function do_unit_test</a>
0605 
0606 <a href="#_sub16" class="code" title="subfunction test_circ_models">test_circ_models</a>
0607 <a href="#_sub17" class="code" title="subfunction test_3d_models">test_3d_models</a>
0608 <a href="#_sub15" class="code" title="subfunction test_np_get_3d_meas">test_np_get_3d_meas</a>
0609 <a href="#_sub18" class="code" title="subfunction test_distmesh_models">test_distmesh_models</a>
0610 
0611 <a name="_sub15" href="#_subfunctions" class="code">function test_np_get_3d_meas</a>
0612    imdl=<a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); st1=imdl.fwd_model.stimulation;
0613    fmdl = imdl.fwd_model;
0614    
0615    <span class="comment">% get the measurement patterns, only indH is used in this model</span>
0616    <span class="comment">%   here we only want to get the meas pattern from 'get_3d_meas',</span>
0617    <span class="comment">%   not the voltages, so we enter zeros</span>
0618    load( <span class="string">'datareal.mat'</span> );
0619    [I,Ib] = <a href="../../eidors/deprecated/set_3d_currents.html" class="code" title="function [I,Ib] = set_3d_currents(protocol,elec,vtx,gnd_ind,no_pl);">set_3d_currents</a>(protocol, elec, <span class="keyword">...</span>
0620                fmdl.nodes, fmdl.gnd_node, no_pl);
0621    [jnk,jnk,indH,indV,jnk] = <a href="../../eidors/deprecated/get_3d_meas.html" class="code" title="function [voltageH,voltageV,indH,indV,df] = get_3d_meas(elec,vtx,V,Ib,no_pl);">get_3d_meas</a>( elec, <span class="keyword">...</span>
0622             fmdl.nodes, zeros(size(I)), Ib, no_pl );
0623    n_elec= size(elec,1);
0624    n_meas= size(indH,1) / size(Ib,2);
0625    <span class="keyword">for</span> i=1:size(Ib,2)
0626       fmdl.stimulation(i).stimulation= <span class="string">'Amp'</span>;
0627       fmdl.stimulation(i).stim_pattern= Ib(:,i);
0628 
0629       idx= ( 1+ (i-1)*n_meas ):( i*n_meas );
0630       fmdl.stimulation(i).meas_pattern= <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a> ( <span class="keyword">...</span>
0631               (1:n_meas)'*[1,1], <span class="keyword">...</span>
0632               indH( idx, : ), <span class="keyword">...</span>
0633               ones(n_meas,2)*[1,0;0,-1], <span class="keyword">...</span>
0634               n_meas, n_elec );
0635    <span class="keyword">end</span>
0636    st2 = fmdl.stimulation;
0637    
0638 
0639    sp1=[]; sp2=[]; mp1=[]; mp2=[]; 
0640    <span class="keyword">for</span> i=1:32;
0641       sp1= [sp1, st1(i).stim_pattern]; mp1= [mp1, st1(i).meas_pattern];
0642       sp2= [sp2, st2(i).stim_pattern]; mp2= [mp2, st2(i).meas_pattern];
0643    <span class="keyword">end</span>
0644    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'STIM_PAT:'</span>,sp1,sp2);
0645    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'MEAS_PAT:'</span>,mp1,mp2);
0646      
0647       
0648 
0649 <a name="_sub16" href="#_subfunctions" class="code">function test_circ_models</a>
0650 <span class="comment">% 2D Circular Models</span>
0651 <span class="keyword">for</span> j=(<span class="string">'a'</span>+0):(<span class="string">'j'</span>+0)
0652     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(sprintf(<span class="string">'%c2C2'</span>,j),16);
0653     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(sprintf(<span class="string">'%c2c0'</span>,j),16);
0654     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(sprintf(<span class="string">'%c2t3'</span>,j),16);
0655     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(sprintf(<span class="string">'%c2T4'</span>,j),16);
0656 <span class="keyword">end</span>;
0657 
0658 <span class="keyword">for</span> j=(<span class="string">'a'</span>+0):(<span class="string">'f'</span>+0)
0659     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(sprintf(<span class="string">'%c2s'</span>,j),8);
0660 <span class="keyword">end</span>;
0661 
0662 <a name="_sub17" href="#_subfunctions" class="code">function test_3d_models</a>
0663 <span class="comment">% 3D Models:</span>
0664     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]);
0665  <span class="comment">%  mk_common_model('n3z',[16,2]);</span>
0666  
0667     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b3cr'</span>,[16,3]);
0668     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b3t2r'</span>,[16,1]);
0669     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b3cz2'</span>,[16,1]);
0670     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b3cp2'</span>,16);
0671  
0672     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a3cr'</span>,16);
0673     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b3cr'</span>,16);
0674     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c3cr'</span>,16);
0675     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d3cr'</span>,16);
0676 
0677 <a name="_sub18" href="#_subfunctions" class="code">function test_distmesh_models</a>
0678 <span class="comment">% Distmesh models</span>
0679 <span class="keyword">for</span> i=0:4; <span class="keyword">for</span> j=(<span class="string">'a'</span>+0):(<span class="string">'j'</span>+0)
0680     <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(sprintf(<span class="string">'%c2d%dd'</span>,j,i),16);
0681 <span class="keyword">end</span>; <span class="keyword">end</span>
0682</pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>