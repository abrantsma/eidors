<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_tet_c2f</title>
  <meta name="keywords" content="mk_tet_c2f">
  <meta name="description" content="MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_tet_c2f.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_tet_c2f
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [c2f] = mk_tet_c2f(fmdl, rmdl, opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.
 C2F = MK_TET_C2F(FMDL,RMDL) returns in C2F the fraction of volume of
 each element of the fine model FMDL contained in each element of
 the coarse model RMDL.
 Uses CONVHULLN to calculate the volume defined by a set of intersection
 points between individual tet and vox elements.

 C2F = MK_TET_C2F(FMDL,RMDL,OPT) allows specifying options.
 
 Inputs:
   FMDL - a (fine) EIDORS (tet-based) forward model
   RMDL - a (course) EIDORS (tet-based) forward model
   OPT  - an option structure with the following fields and defaults:
      .do_not_scale  - set to true to prevent scaling the models to unit
                       cube before any calculations, including thresholds.
                       Default: false
      .tol_node2tet  - tolerance for determinant &lt;= 0 in testing for
                       points inside tets. Default: eps
      .tol_edge2edge - maximum distance between &quot;intersecting&quot; edges
                       Default: 6*sqrt(3)*eps(a), where a is
                       min(max(abs(fmdl.nodes(:))),max(abs(rmdl.nodes(:)))
      .tol_edge2tri  - minimum value of a barycentric coordinate to 
                       decide a point is lying inside a triangle and not
                       on its edge. Default: eps

 NOTE that for grid-based models, such as returned by MK_GRID_MODEL or
 MK_VOXEL_VOLUME, MK_GRID_C2F is much faster.

 Set eidors_msg 'log level' &lt; 2 to supress output to command line.

 Examples:
     fmdl = ng_mk_cyl_models([2,2,.2],[],[]);
     rmdl = ng_mk_cyl_models([2,2],[],[]);
     c2f  = mk_tet_c2f(fmdl,rmdl);
     h = show_fem(fmdl); set(h,'LineWidth',0.1)
     hold on
     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2);
     hold off

 See also <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">MK_GRID_C2F</a>, <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">FIND_EDGE2EDGE_INTERSECTIONS</a>, CONVHULLN
          <a href="mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping( f_mdl, c_mdl );">MK_COARSE_FINE_MAPPING</a>, <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">POINT_IN_TRIANGLE</a>, EIDORS_MSG</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>	NG_MAKE_CYL_MODELS: create cylindrical models using netgen</li><li><a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>	FIND_EDGE2EDGE_INTERSECTIONS intersections between edges of two models</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping( f_mdl, c_mdl );">mk_coarse_fine_mapping</a>	MK_COARSE_FINE_MAPPING: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>	MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="tet_to_inequal.html" class="code" title="function [A,b]=tet_to_inequal(v,e)">tet_to_inequal</a>	[A,b]=tet_to_inequal(v)</li><li><a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/overloads/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>	C = uniquetol(A,TOL):  unique values in A using tolerance TOL.</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li><li><a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>	MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function c2f = do_mk_tet_c2f(fmdl,rmdl,opt)</a></li><li><a href="#_sub2" class="code">function [intpts, tri2edge, tri2intpt, edge2intpt] = edge2face_intersections(fmdl,rmdl,opt)</a></li><li><a href="#_sub3" class="code">function rnode2tet = get_nodes_in_tets(fmdl,nodes, opt)</a></li><li><a href="#_sub4" class="code">function fmdl = prepare_tet_mdl(fmdl)</a></li><li><a href="#_sub5" class="code">function[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a></li><li><a href="#_sub6" class="code">function [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)</a></li><li><a href="#_sub7" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a></li><li><a href="#_sub8" class="code">function do_unit_test</a></li><li><a href="#_sub9" class="code">function do_small_test</a></li><li><a href="#_sub10" class="code">function do_realistic_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)</a>
0002 <span class="comment">%MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</span>
0003 <span class="comment">% C2F = MK_TET_C2F(FMDL,RMDL) returns in C2F the fraction of volume of</span>
0004 <span class="comment">% each element of the fine model FMDL contained in each element of</span>
0005 <span class="comment">% the coarse model RMDL.</span>
0006 <span class="comment">% Uses CONVHULLN to calculate the volume defined by a set of intersection</span>
0007 <span class="comment">% points between individual tet and vox elements.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% C2F = MK_TET_C2F(FMDL,RMDL,OPT) allows specifying options.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs:</span>
0012 <span class="comment">%   FMDL - a (fine) EIDORS (tet-based) forward model</span>
0013 <span class="comment">%   RMDL - a (course) EIDORS (tet-based) forward model</span>
0014 <span class="comment">%   OPT  - an option structure with the following fields and defaults:</span>
0015 <span class="comment">%      .do_not_scale  - set to true to prevent scaling the models to unit</span>
0016 <span class="comment">%                       cube before any calculations, including thresholds.</span>
0017 <span class="comment">%                       Default: false</span>
0018 <span class="comment">%      .tol_node2tet  - tolerance for determinant &lt;= 0 in testing for</span>
0019 <span class="comment">%                       points inside tets. Default: eps</span>
0020 <span class="comment">%      .tol_edge2edge - maximum distance between &quot;intersecting&quot; edges</span>
0021 <span class="comment">%                       Default: 6*sqrt(3)*eps(a), where a is</span>
0022 <span class="comment">%                       min(max(abs(fmdl.nodes(:))),max(abs(rmdl.nodes(:)))</span>
0023 <span class="comment">%      .tol_edge2tri  - minimum value of a barycentric coordinate to</span>
0024 <span class="comment">%                       decide a point is lying inside a triangle and not</span>
0025 <span class="comment">%                       on its edge. Default: eps</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% NOTE that for grid-based models, such as returned by MK_GRID_MODEL or</span>
0028 <span class="comment">% MK_VOXEL_VOLUME, MK_GRID_C2F is much faster.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Set eidors_msg 'log level' &lt; 2 to supress output to command line.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% Examples:</span>
0033 <span class="comment">%     fmdl = ng_mk_cyl_models([2,2,.2],[],[]);</span>
0034 <span class="comment">%     rmdl = ng_mk_cyl_models([2,2],[],[]);</span>
0035 <span class="comment">%     c2f  = mk_tet_c2f(fmdl,rmdl);</span>
0036 <span class="comment">%     h = show_fem(fmdl); set(h,'LineWidth',0.1)</span>
0037 <span class="comment">%     hold on</span>
0038 <span class="comment">%     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2);</span>
0039 <span class="comment">%     hold off</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% See also MK_GRID_C2F, FIND_EDGE2EDGE_INTERSECTIONS, CONVHULLN</span>
0042 <span class="comment">%          MK_COARSE_FINE_MAPPING, POINT_IN_TRIANGLE, EIDORS_MSG</span>
0043 
0044 
0045 <span class="comment">% (C) 2015 Bartlomiej Grychtol - all rights reserved by Swisstom AG</span>
0046 <span class="comment">% License: GPL version 2 or 3</span>
0047 <span class="comment">% $Id: mk_tet_c2f.m 4986 2015-05-11 20:09:28Z aadler $</span>
0048 
0049 <span class="comment">% &gt;&gt; SWISSTOM CONTRIBUTION &lt;&lt;</span>
0050 
0051 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>), <a href="#_sub8" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0052 <span class="keyword">if</span> nargin &lt; 3
0053    opt = struct();
0054 <span class="keyword">end</span>
0055 
0056 f_elems = size(fmdl.elems,1);
0057 r_elems = size(rmdl.elems,1);
0058 
0059 c2f = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(f_elems,r_elems);
0060 [fmdl,rmdl,fmdl_idx,rmdl_idx] = <a href="#_sub6" class="code" title="subfunction [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)">crop_models</a>(fmdl,rmdl);
0061 
0062 <span class="keyword">if</span> ~(any(fmdl_idx) &amp;&amp; any(rmdl_idx))
0063    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@: models do not overlap, returning all-zeros'</span>);
0064    <span class="keyword">return</span>
0065 <span class="keyword">end</span>
0066 
0067 [fmdl,rmdl] = <a href="#_sub5" class="code" title="subfunction[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)">center_scale_models</a>(fmdl,rmdl, opt);
0068 
0069 opt = <a href="#_sub7" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl, opt);
0070 
0071 
0072 copt.fstr = <span class="string">'mk_tet_c2f'</span>;
0073 
0074 c2f(fmdl_idx,rmdl_idx) = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction c2f = do_mk_tet_c2f(fmdl,rmdl,opt)">do_mk_tet_c2f</a>,{fmdl,rmdl,opt},copt);
0075 
0076 
0077 <a name="_sub1" href="#_subfunctions" class="code">function c2f = do_mk_tet_c2f(fmdl,rmdl,opt)</a>
0078    DEBUG = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_tet_c2f'</span>);
0079    
0080    c2f = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(0,0);
0081    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare fine model...'</span>);
0082    fmdl = <a href="#_sub4" class="code" title="subfunction fmdl = prepare_tet_mdl(fmdl)">prepare_tet_mdl</a>(fmdl);
0083    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0084    
0085    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare course model...'</span>);
0086    rmdl = <a href="#_sub4" class="code" title="subfunction fmdl = prepare_tet_mdl(fmdl)">prepare_tet_mdl</a>(rmdl);
0087    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0088    
0089    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_edge2f_face intersections...'</span>)
0090    [intpts1, fface2redge, fface2intpt1, redge2intpt1] = <span class="keyword">...</span>
0091       <a href="#_sub2" class="code" title="subfunction [intpts, tri2edge, tri2intpt, edge2intpt] = edge2face_intersections(fmdl,rmdl,opt)">edge2face_intersections</a>(fmdl,rmdl,opt);
0092    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, size(intpts1,1)), Inf);
0093 
0094    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_edge2c_face intersections...'</span>)
0095    [intpts2, rface2fedge, rface2intpt2, fedge2intpt2] = <span class="keyword">...</span>
0096       <a href="#_sub2" class="code" title="subfunction [intpts, tri2edge, tri2intpt, edge2intpt] = edge2face_intersections(fmdl,rmdl,opt)">edge2face_intersections</a>(rmdl,fmdl,opt);
0097    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, size(intpts2,1)), Inf);
0098 
0099    pmopt.final_msg = <span class="string">'none'</span>;
0100    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find edge2edge intersections...'</span>,-1,pmopt)
0101    [intpts3, fedge2redge, fedge2intpt3, redge2intpt3] = <span class="keyword">...</span>
0102       <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>(fmdl.edges, fmdl.nodes, <span class="keyword">...</span>
0103                                    rmdl.edges, rmdl.nodes, <span class="keyword">...</span>
0104                                    opt.tol_edge2edge);
0105    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,size(intpts3,1)),Inf);
0106 
0107    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_nodes in f_tets...'</span>);
0108    rnode2ftet = <a href="#_sub3" class="code" title="subfunction rnode2tet = get_nodes_in_tets(fmdl,nodes, opt)">get_nodes_in_tets</a>(fmdl,rmdl.nodes, opt);
0109    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(rnode2ftet)), Inf);
0110    
0111    
0112    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_elems in f_elems...'</span>)
0113    rtet_in_ftet = (double(rmdl.node2elem') * rnode2ftet) == 4;
0114    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(rtet_in_ftet)), Inf);
0115    
0116    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_nodes in c_tets...'</span>);
0117    fnode2rtet = <a href="#_sub3" class="code" title="subfunction rnode2tet = get_nodes_in_tets(fmdl,nodes, opt)">get_nodes_in_tets</a>(rmdl,fmdl.nodes, opt);
0118    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(fnode2rtet)), Inf);
0119 
0120    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_elems in c_elems...'</span>)
0121    ftet_in_rtet = (double(fmdl.node2elem') * fnode2rtet) == 4;
0122    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(ftet_in_rtet)), Inf);
0123    
0124    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find total intersections...'</span>);
0125    e2e = double(rmdl.edge2elem');
0126    rtet2ftet =  double(rmdl.elem2face) * (rface2fedge&gt;0) * fmdl.edge2elem <span class="keyword">...</span>
0127                  | e2e * (fface2redge&gt;0)' * fmdl.elem2face' <span class="keyword">...</span>
0128                  | e2e * fedge2redge' * fmdl.edge2elem;
0129    <span class="comment">% exclude inclusion (dealt with separately)</span>
0130    rtet2ftet = rtet2ftet &amp; ~rtet_in_ftet &amp; ~ftet_in_rtet'; 
0131    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(rtet2ftet)), Inf);
0132 
0133    
0134    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Calculate intersection volumes...'</span>);
0135    <span class="comment">% sparse logical multiplication doesn't exist</span>
0136    rtet2intpt1 = logical(rmdl.edge2elem'*redge2intpt1)';
0137    ftet2intpt1 = logical(fmdl.elem2face *fface2intpt1)';
0138    
0139    rtet2intpt2 = logical(rmdl.elem2face * rface2intpt2)';
0140    ftet2intpt2 = logical(fmdl.edge2elem'* fedge2intpt2)';
0141    
0142    ftet2intpt3 = logical(fmdl.edge2elem'* fedge2intpt3)';
0143    rtet2intpt3 = logical(rmdl.edge2elem'* redge2intpt3)';
0144     
0145    rtet_todo = find(sum(rtet2ftet,2)&gt;0);
0146    C = []; F = []; V = [];
0147    
0148    id = 0; N = length(rtet_todo);
0149    mint = ceil(N/100);
0150    <span class="keyword">for</span> v = rtet_todo'
0151       id = id+1;
0152       <span class="keyword">if</span> mod(id,mint)==0, <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(id/N); <span class="keyword">end</span>
0153       tet_todo = find(rtet2ftet(v,:));
0154       common_intpts1 = bsxfun(@and,rtet2intpt1(:,v), ftet2intpt1(:,tet_todo));
0155       common_intpts2 = bsxfun(@and,rtet2intpt2(:,v), ftet2intpt2(:,tet_todo));
0156       common_intpts3 = bsxfun(@and,rtet2intpt3(:,v), ftet2intpt3(:,tet_todo));
0157       f_nodes     = bsxfun(@and,fnode2rtet(:,v), fmdl.node2elem(:,tet_todo));
0158       r_nodes     = bsxfun(@and,rnode2ftet(:,tet_todo), rmdl.node2elem(:,v));
0159       C = [C; v*ones(numel(tet_todo),1)];
0160       F = [F; tet_todo'];
0161       last_v = numel(V);
0162       V = [V; zeros(numel(tet_todo),1)]; <span class="comment">% pre-allocate</span>
0163       
0164       <span class="keyword">for</span> t = 1:numel(tet_todo)
0165          pts = [ intpts1(common_intpts1(:,t),:);
0166             intpts2(common_intpts2(:,t),:);
0167             intpts3(common_intpts3(:,t),:);
0168             fmdl.nodes(f_nodes(:,t),:);
0169             rmdl.nodes(r_nodes(:,t),:)];
0170          last_v = last_v + 1;
0171          <span class="keyword">try</span>
0172             <span class="comment">% move points to origin (helps for small elements at</span>
0173             <span class="comment">% large coordinates</span>
0174             ctr = mean(pts);
0175             pts = bsxfun(@minus,pts,ctr);
0176             scale = max(abs(pts(:)));
0177             <span class="keyword">if</span> scale == 0 <span class="comment">%happens when there's only one point</span>
0178                <span class="keyword">continue</span>
0179             <span class="keyword">end</span>
0180             <span class="comment">% scale largest coordinate to 1 (helps with precision)</span>
0181             pts = pts ./ scale;
0182             <span class="comment">% force thorough search for initinal simplex and</span>
0183             <span class="comment">% supress precision warnings</span>
0184             [K, V(last_v)] = convhulln(pts,{<span class="string">'Qt Pp Qs'</span>});
0185             V(last_v) = V(last_v) * scale^3; <span class="comment">% undo scaling</span>
0186          <span class="keyword">catch</span> err
0187             ok = false;
0188             <span class="keyword">switch</span> err.identifier
0189                <span class="keyword">case</span> {<span class="string">'MATLAB:qhullmx:DegenerateData'</span>, <span class="string">'MATLAB:qhullmx:UndefinedError'</span>}
0190                   <span class="keyword">if</span> size(pts,1) &gt; 3
0191                      u = <a href="../../eidors/overloads/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>(pts*scale,eps,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>, 1);
0192                      ok = ok | size(u,1) &lt; 4;
0193                   <span class="keyword">end</span>
0194             <span class="keyword">end</span>
0195             <span class="keyword">if</span> ~ok
0196                <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_tet_c2f:convhulln'</span>);
0197                   tet.nodes = fmdl.nodes;
0198                   vox.nodes = rmdl.nodes;
0199                   tet.type = <span class="string">'fwd_model'</span>;
0200                   vox.type = <span class="string">'fwd_model'</span>;
0201                   vox.elems = rmdl.faces(logical(rmdl.elem2face(v,:)),:);
0202                   vox.boundary = vox.elems;
0203                   tet.elems = fmdl.elems(tet_todo(t),:);
0204                   clf
0205                   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(vox)
0206                   hold on
0207                   h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(tet);
0208                   set(h,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>)
0209                   pts = bsxfun(@plus,pts*scale,ctr);
0210                   plot3(pts(:,1),pts(:,2),pts(:,3),<span class="string">'o'</span>);
0211                   hold off
0212                   axis auto
0213                   keyboard
0214                <span class="keyword">else</span>
0215                   fprintf(<span class="string">'\n'</span>);
0216                   <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'convhulln has thrown an error. '</span> <span class="keyword">...</span>
0217                      <span class="string">'Enable eidors_debug on mk_tet_c2f and re-run to see a debug plot'</span>],0);
0218                   rethrow(err);
0219                <span class="keyword">end</span>
0220             <span class="keyword">end</span>
0221          <span class="keyword">end</span>
0222       <span class="keyword">end</span>
0223    <span class="keyword">end</span>
0224    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0225     
0226     c2f = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(F,C,V,size(fmdl.elems,1),size(rmdl.elems,1));
0227     
0228     <span class="comment">% add rtet contained in ftet</span>
0229     <span class="keyword">try</span> rmdl = rmfield(rmdl,<span class="string">'coarse2fine'</span>); <span class="keyword">end</span> <span class="comment">% messes with volume</span>
0230     c2f = c2f + bsxfun(@times, <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(rtet_in_ftet), <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl))';
0231     
0232     <span class="comment">% normalize to tet volume</span>
0233     vol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl);
0234     c2f = bsxfun(@rdivide,c2f,vol);
0235 
0236     <span class="comment">% add tets contained in vox</span>
0237 
0238     c2f = c2f + ftet_in_rtet;
0239 <span class="comment">%-------------------------------------------------------------------------%</span>
0240 <span class="comment">% Calculate intersection points between faces and edges</span>
0241 <a name="_sub2" href="#_subfunctions" class="code">function [intpts, tri2edge, tri2intpt, edge2intpt] = edge2face_intersections(fmdl,rmdl,opt)</a>
0242    N_edges = size(rmdl.edges,1);
0243    N_faces = size(fmdl.faces,1);
0244    
0245    face_bb = zeros(N_faces,6);
0246    face_bb(:,1) = min(reshape(fmdl.nodes(fmdl.faces,1),N_faces,3),[],2);
0247    face_bb(:,2) = max(reshape(fmdl.nodes(fmdl.faces,1),N_faces,3),[],2);
0248    face_bb(:,3) = min(reshape(fmdl.nodes(fmdl.faces,2),N_faces,3),[],2);
0249    face_bb(:,4) = max(reshape(fmdl.nodes(fmdl.faces,2),N_faces,3),[],2);
0250    face_bb(:,5) = min(reshape(fmdl.nodes(fmdl.faces,3),N_faces,3),[],2);
0251    face_bb(:,6) = max(reshape(fmdl.nodes(fmdl.faces,3),N_faces,3),[],2);
0252    
0253    edge_bb = zeros(N_edges,6);
0254    edge_bb(:,1) = min(reshape(rmdl.nodes(rmdl.edges,1),N_edges,2),[],2);
0255    edge_bb(:,2) = max(reshape(rmdl.nodes(rmdl.edges,1),N_edges,2),[],2);
0256    edge_bb(:,3) = min(reshape(rmdl.nodes(rmdl.edges,2),N_edges,2),[],2);
0257    edge_bb(:,4) = max(reshape(rmdl.nodes(rmdl.edges,2),N_edges,2),[],2);
0258    edge_bb(:,5) = min(reshape(rmdl.nodes(rmdl.edges,3),N_edges,2),[],2);
0259    edge_bb(:,6) = max(reshape(rmdl.nodes(rmdl.edges,3),N_edges,2),[],2);
0260    
0261    allocsz = max(N_edges,N_faces);
0262    N_alloc = allocsz;
0263    
0264    intpts = zeros(N_edges,3);
0265    T = zeros(N_edges,1);
0266    E = zeros(N_edges,1);
0267    I = zeros(N_edges,1);
0268   
0269    P1 = rmdl.nodes(rmdl.edges(:,1),:);
0270    P12 = P1 - rmdl.nodes(rmdl.edges(:,2),:);
0271 
0272    
0273    d = sum(fmdl.normals .* fmdl.nodes(fmdl.faces(:,1),:),2);
0274       
0275    mint = ceil(N_edges/100);
0276    
0277    <span class="comment">% for point_in_triangle</span>
0278    v0 = fmdl.nodes(fmdl.faces(:,3),:) - fmdl.nodes(fmdl.faces(:,1),:);
0279    v1 = fmdl.nodes(fmdl.faces(:,2),:) - fmdl.nodes(fmdl.faces(:,1),:);
0280    dot00 = dot(v0, v0, 2);
0281    dot01 = dot(v0, v1, 2);
0282    <span class="comment">% dot02 = dot(v0, v2, 2);</span>
0283    dot11 = dot(v1, v1, 2);
0284    <span class="comment">% dot12 = dot(v1, v2, 2);</span>
0285    invDenom = 1 ./ (dot00 .* dot11 - dot01 .* dot01);
0286    
0287    epsilon = opt.tol_edge2tri;
0288    
0289    excl =   bsxfun(@gt, face_bb(:,1), edge_bb(:,2)') <span class="keyword">...</span>
0290           | bsxfun(@lt, face_bb(:,2), edge_bb(:,1)') <span class="keyword">...</span>
0291           | bsxfun(@gt, face_bb(:,3), edge_bb(:,4)') <span class="keyword">...</span>
0292           | bsxfun(@lt, face_bb(:,4), edge_bb(:,3)') <span class="keyword">...</span>
0293           | bsxfun(@gt, face_bb(:,5), edge_bb(:,6)') <span class="keyword">...</span>
0294           | bsxfun(@lt, face_bb(:,6), edge_bb(:,5)');
0295    excl = ~excl;
0296    N_pts = 0;
0297    <span class="keyword">for</span> i = 1:N_edges
0298       <span class="keyword">if</span> mod(i,mint)==0, <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(i/N_edges); <span class="keyword">end</span>
0299      
0300       fidx = excl(:,i);
0301       <span class="keyword">if</span> ~any(fidx), <span class="keyword">continue</span>, <span class="keyword">end</span>;
0302       
0303       num = -d(fidx) + sum(bsxfun(@times,fmdl.normals(fidx,:),P1(i,:)),2);
0304       
0305       den = sum(bsxfun(@times,fmdl.normals(fidx,:),P12(i,:)),2);
0306       
0307       u = num ./ den;
0308       
0309       idx = u &gt;= 0 &amp; u &lt;= 1;
0310       
0311       <span class="comment">% calculate the intersection points</span>
0312       <span class="keyword">if</span> any(idx)
0313          id = find(idx);
0314          ipts = bsxfun(@minus, P1(i,:), bsxfun(@times, u(id), P12(i,:)));
0315          
0316          <span class="keyword">if</span> 1
0317             fcs = find(fidx);
0318             fid = fcs(id);
0319             <span class="comment">% point in triangle test</span>
0320             v2 = bsxfun(@minus,ipts,fmdl.nodes(fmdl.faces(fid,1),:));
0321             dot02 = dot(v0(fid,:),v2,2);
0322             dot12 = dot(v1(fid,:),v2,2);
0323             <span class="comment">% barycentric coordinates</span>
0324             u = (dot11(fid) .* dot02 - dot01(fid) .* dot12) .* invDenom(fid);
0325             v = (dot00(fid) .* dot12 - dot01(fid) .* dot02) .* invDenom(fid);
0326             t = u &gt;= -epsilon &amp; v &gt;= -epsilon &amp; (u+v-epsilon) &lt;= 1; 
0327          <span class="keyword">else</span>
0328             t = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(ipts,fmdl.faces(id,:),fmdl.nodes,epsilon,<span class="string">'match'</span>);
0329          <span class="keyword">end</span>
0330          <span class="keyword">if</span> any(t)
0331             N = nnz(t);
0332             <span class="keyword">if</span> N_pts+N &gt; N_alloc
0333                N_alloc = N_alloc + allocsz;
0334                intpts(N_alloc,3) = 0;
0335                I(N_alloc) = 0;
0336                T(N_alloc) = 0;
0337                E(N_alloc) = 0;
0338             <span class="keyword">end</span>
0339             idv = N_pts + (1:N);
0340             intpts(idv,:) = ipts(t,:);
0341             I(idv) = idv;
0342             T(idv) = fid(t);
0343             E(idv) = i;
0344             N_pts = N_pts + N;
0345          <span class="keyword">end</span>
0346       <span class="keyword">end</span>
0347    <span class="keyword">end</span>
0348    T = T(1:N_pts);
0349    E = E(1:N_pts);
0350    I = I(1:N_pts);
0351    intpts = intpts(1:N_pts,:);
0352    tri2edge = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(T,E,I,size(fmdl.faces,1),size(rmdl.edges,1));
0353    tri2intpt = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(T,I,ones(size(I)),size(fmdl.faces,1),size(I,1));
0354    edge2intpt  = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(E,I,ones(size(I)),size(rmdl.edges,1),size(I,1));    
0355    
0356 <span class="comment">%-------------------------------------------------------------------------%</span>
0357 <span class="comment">% Assign each rmdl node to the tet it is in (nodes on tet faces are counted</span>
0358 <span class="comment">% mutltiple times)</span>
0359 <a name="_sub3" href="#_subfunctions" class="code">function rnode2tet = get_nodes_in_tets(fmdl,nodes, opt)</a>
0360     
0361    [A,b] = <a href="tet_to_inequal.html" class="code" title="function [A,b]=tet_to_inequal(v,e)">tet_to_inequal</a>(fmdl.nodes,fmdl.elems);
0362    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.01);
0363    <span class="comment">% This is split to decrease the memory footprint</span>
0364    rnode2tet = (bsxfun(@minus, A(1:4:<span class="keyword">end</span>,:)*nodes',b(1:4:end)) &lt;= opt.tol_node2tet)';
0365    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.21);
0366    <span class="keyword">for</span> i = 2:4
0367       rnode2tet = rnode2tet &amp; (bsxfun(@minus, A(i:4:<span class="keyword">end</span>,:)*nodes',b(i:4:end)) &lt;= opt.tol_node2tet)';
0368       <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.21 + (i-1)*.23);
0369    <span class="keyword">end</span>
0370 
0371    <span class="comment">% exclude coinciding nodes</span>
0372    ex= bsxfun(@eq,nodes(:,1),fmdl.nodes(:,1)') &amp; <span class="keyword">...</span>
0373        bsxfun(@eq,nodes(:,2),fmdl.nodes(:,2)') &amp; <span class="keyword">...</span>
0374        bsxfun(@eq,nodes(:,3),fmdl.nodes(:,3)');
0375    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.94);
0376    rnode2tet(any(ex,2),:) = 0;
0377    rnode2tet = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(rnode2tet);
0378    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(1);
0379 
0380 <span class="comment">%-------------------------------------------------------------------------%</span>
0381 <span class="comment">% Prepare model</span>
0382 <a name="_sub4" href="#_subfunctions" class="code">function fmdl = prepare_tet_mdl(fmdl)</a>
0383    fmopt.elem2edge = true;
0384    fmopt.edge2elem = true;
0385    fmopt.face2elem = true;
0386    fmopt.node2elem = true;
0387    fmopt.normals   = true;
0388    fmopt.linear_reorder = false; <span class="comment">% this is slow and not needed</span>
0389    ll = <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
0390    fmdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(fmdl,fmopt);
0391    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
0392    fmdl.node2elem = logical(fmdl.node2elem);
0393    nElem = size(fmdl.elems,1);
0394    nFace = size(fmdl.faces,1);
0395    fmdl.elem2face = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(repmat((1:nElem)',1,4),double(fmdl.elem2face),true,nElem,nFace);
0396 
0397 <span class="comment">%-------------------------------------------------------------------------%</span>
0398 <span class="comment">% Center scale models</span>
0399 <a name="_sub5" href="#_subfunctions" class="code">function[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a>
0400    ctr = mean([min(rmdl.nodes);max(rmdl.nodes)]);
0401    rmdl.nodes = bsxfun(@minus,rmdl.nodes,ctr);
0402    fmdl.nodes = bsxfun(@minus,fmdl.nodes,ctr);
0403    <span class="keyword">if</span> isfield(opt,<span class="string">'do_not_scale'</span>) &amp;&amp; opt.do_not_scale
0404       <span class="keyword">return</span>
0405    <span class="keyword">end</span>
0406    maxnode = min( max(abs(rmdl.nodes(:))), max(abs(fmdl.nodes(:))));
0407    scale = 1/maxnode;
0408    rmdl.nodes = scale*rmdl.nodes;
0409    fmdl.nodes = scale*fmdl.nodes;
0410    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ models scaled by %g'</span>, scale,2);
0411 
0412 <span class="comment">%-------------------------------------------------------------------------%</span>
0413 <span class="comment">% Remove obviously non-overlapping parts of the models</span>
0414 <a name="_sub6" href="#_subfunctions" class="code">function [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)</a>
0415    f_min = min(fmdl.nodes);
0416    f_max = max(fmdl.nodes);
0417    r_min = min(rmdl.nodes);
0418    r_max = max(rmdl.nodes);
0419    
0420    <span class="comment">% nodes outside the bounding box of the other model</span>
0421    f_gt  = bsxfun(@gt, fmdl.nodes, r_max);
0422    f_lt  = bsxfun(@lt, fmdl.nodes, r_min);
0423    r_gt  = bsxfun(@gt, rmdl.nodes, f_max);
0424    r_lt  = bsxfun(@lt, rmdl.nodes, f_min);
0425    
0426    <span class="comment">% elems outside the bounding box of the other model</span>
0427    re_gt = any(reshape(all(reshape(r_gt(rmdl.elems',:),4,[])),[],3),2);
0428    re_lt = any(reshape(all(reshape(r_lt(rmdl.elems',:),4,[])),[],3),2);
0429    fe_gt = any(reshape(all(reshape(f_gt(fmdl.elems',:),4,[])),[],3),2);
0430    fe_lt = any(reshape(all(reshape(f_lt(fmdl.elems',:),4,[])),[],3),2);
0431    
0432    <span class="comment">% elems to keep</span>
0433    rmdl_idx = ~(re_gt | re_lt);
0434    fmdl_idx = ~(fe_gt | fe_lt);
0435    
0436    <span class="comment">% remove non-overlapping elems</span>
0437    rmdl.elems = rmdl.elems(rmdl_idx,:);
0438    fmdl.elems = fmdl.elems(fmdl_idx,:);
0439    
0440    <span class="comment">% remove unused nodes</span>
0441    [r_used_nodes,jnk,r_n] = unique(rmdl.elems(:));
0442    [f_used_nodes,jnk,f_n] = unique(fmdl.elems(:));
0443    
0444    r_idx = 1:numel(r_used_nodes);
0445    f_idx = 1:numel(f_used_nodes);
0446    
0447    rmdl.elems = reshape(r_idx(r_n),[],4);
0448    fmdl.elems = reshape(f_idx(f_n),[],4);
0449    
0450    rmdl.nodes = rmdl.nodes(r_used_nodes,:);
0451    fmdl.nodes = fmdl.nodes(f_used_nodes,:);
0452    
0453    <span class="comment">% for the benefit of any (debug) plots later on</span>
0454    rmdl = rmfield(rmdl,<span class="string">'boundary'</span>);
0455    fmdl = rmfield(fmdl,<span class="string">'boundary'</span>);
0456     
0457 <span class="comment">%-------------------------------------------------------------------------%</span>
0458 <span class="comment">% Parse option struct</span>
0459  <a name="_sub7" href="#_subfunctions" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a>
0460 
0461     
0462     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_node2tet'</span>);
0463         opt.tol_node2tet = eps; <span class="comment">% * max(rmdl_rng,fmdl_rng)^3;</span>
0464     <span class="keyword">end</span>
0465     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_edge2edge'</span>)
0466         opt.tol_edge2edge = 2*sqrt(3)*eps(min(max(abs(fmdl.nodes(:))),max(abs(rmdl.nodes(:)))));
0467     <span class="keyword">end</span>
0468     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_edge2tri'</span>)
0469         opt.tol_edge2tri = eps; <span class="comment">%1e-10</span>
0470     <span class="keyword">end</span>
0471 <span class="comment">%     if ~isfield(opt, 'save_memory')</span>
0472 <span class="comment">%        opt.save_memory = 0;</span>
0473 <span class="comment">%     end</span>
0474     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ node2tet  tolerance = %g'</span>, opt.tol_node2tet,2);
0475     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ edge2edge tolerance = %g'</span>, opt.tol_edge2edge,2);
0476     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ edge2tri  tolerance = %g'</span>, opt.tol_edge2tri,2);
0477    
0478    
0479 <span class="comment">%-------------------------------------------------------------------------%</span>
0480 <span class="comment">% Perfom unit tests</span>
0481 <a name="_sub8" href="#_subfunctions" class="code">function do_unit_test</a>
0482    <a href="#_sub9" class="code" title="subfunction do_small_test">do_small_test</a>;
0483    <a href="#_sub10" class="code" title="subfunction do_realistic_test">do_realistic_test</a>;
0484 
0485 
0486 <a name="_sub9" href="#_subfunctions" class="code">function do_small_test</a>
0487    fmdl = <a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([1 .5],[],[]);
0488    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl)
0489    v = -.5:.1:.5;
0490    rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],v,v,0:.1:1);
0491    hold on
0492    h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(rmdl);
0493    set(h,<span class="string">'edgecolor'</span>,<span class="string">'b'</span>);
0494    hold off
0495    c2f = <a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>(fmdl,rmdl);
0496    tc2f = c2f * rmdl.coarse2fine;
0497    vc2f = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl,rmdl);
0498    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'mk_tet_c2f v mk_grid_c2f'</span>, tc2f,vc2f, 1e-15);
0499 
0500 
0501 <a name="_sub10" href="#_subfunctions" class="code">function do_realistic_test</a>
0502    fmdl= <a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([2,2,.1],[16,1],[.1,0,.025]);
0503    xvec = [-1.5 -.5:.2:.5 1.5];
0504    yvec = [-1.6 -1:.2:1 1.6];
0505    zvec = 0:.25:2;
0506    rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],xvec,yvec,zvec);
0507    tic
0508    opt.save_memory = 0;
0509    c2f_a = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl, rmdl,opt);
0510    t = toc;
0511    fprintf(<span class="string">'Voxel: t=%f s\n'</span>,t);
0512 
0513    tic
0514    opt.save_memory = 0;
0515    c2f_b = <a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>(fmdl, rmdl,opt);
0516    t = toc;
0517    fprintf(<span class="string">'Tet: t=%f s\n'</span>,t);
0518 
0519    c2f_b = c2f_b * rmdl.coarse2fine;
0520    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'mk_tet_c2f v mk_grid_c2f'</span>, c2f_b,c2f_a, 1e-5);
0521 
0522    tic
0523    c2f_n = <a href="mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping( f_mdl, c_mdl );">mk_coarse_fine_mapping</a>(fmdl,rmdl);
0524    t = toc;
0525    fprintf(<span class="string">'Approximate: t=%f s\n'</span>,t);
0526</pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>