<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_voxel_volume</title>
  <meta name="keywords" content="mk_voxel_volume">
  <meta name="description" content="MK_VOXEL_VOLUME create a voxel model to reconstruct on">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_voxel_volume.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_voxel_volume
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_VOXEL_VOLUME create a voxel model to reconstruct on</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [imdl, fmdl] = mk_voxel_volume(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_VOXEL_VOLUME create a voxel model to reconstruct on
 OUT = MK_VOXEL_VOLUME(MDL)
 OUT = MK_VOXEL_VOLUME(MDL, OPT)

 Inputs:
  MDL   = an EIDORS forward or inverse model structure
  OPT   = an option structure with the following fields and defaults:
     opt.imgsz = [32 32 4]; % X, Y and Z dimensions of the voxel grid
     opt.xvec  = []          % Specific X cut-planes between voxels
                             % A scalar means the number of planes
                             % Takes precedence over other options
     opt.yvec  = []          % Specific Y cut-planes between voxels
                             % A scalar means the number of planes
                             % Takes precedence over other options
     opt.zvec  = []          % Specific Z cut-planes between voxels
                             % A scalar means the number of planes
                             % Takes precedence over other options
     opt.square_pixels = 0;  % adjust imgsz to get square pixels (in XY)
     opt.cube_voxels = 0;    % adjust imgsz to get cube voxels (in XYZ)  
     opt.prune_model = true  % removes voxels outside the supplied MDL
                             % This runs mk_grid_c2f. For simple
                             % geometries, such a cylinder, it is much
                             % quicker to set to false and prune manually.
     opt.save_memory         % passed to mk_grid_c2f

 Output depends on the type of model suplied. If MDL is a fwd_model
 structure then OUT is a rec_model. If MDL is an inv_model, then OUT is a
 modified version of it, with the voxel volume in inv_model.rec_model and
 updated inv_model.fwd_model.coarse2fine
 
 [OUT FMDL] = MK_VOXEL_VOLUME(MDL, ...) also returns the forward model
 structure with the coarse2fine field.

 See also <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">MK_PIXEL_SLICE</a>, <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">MK_GRID_MODEL</a>, <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">MK_GRID_C2F</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li><li><a href="mk_voxel_volume.html" class="code" title="function [imdl, fmdl] = mk_voxel_volume(varargin)">mk_voxel_volume</a>	MK_VOXEL_VOLUME create a voxel model to reconstruct on</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_voxel_volume.html" class="code" title="function [imdl, fmdl] = mk_voxel_volume(varargin)">mk_voxel_volume</a>	MK_VOXEL_VOLUME create a voxel model to reconstruct on</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [rmdl, c2f] = do_voxel_volume(fmdl,opt)</a></li><li><a href="#_sub2" class="code">function cache_obj = get_cache_obj(fmdl, opt)</a></li><li><a href="#_sub3" class="code">function opt = parse_opts(fmdl, opt)</a></li><li><a href="#_sub4" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [imdl, fmdl] = mk_voxel_volume(varargin)</a>
0002 <span class="comment">%MK_VOXEL_VOLUME create a voxel model to reconstruct on</span>
0003 <span class="comment">% OUT = MK_VOXEL_VOLUME(MDL)</span>
0004 <span class="comment">% OUT = MK_VOXEL_VOLUME(MDL, OPT)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Inputs:</span>
0007 <span class="comment">%  MDL   = an EIDORS forward or inverse model structure</span>
0008 <span class="comment">%  OPT   = an option structure with the following fields and defaults:</span>
0009 <span class="comment">%     opt.imgsz = [32 32 4]; % X, Y and Z dimensions of the voxel grid</span>
0010 <span class="comment">%     opt.xvec  = []          % Specific X cut-planes between voxels</span>
0011 <span class="comment">%                             % A scalar means the number of planes</span>
0012 <span class="comment">%                             % Takes precedence over other options</span>
0013 <span class="comment">%     opt.yvec  = []          % Specific Y cut-planes between voxels</span>
0014 <span class="comment">%                             % A scalar means the number of planes</span>
0015 <span class="comment">%                             % Takes precedence over other options</span>
0016 <span class="comment">%     opt.zvec  = []          % Specific Z cut-planes between voxels</span>
0017 <span class="comment">%                             % A scalar means the number of planes</span>
0018 <span class="comment">%                             % Takes precedence over other options</span>
0019 <span class="comment">%     opt.square_pixels = 0;  % adjust imgsz to get square pixels (in XY)</span>
0020 <span class="comment">%     opt.cube_voxels = 0;    % adjust imgsz to get cube voxels (in XYZ)</span>
0021 <span class="comment">%     opt.prune_model = true  % removes voxels outside the supplied MDL</span>
0022 <span class="comment">%                             % This runs mk_grid_c2f. For simple</span>
0023 <span class="comment">%                             % geometries, such a cylinder, it is much</span>
0024 <span class="comment">%                             % quicker to set to false and prune manually.</span>
0025 <span class="comment">%     opt.save_memory         % passed to mk_grid_c2f</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Output depends on the type of model suplied. If MDL is a fwd_model</span>
0028 <span class="comment">% structure then OUT is a rec_model. If MDL is an inv_model, then OUT is a</span>
0029 <span class="comment">% modified version of it, with the voxel volume in inv_model.rec_model and</span>
0030 <span class="comment">% updated inv_model.fwd_model.coarse2fine</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% [OUT FMDL] = MK_VOXEL_VOLUME(MDL, ...) also returns the forward model</span>
0033 <span class="comment">% structure with the coarse2fine field.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% See also MK_PIXEL_SLICE, MK_GRID_MODEL, MK_GRID_C2F</span>
0036 
0037 <span class="comment">% (C) 2015 Bartlomiej Grychtol - all rights reserved by Swisstom AG</span>
0038 <span class="comment">% License: GPL version 2 or 3</span>
0039 <span class="comment">% $Id: mk_voxel_volume.m 4859 2015-04-03 12:06:01Z bgrychtol-ipa $</span>
0040 
0041 <span class="comment">% &gt;&gt; SWISSTOM CONTRIBUTION &lt;&lt;</span>
0042 
0043 imdl = varargin{1};
0044 <span class="comment">% if input is 'UNIT_TEST', run tests</span>
0045 <span class="keyword">if</span> ischar(imdl) &amp;&amp; strcmp(imdl,<span class="string">'UNIT_TEST'</span>) 
0046     <a href="#_sub4" class="code" title="subfunction do_unit_test">do_unit_test</a>; clear imdl 
0047     <span class="keyword">return</span>; 
0048 <span class="keyword">end</span>
0049 
0050 <span class="keyword">if</span> nargin &lt; 2
0051     opt = struct;
0052 <span class="keyword">else</span> 
0053     opt = varargin{2};
0054 <span class="keyword">end</span>
0055 
0056 <span class="keyword">switch</span>(imdl.type)
0057     <span class="keyword">case</span> <span class="string">'inv_model'</span>
0058         fmdl = imdl.fwd_model;
0059     <span class="keyword">case</span> <span class="string">'fwd_model'</span>
0060         fmdl = imdl;
0061     <span class="keyword">otherwise</span>
0062         error(<span class="string">'An EIDORS inverse or forward model struct required'</span>);
0063 <span class="keyword">end</span>
0064 
0065 opt = <a href="#_sub3" class="code" title="subfunction opt = parse_opts(fmdl, opt)">parse_opts</a>(fmdl,opt);
0066 
0067 copt.fstr = <span class="string">'mk_voxel_volume'</span>;
0068 copt.cache_obj = <a href="#_sub2" class="code" title="subfunction cache_obj = get_cache_obj(fmdl, opt)">get_cache_obj</a>(fmdl, opt);
0069 [rmdl, c2f] = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction [rmdl, c2f] = do_voxel_volume(fmdl,opt)">do_voxel_volume</a>,{fmdl, opt},copt);
0070 
0071 <span class="keyword">if</span> ~isempty(c2f)
0072     fmdl.coarse2fine = c2f;
0073 <span class="keyword">end</span>
0074 
0075 <span class="keyword">switch</span> imdl.type
0076    <span class="keyword">case</span> <span class="string">'inv_model'</span>
0077       imdl.rec_model = rmdl;
0078       imdl.fwd_model = fmdl;
0079    <span class="keyword">case</span> <span class="string">'fwd_model'</span>
0080       imdl = rmdl;
0081 <span class="keyword">end</span>
0082 
0083 
0084 <span class="comment">%-------------------------------------------------------------------------%</span>
0085 <span class="comment">% The main function</span>
0086 <a name="_sub1" href="#_subfunctions" class="code">function [rmdl, c2f] = do_voxel_volume(fmdl,opt)</a>
0087     
0088     rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],opt.xvec,opt.yvec,opt.zvec);
0089     
0090     c2f = [];
0091     <span class="keyword">if</span> ~opt.prune_model, <span class="keyword">return</span>, <span class="keyword">end</span>
0092     
0093     <span class="comment">%     fmdl.elems = fmdl.elems( 210714,:);</span>
0094     [c2f, m]  = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl, rmdl, opt);
0095     inside = any(c2f,1);
0096 
0097     c2f(:,~inside) = [];
0098     rm = ~logical(rmdl.coarse2fine*inside');
0099     rmdl.elems(rm,:) = [];
0100     rmdl.coarse2fine(rm,:) = [];
0101     rmdl.coarse2fine(:,~inside) = [];
0102     
0103     
0104     bnd_fcs = ones(1,nnz(inside))*m.vox2face(inside,:) == 1;
0105     rmdl.boundary = m.faces(bnd_fcs,:);
0106     rmdl.inside   = inside; <span class="comment">% the inside array is useful in other functions</span>
0107     x_pts = opt.xvec(1:end-1) + 0.5*diff(opt.xvec);
0108     y_pts = opt.yvec(1:end-1) + 0.5*diff(opt.yvec);
0109 
0110     rmdl.mdl_slice_mapper.x_pts = x_pts;
0111     rmdl.mdl_slice_mapper.y_pts = y_pts;
0112     
0113     
0114 <span class="comment">%-------------------------------------------------------------------------%</span>
0115 <span class="comment">% Assemble a reference object for caching</span>
0116 <a name="_sub2" href="#_subfunctions" class="code">function cache_obj = get_cache_obj(fmdl, opt)</a>
0117     tmp = struct;
0118     flds = {<span class="string">'nodes'</span>,<span class="string">'elems'</span>};
0119     <span class="keyword">for</span> f = flds;
0120         tmp.(f{1}) = fmdl.(f{1});
0121     <span class="keyword">end</span>
0122     cache_obj = {tmp, opt};
0123     
0124 
0125 <span class="comment">%-------------------------------------------------------------------------%</span>
0126 <span class="comment">% Parse option struct</span>
0127  <a name="_sub3" href="#_subfunctions" class="code">function opt = parse_opts(fmdl, opt)</a>
0128     <span class="keyword">if</span> ~isfield(opt, <span class="string">'imgsz'</span>),     
0129         opt.imgsz = [32 32 4]; 
0130     <span class="keyword">end</span>
0131     <span class="keyword">if</span> ~isfield(opt, <span class="string">'square_pixels'</span>)
0132         opt.square_pixels = 0;
0133     <span class="keyword">end</span>
0134     <span class="keyword">if</span> ~isfield(opt, <span class="string">'cube_voxels'</span>)
0135         opt.cube_voxels = 0;
0136     <span class="keyword">end</span>
0137     <span class="keyword">if</span> ~isfield(opt, <span class="string">'xvec'</span>)
0138         opt.xvec = [];
0139     <span class="keyword">end</span>
0140     <span class="keyword">if</span> ~isfield(opt, <span class="string">'yvec'</span>)
0141         opt.yvec = [];
0142     <span class="keyword">end</span>
0143     <span class="keyword">if</span> ~isfield(opt, <span class="string">'zvec'</span>)
0144         opt.zvec = [];
0145     <span class="keyword">end</span>
0146     <span class="keyword">if</span> ~isfield(opt, <span class="string">'prune_model'</span>)
0147         opt.prune_model = true;
0148     <span class="keyword">end</span>
0149     <span class="keyword">if</span> isempty(opt.xvec) &amp;&amp; isempty(opt.imgsz)
0150         error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'opt.imgsz must not be empty if opt.xvec is empty or absent'</span>);
0151     <span class="keyword">end</span>
0152     <span class="keyword">if</span> isempty(opt.yvec) &amp;&amp; numel(opt.imgsz) &lt; 2
0153         error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'opt.imgsz must have at least 2 elements if opt.yvec is empty or absent'</span>);
0154     <span class="keyword">end</span>
0155     <span class="keyword">if</span> isempty(opt.zvec) &amp;&amp; numel(opt.imgsz) &lt; 3
0156         error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'opt.imgsz must have 3 elements if opt.zvec is empty or absent'</span>);
0157     <span class="keyword">end</span>
0158     
0159     mingrid = min(fmdl.nodes);
0160     maxgrid = max(fmdl.nodes);
0161     mdl_sz = maxgrid - mingrid;
0162     
0163     allempty = isempty(opt.xvec) &amp; isempty(opt.yvec) &amp; isempty(opt.zvec);
0164     <span class="keyword">if</span> opt.cube_voxels &amp;&amp; ~allempty
0165         warning(<span class="string">'EIDORS:IncompatibleOptions'</span>,<span class="string">'Option cube_voxels is ignored when xvec, yvec or zvec is specifed'</span>);
0166     <span class="keyword">end</span>
0167     <span class="keyword">if</span> opt.cube_voxels &amp;&amp; allempty
0168         side_sz = max(mdl_sz ./ opt.imgsz(1:3));
0169         n_steps = ceil(mdl_sz / side_sz);
0170         mdl_ctr = mingrid + mdl_sz/2;
0171         mingrid = mdl_ctr - n_steps/2 * side_sz;
0172         maxgrid = mdl_ctr + n_steps/2 * side_sz;
0173         opt.imgsz = n_steps;
0174  
0175     <span class="keyword">elseif</span> opt.square_pixels
0176         <span class="keyword">if</span> ~isempty(opt.xvec) || ~isempty(opt.yvec)
0177             warning(<span class="string">'EIDORS:IncompatibleOptions'</span>,<span class="string">'Option square_pixels is ignored when xvec or yvec is specifed'</span>);
0178         <span class="keyword">else</span>
0179             mdl_AR = mdl_sz(1)/mdl_sz(2);
0180             img_AR = opt.imgsz(1)/opt.imgsz(2);
0181             <span class="keyword">if</span> mdl_AR &lt; img_AR
0182                 delta = (mdl_sz(2) * img_AR - mdl_sz(1)) /2;
0183                 mingrid(1) = mingrid(1) - delta;
0184                 maxgrid(1) = maxgrid(1) + delta;
0185             <span class="keyword">elseif</span> mdl_AR &gt; img_AR
0186                 delta = (mdl_sz(1)/img_AR - mdl_sz(2)) / 2;
0187                 mingrid(2) = mingrid(2) - delta;
0188                 maxgrid(2) = maxgrid(2) + delta;
0189             <span class="keyword">end</span>
0190         <span class="keyword">end</span>
0191     <span class="keyword">end</span>
0192     <span class="keyword">if</span> isempty(opt.xvec)
0193         opt.xvec = linspace(mingrid(1), maxgrid(1), opt.imgsz(1)+1);
0194     <span class="keyword">end</span>      
0195     <span class="keyword">if</span> isempty(opt.yvec)
0196         opt.yvec = linspace(mingrid(2), maxgrid(2), opt.imgsz(2)+1);
0197     <span class="keyword">end</span>
0198     <span class="keyword">if</span> isempty(opt.zvec)
0199         opt.zvec = linspace(mingrid(3), maxgrid(3), opt.imgsz(3)+1);
0200     <span class="keyword">end</span>
0201     
0202     <span class="keyword">if</span> ~isfield(opt, <span class="string">'do_coarse2fine'</span>)
0203         opt.do_coarse2fine = 1;
0204     <span class="keyword">end</span>
0205     <span class="keyword">if</span> ~isfield(opt, <span class="string">'z_depth'</span>)
0206         opt.z_depth = inf;
0207     <span class="keyword">end</span>
0208 
0209 <span class="comment">%-------------------------------------------------------------------------%</span>
0210 <span class="comment">% Perfom unit tests</span>
0211 <a name="_sub4" href="#_subfunctions" class="code">function do_unit_test</a>
0212 
0213 fmdl = <a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'adult_male_16el'</span>);
0214 <span class="comment">% fmdl= ng_mk_cyl_models([2,2,.4],[16,1],[.1,0,.025]);</span>
0215 opt.square_pixels = 1;
0216 [rmdl, fmdl] = <a href="mk_voxel_volume.html" class="code" title="function [imdl, fmdl] = mk_voxel_volume(varargin)">mk_voxel_volume</a>(fmdl, opt);
0217 
0218 
0219 subplot(121)
0220 rimg = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,0);
0221 rimg.elem_data = zeros(size(rmdl.coarse2fine,2),1);
0222 idx = round(rand(5,1)* length(rimg.elem_data));
0223 rimg.elem_data(idx) = 1;
0224 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(rimg);
0225 
0226 subplot(122)
0227 img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,0);
0228 img.elem_data = fmdl.coarse2fine * rimg.elem_data;
0229 img.calc_colours.ref_level = 0;
0230 img.calc_colours.transparency_thresh = 1e-2;
0231 
0232 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0233 
0234 
0235 
0236 
0237</pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>