<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of place_elec_on_surf</title>
  <meta name="keywords" content="place_elec_on_surf">
  <meta name="description" content="PLACE_ELEC_ON_SURF Place electrodes on the surface of a model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; place_elec_on_surf.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>place_elec_on_surf
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">PLACE_ELEC_ON_SURF Place electrodes on the surface of a model
 mdl = place_elec_on_surf(mdl,elec_pos, elec_spec, ng_opt_file, maxh)
 INPUT:
  mdl         = an EIDORS fwd_model struct
  elec_pos    = an array specigying electrode positions
  elec_shape  = an array specifying electrode shape (can be different for
                each electrode)
  ng_opt_file = an alternative ng.opt file to use (OPTIONAL)
                specify [] to use dafault
  maxh        = maximum edge length (if ng_opt_file is specified, maxh 
                only applies to the volume and not the surface)
 ELECTRODE POSITIONS:
  elec_pos = [n_elecs_per_plane,z_planes] 
     OR
  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)
     OR
  elec_pos = [x y z] centres of each electrode (N_elecs x 3)

  Note: N_elecs &gt;= 2.

 ELECTRODE SHAPES::
  elec_shape = [width,height, maxsz]  % Rectangular elecs
     OR
  elec_shape = [radius, 0, maxsz ]    % Circular elecs

 NOTE that this function requires both Netgen and Gmsh.
 It will completely re-mesh your model.
 The code makes several assumptions about the output of Netgen, which it
 attempts to control through the ng.opt file, but there will be meshes 
 for which this appraoch will fail. In this case, you can supply your own 
 file with options for Netgen (with a filename different than ng.opt), or
 change your mesh and/or electrode locations. Most common problem is too 
 big electrode maxh value (must be significantly smaller than the smallest
 element on which the electrode will fall).

 CITATION_REQUEST:
 TITLE: FEM Electrode Refinement for Electrical Impedance Tomography 
 AUTHOR: B Grychtol and A Adler
 JOURNAL: Engineering in Medicine and Biology Society (EMBC), 2013 Annual 
 International Conference of the IEEE 
 YEAR: 2013

 See also <a href="gmsh_stl2tet.html" class="code" title="function mdl = gmsh_stl2tet(stlfile, maxh, extra)">gmsh_stl2tet</a>, ng_write_opt, <a href="merge_meshes.html" class="code" title="function out = merge_meshes(M1,varargin)">merge_meshes</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/meshing/netgen/call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>	CALL_NETGEN: call netgen to create a vol_file from a geo_file</li><li><a href="../../eidors/meshing/netgen/ng_mk_2d_model.html" class="code" title="function mdl = ng_mk_2d_model(varargin)">ng_mk_2d_model</a>	NG_MG_2D_MODELS create a 2D mesh with Netgen via the in2d interface</li><li><a href="../../eidors/meshing/netgen/ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>	NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen</li><li><a href="../../eidors/meshing/netgen/ng_mk_fwd_model.html" class="code" title="function [fwd_mdl, mat_idx_reordered]=ng_mk_fwd_model( ng_vol_filename, centres,name, stim_pattern, z_contact, postprocmesh)">ng_mk_fwd_model</a>	NG_MK_FWD_MODEL: create a fwd_model object from a netgen vol file</li><li><a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>	NG_WRITE_OPT Write an ng.opt file in current directory</li><li><a href="../../eidors/meshing/stl/stl_write.html" class="code" title="function stl_write(fv, name)">stl_write</a>	STL_WRITE Create a text STL file from a patch struct</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="gmsh_stl2tet.html" class="code" title="function mdl = gmsh_stl2tet(stlfile, maxh, extra)">gmsh_stl2tet</a>	GMSH_STL2TET creates a tetrahedral mesh from an stl file</li><li><a href="merge_meshes.html" class="code" title="function out = merge_meshes(M1,varargin)">merge_meshes</a>	MERGE_MESHES - merges two meshes based on common nodes</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/tools/citeme.html" class="code" title="function citeme(fname)">citeme</a>	CITEME Display citation requests</li><li><a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function debugging = do_debug;</a></li><li><a href="#_sub2" class="code">function write_to_stl(mdl,stlfn)</a></li><li><a href="#_sub3" class="code">function write_ng_opt_file(ng_opt_file, maxh)</a></li><li><a href="#_sub4" class="code">function mdl = prepare_surf_model(mdl)</a></li><li><a href="#_sub5" class="code">function mdl = orient_boundary(mdl)</a></li><li><a href="#_sub6" class="code">function mdl = flatten_electrode(mdl,inner,outer, V)</a></li><li><a href="#_sub7" class="code">function match = find_matching_nodes(mdl, nodes,th)</a></li><li><a href="#_sub8" class="code">function [joint EL1 EL2 V] = add_electrodes(mdl,N,elecs)</a></li><li><a href="#_sub9" class="code">function PN = project_nodes_on_elec(mdl,elecs,nodes)</a></li><li><a href="#_sub10" class="code">function [elecs] = parse_elecs(mdl, elec_pos, elec_shape )</a></li><li><a href="#_sub11" class="code">function [u v s] = get_face_basis(mdl, fc)</a></li><li><a href="#_sub12" class="code">function [fc pos] = find_elec_centre(mdl, el_th,el_z)</a></li><li><a href="#_sub13" class="code">function out = grow_neighbourhood(mdl, varargin)</a></li><li><a href="#_sub14" class="code">function nn =  find_neighbours(fc, bb);</a></li><li><a href="#_sub15" class="code">function [e p] = find_face_under_elec(mdl, elec_pos)</a></li><li><a href="#_sub16" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)</a>
0002 <span class="comment">%PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</span>
0003 <span class="comment">% mdl = place_elec_on_surf(mdl,elec_pos, elec_spec, ng_opt_file, maxh)</span>
0004 <span class="comment">% INPUT:</span>
0005 <span class="comment">%  mdl         = an EIDORS fwd_model struct</span>
0006 <span class="comment">%  elec_pos    = an array specigying electrode positions</span>
0007 <span class="comment">%  elec_shape  = an array specifying electrode shape (can be different for</span>
0008 <span class="comment">%                each electrode)</span>
0009 <span class="comment">%  ng_opt_file = an alternative ng.opt file to use (OPTIONAL)</span>
0010 <span class="comment">%                specify [] to use dafault</span>
0011 <span class="comment">%  maxh        = maximum edge length (if ng_opt_file is specified, maxh</span>
0012 <span class="comment">%                only applies to the volume and not the surface)</span>
0013 <span class="comment">% ELECTRODE POSITIONS:</span>
0014 <span class="comment">%  elec_pos = [n_elecs_per_plane,z_planes]</span>
0015 <span class="comment">%     OR</span>
0016 <span class="comment">%  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)</span>
0017 <span class="comment">%     OR</span>
0018 <span class="comment">%  elec_pos = [x y z] centres of each electrode (N_elecs x 3)</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%  Note: N_elecs &gt;= 2.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% ELECTRODE SHAPES::</span>
0023 <span class="comment">%  elec_shape = [width,height, maxsz]  % Rectangular elecs</span>
0024 <span class="comment">%     OR</span>
0025 <span class="comment">%  elec_shape = [radius, 0, maxsz ]    % Circular elecs</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% NOTE that this function requires both Netgen and Gmsh.</span>
0028 <span class="comment">% It will completely re-mesh your model.</span>
0029 <span class="comment">% The code makes several assumptions about the output of Netgen, which it</span>
0030 <span class="comment">% attempts to control through the ng.opt file, but there will be meshes</span>
0031 <span class="comment">% for which this appraoch will fail. In this case, you can supply your own</span>
0032 <span class="comment">% file with options for Netgen (with a filename different than ng.opt), or</span>
0033 <span class="comment">% change your mesh and/or electrode locations. Most common problem is too</span>
0034 <span class="comment">% big electrode maxh value (must be significantly smaller than the smallest</span>
0035 <span class="comment">% element on which the electrode will fall).</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% CITATION_REQUEST:</span>
0038 <span class="comment">% TITLE: FEM Electrode Refinement for Electrical Impedance Tomography</span>
0039 <span class="comment">% AUTHOR: B Grychtol and A Adler</span>
0040 <span class="comment">% JOURNAL: Engineering in Medicine and Biology Society (EMBC), 2013 Annual</span>
0041 <span class="comment">% International Conference of the IEEE</span>
0042 <span class="comment">% YEAR: 2013</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% See also gmsh_stl2tet, ng_write_opt, merge_meshes</span>
0045 
0046 <span class="comment">% (C) Bartlomiej Grychtol and Andy Adler, 2012-2013. Licence: GPL v2 or v3</span>
0047 <span class="comment">% $Id: place_elec_on_surf.m 4680 2015-02-18 07:20:33Z bgrychtol-ipa $</span>
0048 
0049 <a href="../../eidors/tools/citeme.html" class="code" title="function citeme(fname)">citeme</a>(mfilename);
0050 
0051 <span class="keyword">if</span> isstr(mdl) &amp;&amp; strcmp(mdl, <span class="string">'UNIT_TEST'</span>) <a href="#_sub16" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>;
0052 <span class="keyword">if</span> nargin &lt; 4
0053    ng_opt_file = <span class="string">''</span>;
0054 <span class="keyword">end</span>
0055 <span class="keyword">if</span> nargin &lt; 5
0056    maxh = [];
0057 <span class="keyword">end</span>
0058    
0059 
0060 <span class="comment">% filenames</span>
0061 <span class="keyword">if</span> do_debug; fnstem = <span class="string">'tmp1'</span>;
0062 <span class="keyword">else</span>;        fnstem = tempname;
0063 <span class="keyword">end</span>
0064 
0065 stlfn = [fnstem,<span class="string">'.stl'</span>];
0066 meshfn= [fnstem,<span class="string">'.vol'</span>];
0067 
0068 <span class="keyword">if</span> do_debug; fnstem = <span class="string">'tmp2'</span>;
0069 <span class="keyword">else</span>;        fnstem = tempname;
0070 <span class="keyword">end</span>
0071 
0072 stlfn2 = [fnstem,<span class="string">'.stl'</span>];
0073 
0074 <span class="comment">% 1. Get a surface model</span>
0075 mdl = <a href="#_sub4" class="code" title="subfunction mdl = prepare_surf_model(mdl)">prepare_surf_model</a>(mdl);
0076 <span class="keyword">if</span> isempty(maxh)
0077    maxh = max(mdl.edge_len);
0078 <span class="keyword">end</span>
0079 
0080 elecs = <a href="#_sub10" class="code" title="subfunction [elecs] = parse_elecs(mdl, elec_pos, elec_shape )">parse_elecs</a>(mdl,elec_pos,elec_spec);
0081 <span class="keyword">if</span> isempty(elecs)
0082    error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'Failed to parse electrode positions. Exiting'</span>);
0083 <span class="keyword">end</span>
0084 
0085 
0086 <span class="comment">% 2. Add extruded electrodes</span>
0087 <span class="keyword">for</span> i = 1:length(elecs)
0088    <span class="keyword">try</span>
0089       N = <a href="#_sub13" class="code" title="subfunction out = grow_neighbourhood(mdl, varargin)">grow_neighbourhood</a>(mdl,elecs(i));
0090       [mdl E1{i} E2{i} V{i}] = <a href="#_sub8" class="code" title="subfunction [joint EL1 EL2 V] = add_electrodes(mdl,N,elecs)">add_electrodes</a>(mdl,N,elecs(i));
0091    <span class="keyword">catch</span> e
0092       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Failed to add electrode #%d'</span>,i,1);
0093       rethrow(e);
0094    <span class="keyword">end</span>
0095 <span class="keyword">end</span>
0096 
0097 <span class="comment">% 3. Save as STL and mesh with NETGEN</span>
0098 <a href="#_sub2" class="code" title="subfunction write_to_stl(mdl,stlfn)">write_to_stl</a>(mdl,stlfn);
0099 <a href="#_sub3" class="code" title="subfunction write_ng_opt_file(ng_opt_file, maxh)">write_ng_opt_file</a>(ng_opt_file, maxh)
0100 <a href="../../eidors/meshing/netgen/call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>(stlfn,meshfn);
0101 delete(<span class="string">'ng.opt'</span>); <span class="comment">% clean up</span>
0102 
0103 <span class="comment">% 4. Extract surface</span>
0104 fmdl=<a href="../../eidors/meshing/netgen/ng_mk_fwd_model.html" class="code" title="function [fwd_mdl, mat_idx_reordered]=ng_mk_fwd_model( ng_vol_filename, centres,name, stim_pattern, z_contact, postprocmesh)">ng_mk_fwd_model</a>(meshfn,[],[],[],[]);
0105 mdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(fmdl);
0106 mdl = <a href="#_sub5" class="code" title="subfunction mdl = orient_boundary(mdl)">orient_boundary</a>(mdl);
0107 mdl.elems = mdl.boundary;
0108 
0109 <span class="comment">% 5. One by one, flatten the electrodes</span>
0110 <span class="keyword">for</span> i = 1:length(elecs)
0111    <span class="keyword">try</span> 
0112       mdl = <a href="#_sub6" class="code" title="subfunction mdl = flatten_electrode(mdl,inner,outer, V)">flatten_electrode</a>(mdl,E1{i},E2{i}, V{i});
0113    <span class="keyword">catch</span> e
0114       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Failed to flatten electrode #%d'</span>,i,1);
0115       rethrow(e);
0116    <span class="keyword">end</span>
0117 <span class="keyword">end</span>
0118 
0119 <span class="comment">% 6. Keeping the surface intact, remesh the inside</span>
0120 <a href="#_sub2" class="code" title="subfunction write_to_stl(mdl,stlfn)">write_to_stl</a>(mdl,stlfn2);
0121 mdl2 = <a href="gmsh_stl2tet.html" class="code" title="function mdl = gmsh_stl2tet(stlfile, maxh, extra)">gmsh_stl2tet</a>(stlfn2, maxh);
0122 mdl2.electrode = mdl.electrode;
0123 
0124 <span class="comment">% 7. Find all electrode nodes</span>
0125 <span class="keyword">for</span> i = 1:length(elecs)
0126    enodes = mdl.nodes(mdl.electrode(i).nodes,:);
0127    mdl2.electrode(i).nodes = <a href="#_sub7" class="code" title="subfunction match = find_matching_nodes(mdl, nodes,th)">find_matching_nodes</a>(mdl2,enodes,1e-5);
0128 <span class="keyword">end</span>
0129 
0130 <a name="_sub1" href="#_subfunctions" class="code">function debugging = do_debug;</a>
0131   debugging = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'place_elec_on_surf'</span>);
0132 
0133 <a name="_sub2" href="#_subfunctions" class="code">function write_to_stl(mdl,stlfn)</a>
0134 STL.vertices = mdl.nodes;
0135 STL.faces    = mdl.elems;
0136 <a href="../../eidors/meshing/stl/stl_write.html" class="code" title="function stl_write(fv, name)">stl_write</a>(STL,stlfn);
0137 
0138 <a name="_sub3" href="#_subfunctions" class="code">function write_ng_opt_file(ng_opt_file, maxh)</a>
0139 <span class="comment">% these options are meant to insure that the electrode sides don't get</span>
0140 <span class="comment">% modified, but there's no guarantee</span>
0141 <span class="keyword">if</span> ~isempty(ng_opt_file)
0142    <a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>(ng_opt_file);
0143 <span class="keyword">else</span>
0144    opt.meshoptions.fineness = 6; <span class="comment">% some options have no effect without this</span>
0145    opt.options.curvaturesafety = 0.2;
0146    <span class="comment">% small yangle preserves the original mesh, large encourages smoother</span>
0147    <span class="comment">% surface with nicer spreading of refinement</span>
0148    opt.stloptions.yangle = 30; <span class="comment">% was 10</span>
0149  <span class="comment">%    opt.stloptions.contyangle = 20;</span>
0150    opt.stloptions.edgecornerangle = 0;
0151 <span class="comment">%    opt.stloptions.chartangle = 0;</span>
0152    opt.stloptions.outerchartangle = 120;
0153    opt.stloptions.resthchartdistenable = 1;
0154    opt.stloptions.resthchartdistfac = 2.0; <span class="comment">% encourages slower increase of element size</span>
0155    <span class="keyword">if</span> ~isempty(maxh)
0156       opt.options.meshsize = maxh;
0157    <span class="keyword">end</span>
0158    opt.meshoptions.laststep = <span class="string">'mv'</span>; <span class="comment">% don't need volume optimization</span>
0159    opt.options.optsteps2d =  5; <span class="comment">% but we can up surface optimization</span>
0160    opt.options.badellimit = 120; <span class="comment">% decrease the maximum allowed angle</span>
0161    <a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>(opt);
0162 <span class="keyword">end</span>
0163 
0164 
0165 <span class="comment">% Extract a nice surface model from the one given</span>
0166 <a name="_sub4" href="#_subfunctions" class="code">function mdl = prepare_surf_model(mdl)</a>
0167 <span class="keyword">try</span> mdl = rmfield(mdl,<span class="string">'boundary'</span>);  <span class="keyword">end</span>
0168 mdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0169 mdl = <a href="#_sub5" class="code" title="subfunction mdl = orient_boundary(mdl)">orient_boundary</a>(mdl);
0170 mdl.elems = mdl.boundary;
0171 mdl.faces = mdl.boundary;
0172 mdl.face_centre = mdl.face_centre(mdl.boundary_face,:);
0173 mdl.normals = mdl.normals(mdl.boundary_face,:);
0174 mdl = rmfield(mdl, <span class="string">'inner_normal'</span>);
0175 mdl = rmfield(mdl, <span class="string">'boundary_face'</span>);
0176 idx = nchoosek(1:3, 2);
0177 elem_sorted = sort(mdl.elems,2);
0178 [mdl.edges ib ia] = unique(reshape(elem_sorted(:,idx),[],2),<span class="string">'rows'</span>);
0179 D = mdl.nodes(mdl.edges(:,1),:) - mdl.nodes(mdl.edges(:,2),:);
0180 mdl.edge_len = sqrt(sum(D.^2,2)); 
0181 
0182 <a name="_sub5" href="#_subfunctions" class="code">function mdl = orient_boundary(mdl)</a>
0183 <span class="comment">% consistently orient boundary elements</span>
0184 flip = mdl.elem2face(logical(mdl.boundary_face(mdl.elem2face).*mdl.inner_normal));
0185 mdl.faces(flip,:) = mdl.faces(flip,[1 3 2]);
0186 mdl.normals(flip,:) = -mdl.normals(flip,:);
0187 mdl.boundary = mdl.faces(mdl.boundary_face,:);
0188 
0189 
0190 <a name="_sub6" href="#_subfunctions" class="code">function mdl = flatten_electrode(mdl,inner,outer, V)</a>
0191 n1 = <a href="#_sub7" class="code" title="subfunction match = find_matching_nodes(mdl, nodes,th)">find_matching_nodes</a>(mdl,inner, 1e-2);
0192 n2 = <a href="#_sub7" class="code" title="subfunction match = find_matching_nodes(mdl, nodes,th)">find_matching_nodes</a>(mdl,outer, 1e-5);
0193 <span class="comment">% remove the side nodes of the electrode</span>
0194 N1 = false(length(mdl.nodes),1);
0195 N1(n1) = true;
0196 N2 = false(length(mdl.nodes),1);
0197 N2(n2) = true;
0198 rm = sum(N1(mdl.elems),2)&gt;0 &amp; sum(N2(mdl.elems),2)&gt;0;
0199 
0200 f = find(sum(N2(mdl.elems),2)&gt;1 &amp; ~rm,1,<span class="string">'first'</span>);
0201 B = find(mdl.boundary_face);
0202 p = mdl.face_centre(B(f),:);
0203 r = Inf;
0204 mdl.elems(rm,:) = [];
0205 mdl.boundary = mdl.elems;
0206 mdl.boundary_face(B(rm)) = [];
0207 mdl.face_centre(B(rm),:) = [];
0208 mdl.normals(B(rm),:)     = [];
0209 mdl.faces(B(rm),:)       = [];
0210 f = f - nnz(rm(1:f));
0211 N = <a href="#_sub13" class="code" title="subfunction out = grow_neighbourhood(mdl, varargin)">grow_neighbourhood</a>(mdl,f,p,r);
0212 
0213 <span class="comment">% WARNING: Here we assume the sides of the electrode are one element high!</span>
0214 
0215 <span class="comment">%nodes to move</span>
0216 ntm = unique(mdl.elems(N,:));
0217 mdl.nodes(ntm,:) = mdl.nodes(ntm,:) - repmat(V,length(ntm),1);
0218 e_nodes = ntm;
0219 
0220 <span class="comment">%remap outer nodes to inner ones</span>
0221 map = 1:length(mdl.nodes);
0222 map(n2) = n1;
0223 mdl.elems = map(mdl.elems);
0224 mdl.faces = map(mdl.faces);
0225 e_nodes = map(ntm);
0226 
0227 <span class="comment">% remove the outer nodes</span>
0228 m = true(length(mdl.nodes),1);
0229 m(n2) = false;
0230 map = zeros(size(m));
0231 map(m) = 1:nnz(m);
0232 
0233 mdl.nodes(n2,:) = [];
0234 mdl.elems = map(mdl.elems);
0235 mdl.faces = map(mdl.faces);
0236 e_nodes = map(e_nodes);
0237 
0238 mdl.boundary = mdl.elems;
0239 <span class="keyword">if</span> ~isfield(mdl,<span class="string">'electrode'</span>)
0240    mdl.electrode = struct();
0241    l = 1;
0242 <span class="keyword">else</span>
0243    l = length(mdl.electrode);
0244    <span class="comment">% because we are changing the number of nodes, we need to correct the</span>
0245    <span class="comment">% electrodes that are there already</span>
0246    <span class="keyword">for</span> i = 1:l
0247       mdl.electrode(i).nodes = map(mdl.electrode(i).nodes);
0248    <span class="keyword">end</span>
0249    l = l + 1;
0250 <span class="keyword">end</span>
0251 mdl.electrode(l).nodes = double(e_nodes);
0252 mdl.electrode(l).z_contact = 0.01;
0253 
0254 <span class="keyword">if</span> do_debug
0255    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0256 <span class="keyword">end</span>
0257 
0258 
0259 <a name="_sub7" href="#_subfunctions" class="code">function match = find_matching_nodes(mdl, nodes,th)</a>
0260 l0 = length(mdl.nodes);
0261 match = 0 * (1:length(nodes));
0262 <span class="keyword">for</span> n = 1:length(nodes)
0263    D = mdl.nodes - repmat(nodes(n,:),l0,1);
0264    D = sqrt(sum(D.^2,2));
0265    [val p] = min(D);
0266    <span class="keyword">if</span> val &lt; th
0267       match(n) = p;
0268    <span class="keyword">end</span>
0269 <span class="keyword">end</span>
0270 
0271 <span class="comment">% Returns a joint surface mesh and the list of nodes on the side of the</span>
0272 <span class="comment">% electrode</span>
0273 <a name="_sub8" href="#_subfunctions" class="code">function [joint EL1 EL2 V] = add_electrodes(mdl,N,elecs)</a>
0274 
0275 
0276 fc = <a href="#_sub15" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs.pos);
0277 <span class="comment">% N indexes the boundary, need index into faces</span>
0278 <span class="comment">% fcs = find(mdl.boundary_face);</span>
0279 <span class="comment">% fcs = fcs(N);</span>
0280 fcs = N;
0281 
0282 jnk.type = <span class="string">'fwd_model'</span>;
0283 jnk.elems = mdl.boundary(N,:);
0284 jnk.nodes = mdl.nodes;
0285 jnk.boundary = jnk.elems;
0286 img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(jnk,1);
0287 <span class="keyword">if</span> do_debug
0288    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(jnk);
0289    hold on
0290    plot3(elecs.points(:,1),elecs.points(:,2),elecs.points(:,3),<span class="string">'ro'</span>);
0291    <span class="comment">% plot3(mdl.nodes(nn(outer),1), mdl.nodes(nn(outer),2), mdl.nodes(nn(outer),3),'bs')</span>
0292    hold off
0293 <span class="keyword">end</span>
0294 
0295 
0296 <span class="comment">%nodes used</span>
0297 [nn,I, J] = unique(mdl.faces(fcs,:));
0298 outer = true(size(nn));
0299 <span class="keyword">for</span> i = 1:length(nn)
0300    <span class="keyword">if</span> sum(J==i) == sum(mdl.boundary(:) == nn(i))
0301       outer(i) = false;
0302    <span class="keyword">end</span>
0303 <span class="keyword">end</span>
0304 <span class="comment">% we want to keep the ones on the outside</span>
0305 keep = false(size(mdl.nodes,1),1);
0306 keep(nn) = outer;
0307 keep = keep(jnk.elems);
0308 
0309 <span class="comment">% this will not catch the situation where the element reaches from boundary</span>
0310 <span class="comment">% to boundary and the electrode is in the middle (small electrode, big</span>
0311 <span class="comment">% element). Fortunately, in these cases the edge will be there twice</span>
0312 edges = reshape(jnk.elems(:,[1 2 2 3 3 1])',2,[])';
0313 <span class="keyword">if</span> size(keep,2) == 1; keep = shiftdim(keep,1); <span class="keyword">end</span>
0314 keep = reshape(keep(:,[1 2 2 3 3 1])',2,[])';
0315 rm = sum(keep,2)&lt;2;
0316 edges(rm,:) = [];
0317 
0318 <span class="comment">% detect and remove double entries</span>
0319 rm = ismember(edges,edges(:,[2 1]),<span class="string">'rows'</span>);
0320 edges(rm,:) = [];
0321 
0322 <span class="comment">% project all nodes of the faces in N onto the plane of the electrode</span>
0323 nodes = unique(mdl.faces(fcs,:));
0324 PN = <a href="#_sub9" class="code" title="subfunction PN = project_nodes_on_elec(mdl,elecs,nodes)">project_nodes_on_elec</a>(mdl,elecs,nodes);
0325 
0326 <span class="comment">% electrode coordinate system</span>
0327 [u v s] = <a href="#_sub11" class="code" title="subfunction [u v s] = get_face_basis(mdl, fc)">get_face_basis</a>(mdl,fc);
0328 <span class="comment">% u = mdl.normals(fc,:); % unit normal</span>
0329 <span class="comment">% % vertical vector on the plane of that surface triangle</span>
0330 <span class="comment">% v = [0 0 1] - dot([0 0 1],u) *u; v = v/norm(v);</span>
0331 <span class="comment">% s = cross(u,v); s= s/norm(s);</span>
0332 
0333 <span class="comment">% mark nodes that are too close to elecs.points for removal</span>
0334 rm = false(length(PN),1);
0335 <span class="keyword">for</span> i = 1:length(PN)
0336    D = repmat(PN(i,:),length(elecs.points),1) - elecs.points;
0337    D = sqrt(sum(D.^2,2));
0338    <span class="keyword">if</span> any(D &lt; 2*elecs.maxh)
0339       rm(i) = true;
0340    <span class="keyword">end</span>
0341 <span class="keyword">end</span>
0342 
0343 <span class="comment">% we can only delete if it's not part of the boundary</span>
0344 b = unique(edges(:));
0345 rm = find(rm);
0346 rm(ismember(nodes(rm),b)) = [];
0347 
0348 <span class="comment">% remove and remap</span>
0349 PN(rm,:) = [];
0350 nodes(rm) = [];
0351 
0352 points = [PN; elecs.points];
0353 np = size(points,1);
0354 x = dot(points,repmat(v,np,1),2);
0355 y = dot(points,repmat(s,np,1),2);
0356 
0357 map(nodes) = 1:length(nodes);
0358 edges = map(edges); <span class="comment">%</span>
0359 
0360 <span class="comment">% constrained Delaunay triangulation in 2D</span>
0361 f = length(PN) +(1:2);
0362 C = [];
0363 <span class="keyword">for</span> i= 0:length(elecs.points)-2
0364    C = [C; i+f];
0365 <span class="keyword">end</span>
0366 D = DelaunayTri([x y],[edges; C]);
0367 els = D.Triangulation(D.inOutStatus,:);
0368 
0369 
0370 <span class="comment">% project all electrode points on all triangles, using the normal of the central elem</span>
0371 Ne = mdl.normals(fc,:);
0372 <span class="keyword">for</span> j = 1:length(elecs.nodes)
0373    Pe = elecs.nodes(j,:);
0374    <span class="keyword">for</span> i = 1:length(fcs)
0375       Nf = mdl.normals(fcs(i),:);
0376       Cf = mdl.face_centre(fcs(i),:);
0377       <span class="comment">% the plane is (X - Cf).Nf = 0</span>
0378       <span class="comment">% the line is X = Pe + tNe (through Pe perpendicular to the main elec</span>
0379       <span class="comment">% face</span>
0380       <span class="comment">% We want X that satisfies both.</span>
0381       <span class="comment">% (Pe +tNe -  Cf).Nf = 0</span>
0382       <span class="comment">% (Pe - Cf).Nf + tNe.Nf = 0</span>
0383       <span class="comment">% t = (Cf-Pe).Nf / (Ne.Nf)</span>
0384       <span class="comment">% X = Pe + Ne * (Cf-Pe).Nf / (Ne.Nf)</span>
0385       X = Pe + Ne * dot(Cf-Pe,Nf) / dot(Ne,Nf) ;
0386       <span class="keyword">if</span> <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(X, mdl.faces(fcs(i),:), mdl.nodes)
0387          Proj(j,:) = X;
0388          FC(j) = fcs(i);
0389          <span class="keyword">break</span>;
0390       <span class="keyword">end</span>
0391    <span class="keyword">end</span>
0392 <span class="keyword">end</span>
0393 
0394 <span class="comment">% this is just output</span>
0395 EL1 = Proj(1:length(elecs.points),:);
0396 
0397 <span class="comment">% remove any nodes inside the electrode</span>
0398 ln = length(nodes);
0399 <span class="comment">% IN = inpolygon(x(1:ln),y(1:ln),x(ln+1:end),y(ln+1:end));</span>
0400 <span class="comment">% nodes(IN) = [];</span>
0401 
0402 add = elecs.maxh;
0403 
0404 nn = mdl.nodes(nodes,:);<span class="comment">% + add * repmat(IN,1,3) .* repmat(Ne,ln,1);</span>
0405 le = length(elecs.nodes);
0406 ne = Proj + add * repmat(Ne,le,1);
0407 
0408 <span class="comment">%this is just output</span>
0409 EL2 = ne(1:length(elecs.points),:);
0410 V = add*Ne;
0411 
0412 <span class="comment">% the nodes of the electrode</span>
0413 <span class="comment">% IN = [IN; ones(le,1)];</span>
0414 el_c = D.incenters;
0415 el_c(~D.inOutStatus,:) = [];
0416 e_el = inpolygon(el_c(:,1),el_c(:,2),x(ln+1:end),y(ln+1:end));
0417 els(e_el,:) = []; <span class="comment">% els(e_el,:) + (els(e_el,:)&gt;ln ) .* le;</span>
0418 
0419 <span class="comment">% add connecting elements</span>
0420 E = [];
0421 le = length(elecs.points);
0422 f = ln + [ 1 le+1 le+2; le+2 2 1];
0423 <span class="keyword">for</span> j = 0:(le-2)
0424    E = [E; j+f];
0425 <span class="keyword">end</span>
0426 M = ln + [le+1 le 2*le; le le+1 1];
0427 E = [E; M];
0428 
0429 jnk.nodes = [nn ; Proj(1:le,:);  ne];
0430 jnk.elems = [ els; E; elecs.elems+ln+le];
0431 jnk.boundary = jnk.elems;
0432 <span class="keyword">if</span> do_debug
0433    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(jnk);
0434 <span class="keyword">end</span>
0435 
0436 <span class="comment">% remove the patch we're replacing</span>
0437 big = mdl;
0438 big.boundary(N,:) = [];
0439 big.faces(N,:) = [];
0440 big.normals(N,:) = [];
0441 big.face_centre(N,:) = [];
0442 
0443 big.elems = big.boundary;
0444 
0445 joint = <a href="merge_meshes.html" class="code" title="function out = merge_meshes(M1,varargin)">merge_meshes</a>(big,jnk,0.001);
0446 joint.boundary = joint.elems;
0447 joint.faces = joint.boundary;
0448 opt.normals = true;
0449 opt.face_centre = true;
0450 joint = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(joint,opt);
0451 
0452 <a name="_sub9" href="#_subfunctions" class="code">function PN = project_nodes_on_elec(mdl,elecs,nodes)</a>
0453 fc = <a href="#_sub15" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs.pos);
0454 Ne = mdl.normals(fc,:);
0455 Pe = elecs.pos;
0456 <span class="keyword">for</span> i = 1:length(nodes)
0457    P = mdl.nodes(nodes(i),:);
0458    PN(i,:) = P + dot(Pe - P, Ne) * Ne;
0459 <span class="keyword">end</span>
0460 
0461 <span class="comment">% OUTPUT:</span>
0462 <span class="comment">%  elecs(i).pos   = [x,y,z]</span>
0463 <span class="comment">%  elecs(i).shape = 'C' or 'R'</span>
0464 <span class="comment">%  elecs(i).dims  = [radius] or [width,height]</span>
0465 <span class="comment">%  elecs(i).maxh  = '-maxh=#' or '';</span>
0466 <span class="comment">%  elecs(i).points= list of points around the perimeter</span>
0467 <span class="comment">% Angles (th) are interpreted with the mean of boundary nodes as origin</span>
0468 <a name="_sub10" href="#_subfunctions" class="code">function [elecs] = parse_elecs(mdl, elec_pos, elec_shape )</a>
0469 elecs = [];
0470 
0471 <span class="keyword">if</span> size(elec_shape,2) &lt; 3
0472    elec_shape(:,3) = elec_shape(:,1)/10;
0473 <span class="keyword">end</span>
0474 
0475 have_xyz = 0;
0476 
0477 <span class="keyword">if</span> size(elec_pos,1) == 1
0478    <span class="comment">% Parse elec_pos = [n_elecs_per_plane,(0=equal angles,1=equal dist),z_planes]</span>
0479    n_elecs= elec_pos(1); <span class="comment">% per plane</span>
0480    offset = elec_pos(2) - floor(elec_pos(2));
0481    <span class="keyword">switch</span> floor(elec_pos(2))
0482       <span class="keyword">case</span> 0
0483          th = linspace(0,2*pi, n_elecs+1)'; th(end)=[];
0484          th = th + offset*2*pi;
0485          ind = th &gt;= 2*pi;
0486          th(ind) = th(ind) - 2*pi;
0487       <span class="keyword">case</span> 1
0488          error(<span class="string">'not implemented yet'</span>);
0489    <span class="keyword">end</span>
0490    on_elecs = ones(n_elecs, 1);
0491    el_th = [];
0492    el_z  = [];
0493    <span class="keyword">for</span> i=3:length(elec_pos)
0494       el_th = [el_th; th];
0495       el_z  = [el_z ; on_elecs*elec_pos(i)];
0496    <span class="keyword">end</span>
0497 <span class="keyword">elseif</span> size(elec_pos,2) == 2
0498    <span class="comment">% elec_pos = [theta z];</span>
0499    el_th = elec_pos(:,1)*2*pi/360;
0500    el_z  = elec_pos(:,2);
0501 <span class="keyword">elseif</span> size(elec_pos,2) == 3
0502    <span class="comment">% elec_pos = [x y z];</span>
0503    have_xyz = 1;
0504    el_z  = elec_pos(:,3);
0505 <span class="keyword">end</span>
0506 
0507 <span class="keyword">if</span> ~have_xyz
0508    el_th(el_th&gt;pi) =  el_th(el_th&gt;pi) - 2*pi;
0509    el_th(el_th&lt;-pi) = el_th(el_th&lt;-pi) + 2*pi;
0510 <span class="keyword">end</span>
0511 n_elecs= size(el_z,1);
0512 
0513 <span class="keyword">if</span> size(elec_shape,1) == 1
0514    elec_shape = ones(n_elecs,1) * elec_shape;
0515 <span class="keyword">end</span>
0516 
0517 <span class="keyword">for</span> i = 1:n_elecs
0518    <span class="keyword">if</span> ~have_xyz
0519       [fc elecs(i).pos] = <a href="#_sub12" class="code" title="subfunction [fc pos] = find_elec_centre(mdl, el_th,el_z)">find_elec_centre</a>(mdl,el_th(i),el_z(i));
0520    <span class="keyword">else</span>
0521       elecs(i).pos = elec_pos(i,:);
0522    <span class="keyword">end</span>
0523 <span class="comment">%    elecs(i).face = fc; % this changes too often to store!</span>
0524    elecs(i).dims = elec_shape(i,1:2);
0525    elecs(i).dims(elecs(i).dims==0) = [];
0526    elecs(i).maxh = elec_shape(i,3);
0527    
0528    <span class="keyword">if</span> elec_shape(i,2) == 0
0529       elecs(i).shape = <span class="string">'C'</span>;
0530       r = elec_shape(i,1);
0531       n = ceil(2*pi*elec_shape(i,1) / elec_shape(i,3));
0532       t = linspace(0,2*pi,n+1); t(end) = [];
0533       x = r*sin(t); y = r*cos(t);
0534    <span class="keyword">else</span>
0535       elecs(i).shape = <span class="string">'R'</span>;
0536       height = elec_shape(i,1); width = elec_shape(i,2); d_org = elec_shape(i,3);
0537       <span class="comment">% enforce a minimum of 5 nodes per side</span>
0538       d = min( [ d_org , height/5, width/5]);
0539       <span class="keyword">if</span> d &lt; d_org
0540          elecs(i).maxh = d;
0541          <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ Decreased maxh of electrode %d from %f to %f'</span>,i,d_org, d,2);
0542       <span class="keyword">end</span>
0543       nh = ceil(height/d)+1; nw = ceil(width/d)+1; 
0544       ph = linspace(-height/2,height/2,nh);
0545       pw = linspace(-width/2,width/2,nw);
0546       y = [ph, ph(end)*ones(1,nw-2), fliplr(ph), ph(1)*ones(1,nw-2)];
0547       x = [pw(1)*ones(1,nh-1), pw, pw(end)*ones(1,nh-2), fliplr(pw(2:end))];
0548       <span class="comment">%    % we don't want real rectangles, because Netgen will merge coplanar</span>
0549       <span class="comment">%    % faces, so we create a nice superellipse instead</span>
0550       n = 2*(nh+nw);
0551       <span class="comment">%    t = linspace(2*pi,0,n); t(end) = [];</span>
0552       <span class="comment">%    N = 8;</span>
0553       <span class="comment">%    x = abs(cos(t)).^(2/N) * width/2  .* sign(cos(t));</span>
0554       <span class="comment">%    y = abs(sin(t)).^(2/N) * height/2 .* sign(sin(t));</span>
0555       <span class="comment">% superellipses are also bad, what about a wavy rectange?</span>
0556 <span class="comment">%       [pp] = fourier_fit([x; y]', min(size(x,2),18) );</span>
0557 <span class="comment">%       t = linspace(0,1,n+1); t(end) = [];</span>
0558 <span class="comment">%       xy = fourier_fit(pp,t);</span>
0559 <span class="comment">%       x = xy(:,1)'; y = xy(:,2)';</span>
0560       <span class="comment">% wavy rectangles are nice but don't guarantee absence of co-planar</span>
0561       <span class="comment">% faces</span>
0562       <span class="comment">% let's try a brute-force approach</span>
0563       e = tand(0.5)*d;
0564       x = x + e* [0 power(-1,0:nh-3) zeros(1,nw)  power(-1,0:nh-3) zeros(1,nw-1)];
0565       y = y + e* [zeros(1,nh) power(-1,0:nw-3) zeros(1,nh) power(-1,0:nw-3)];
0566    <span class="keyword">end</span>
0567    fc = <a href="#_sub15" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs(i).pos);
0568    [u v s] = <a href="#_sub11" class="code" title="subfunction [u v s] = get_face_basis(mdl, fc)">get_face_basis</a>(mdl, fc);
0569    
0570    np = length(x);
0571 <span class="comment">%    elecs(i).points = flipud(ones(size(x))' * elecs(i).pos + x'*s + y'*v);</span>
0572 
0573    <a href="../../eidors/meshing/netgen/ng_write_opt.html" class="code" title="function opt = ng_write_opt(varargin)">ng_write_opt</a>(<span class="string">'meshoptions.fineness'</span>,1,<span class="string">'options.meshsize'</span>,1.2*elecs(i).maxh);
0574    emdl = <a href="../../eidors/meshing/netgen/ng_mk_2d_model.html" class="code" title="function mdl = ng_mk_2d_model(varargin)">ng_mk_2d_model</a>(flipud([x', y']));
0575    x = emdl.nodes(:,1); y = emdl.nodes(:,2);
0576    elecs(i).nodes = ones(size(x)) * elecs(i).pos + x*s + y*v;
0577    elecs(i).elems = emdl.elems(:,[1 3 2]); <span class="comment">% flip orientation to the outside</span>
0578    elecs(i).points = elecs(i).nodes(1:np,:); <span class="comment">% this must be the boundary</span>
0579    <span class="comment">% TODO: write code to check if this is true</span>
0580    
0581 <span class="keyword">end</span>
0582 delete(<span class="string">'ng.opt'</span>);
0583 
0584 <a name="_sub11" href="#_subfunctions" class="code">function [u v s] = get_face_basis(mdl, fc)</a>
0585    u = mdl.normals(fc,:); <span class="comment">% unit normal</span>
0586    <span class="comment">% vertical vector on the plane of that surface triangle</span>
0587    v = [0 0 1] - dot([0 0 1],u) *u;
0588    <span class="keyword">if</span> norm(v) == 0
0589       <span class="comment">% the element is horizontal</span>
0590       v = [0 1 0] - dot([0 1 0],u)*u;
0591    <span class="keyword">end</span>
0592    v = v/norm(v);
0593    s = cross(u,v); s= s/norm(s);
0594 
0595 <a name="_sub12" href="#_subfunctions" class="code">function [fc pos] = find_elec_centre(mdl, el_th,el_z)</a>
0596 fc = [];
0597 pos = [];
0598 
0599 Ctr = mean(mdl.nodes(mdl.boundary,:));
0600 Ctr(3) = el_z;
0601 
0602 <span class="comment">%1. Find edges that cross the z plane</span>
0603 n_above = mdl.nodes(:,3) &gt;= el_z;
0604 sum_above = sum(n_above(mdl.edges),2) ;
0605 edg = sum_above == 1;
0606 
0607 <span class="comment">%2. Find an edge that crosses el_th</span>
0608 n = unique(mdl.edges(edg,:));
0609 nn = mdl.nodes(n,1:2);
0610 nn = nn - repmat(Ctr(:,1:2),length(nn),1);
0611 th = cart2pol(nn(:,1),nn(:,2));
0612 th(:,2) = 1:length(th);
0613 th = sortrows(th);
0614 idx = find(th(:,1) &gt; el_th,1,<span class="string">'first'</span>);
0615 <span class="keyword">if</span> isempty(idx) || idx == 1
0616    n1 = n(th(1,2));
0617    n2 = n(th(<span class="keyword">end</span>,2));
0618    <span class="comment">% edges in edg that contain these nodes (they don't need to be on the</span>
0619    <span class="comment">% same element)</span>
0620    ed = edg &amp; sum( (mdl.edges == n1) + (mdl.edges == n2) ,2) &gt; 0;
0621 <span class="keyword">else</span>
0622 <span class="comment">%    to_the_left = false(length(mdl.nodes),1);</span>
0623 <span class="comment">%    to_the_left(n(th(1:idx-1,2))) = true;</span>
0624 <span class="comment">%    sum_left = sum( to_the_left(mdl.boundary), 2);</span>
0625 <span class="comment">%    el = els &amp; sum_left &gt; 0 &amp; sum_left &lt; 3;</span>
0626    n1 = n(th(idx-1,2));
0627    n2 = n(th(idx,  2));
0628    ed = edg &amp; sum( (mdl.edges == n1) + (mdl.edges == n2) ,2) &gt; 0;
0629 <span class="keyword">end</span>
0630 
0631 el = false(length(mdl.boundary),1);
0632 <span class="keyword">for</span> i = find(ed)'
0633    n1 = mdl.edges(i,1);
0634    n2 = mdl.edges(i,2);
0635    el = el | sum( (mdl.boundary == n1) + (mdl.boundary == n2), 2) == 2;
0636 <span class="keyword">end</span>
0637 el = find(el);
0638 <span class="comment">% fcs = find(mdl.boundary_face);</span>
0639 <span class="comment">% fcs = fcs(el);</span>
0640 
0641 [De(1) De(2) De(3)]  = pol2cart(el_th,1, 0); 
0642 <span class="keyword">for</span> i = 1:length(el)
0643    Nf = mdl.normals(el(i),:);
0644    Cf = mdl.face_centre(el(i),:);
0645    <span class="comment">% the plane is (X - Cf).Nf = 0</span>
0646    <span class="comment">% the line is X = Ctr + tDe (through Ctr along De</span>
0647    <span class="comment">% We want X that satisfies both.</span>
0648    <span class="comment">% (Ctr +tDe -  Cf).Nf = 0</span>
0649    <span class="comment">% (Ctr - Cf).Nf + tDe.Nf = 0</span>
0650    <span class="comment">% t =</span>
0651    <span class="comment">% X = Ctr + De * (Cf-Ctr).Nf / (De.Nf)</span>
0652    t = dot(Cf-Ctr,Nf) / dot(De,Nf);
0653    <span class="keyword">if</span> t &lt; 0, <span class="keyword">continue</span>, <span class="keyword">end</span>
0654    X = Ctr + De * t ;
0655    <span class="keyword">if</span> <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(X, mdl.faces(el(i),:), mdl.nodes)
0656       pos = X;
0657       fc = el(i);
0658       <span class="keyword">break</span>;
0659    <span class="keyword">end</span>
0660    
0661    <span class="comment">% project the line on this element</span>
0662    <span class="comment">% check if it falls inside</span>
0663 <span class="keyword">end</span>
0664 <span class="keyword">if</span> isempty(pos)
0665    keyboard
0666 <span class="keyword">end</span>
0667 
0668 <a name="_sub13" href="#_subfunctions" class="code">function out = grow_neighbourhood(mdl, varargin)</a>
0669 use_elec = false;
0670 <span class="keyword">if</span> length(varargin) == 1
0671    use_elec = true;
0672    elecs = varargin{1};
0673    fc = <a href="#_sub15" class="code" title="subfunction [e p] = find_face_under_elec(mdl, elec_pos)">find_face_under_elec</a>(mdl,elecs.pos);
0674    p = elecs.pos;
0675    <span class="keyword">switch</span> elecs.shape
0676       <span class="keyword">case</span> <span class="string">'R'</span>
0677          r = sqrt(sum(elecs.dims.^2,2));
0678       <span class="keyword">case</span> <span class="string">'C'</span>
0679          r = 2 * elecs.dims(1);
0680    <span class="keyword">end</span>
0681 <span class="keyword">else</span>
0682    fc = varargin{1};
0683    p = varargin{2};
0684    r = varargin{3};
0685 <span class="keyword">end</span>
0686 
0687 done = false(length(mdl.boundary),1);
0688 todo = false(length(mdl.boundary),1);
0689 todo(fc) = true;
0690 bb = mdl.boundary;
0691 vv = mdl.nodes;
0692 <span class="comment">% distance of each vertex to the line perpendicular to face fc passing</span>
0693 <span class="comment">% through p</span>
0694 dv = vv - repmat(p,length(vv),1);
0695 nl = mdl.normals;
0696 nl = repmat(nl(fc,:),length(vv),1);
0697 dd = sqrt(sum( (dv - repmat(dot(dv,nl,2),1,3) .* nl).^2,2));
0698 dim = size(bb,2);
0699 first = true; <span class="comment">% at first iteration, add all neighbours</span>
0700 <span class="keyword">if</span> use_elec
0701    PN = <a href="#_sub9" class="code" title="subfunction PN = project_nodes_on_elec(mdl,elecs,nodes)">project_nodes_on_elec</a>(mdl,elecs,1:length(mdl.nodes));
0702    emin = min(elecs.points);
0703    emax = max(elecs.points);
0704    rng = emax-emin;
0705    emin = emin - 0.1*rng;
0706    emax = emax + 0.1*rng;
0707    toofar = false(size(mdl.boundary,1),1);
0708    
0709    <span class="keyword">for</span> i = 1:3
0710       nodes = reshape(PN(mdl.boundary,i),[],3);
0711       toofar =  toofar |  sum(nodes &gt; emax(i),2) == 3 | sum(nodes &lt; emin(i),2) == 3;
0712    <span class="keyword">end</span>
0713 <span class="keyword">end</span>
0714 <span class="keyword">while</span> any(todo)
0715    id = find(todo,1,<span class="string">'first'</span>);
0716    done(id) = 1;
0717    nn = <a href="#_sub14" class="code" title="subfunction nn =  find_neighbours(fc, bb);">find_neighbours</a>(id,bb);
0718    <span class="keyword">if</span> use_elec
0719       nn = nn &amp; ~toofar;
0720    <span class="keyword">elseif</span> first
0721       <span class="comment">% include all neighbours</span>
0722       first = false;
0723    <span class="keyword">else</span>
0724       <span class="comment">% at least one node must be close enough</span>
0725       nn = nn &amp; sum(dd(bb) &lt;= r,2) &gt; 0;
0726    <span class="keyword">end</span>
0727    todo = todo | nn;
0728    todo(done) = 0;
0729 <span class="comment">%    disp(sprintf('id: %d done: %d todo: %d',id, nnz(done),nnz(todo)));</span>
0730 <span class="comment">%    disp(find(todo)');</span>
0731 <span class="comment">%    disp(find(done)');</span>
0732 <span class="keyword">end</span>
0733 out = find(done);
0734 
0735 
0736 <a name="_sub14" href="#_subfunctions" class="code">function nn =  find_neighbours(fc, bb);</a>
0737 dim = size(bb,2);
0738 nn = false(length(bb),1);
0739 <span class="keyword">for</span> i = 1:dim
0740    node = bb(fc,i);
0741    nn = nn | sum(bb == node,2) &gt; 0;
0742 <span class="keyword">end</span>
0743 nn(fc) = 0;
0744 
0745 <a name="_sub15" href="#_subfunctions" class="code">function [e p] = find_face_under_elec(mdl, elec_pos)</a>
0746 <span class="keyword">for</span> i = 1:size(elec_pos,1)
0747    <span class="comment">% 1. Project electrode on all faces</span>
0748    ee = repmat(elec_pos(i,:),length(mdl.faces),1);
0749    fc = mdl.face_centre;
0750    n  = mdl.normals;
0751    proj1 = ee - repmat(dot(ee-fc, n,2),1,3) .* n;
0752    in1 = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(proj1,mdl.faces,mdl.nodes, <span class="string">'match'</span>);
0753    dis1 = sqrt(sum((ee-proj1).^2,2));
0754    <span class="comment">% 2. Project electrode on all edges</span>
0755    edg = [mdl.faces(:,1:2);mdl.faces(:,2:3);mdl.faces(:,[3 1])];
0756    edg = sort(edg,2);
0757    [edg jnk e2f] = unique(edg,<span class="string">'rows'</span>);
0758    ee = repmat(elec_pos(i,:),length(edg),1);
0759    s = mdl.nodes(edg(:,2),:) - mdl.nodes(edg(:,1),:); <span class="comment">%edge direction vector</span>
0760    t = dot(ee-mdl.nodes(edg(:,1),:),s,2)./dot(s,s,2);
0761    in2 = t&gt;=0 &amp; t &lt;=1;
0762    in2 = any(reshape(in2(e2f),[],3),2);
0763    proj2 = mdl.nodes(edg(:,1),:) + repmat(t,1,3).*s;
0764    dis = sqrt(sum((ee - proj2).^2,2));
0765    dis = repmat(dis,2,1);
0766    dis(t&lt;0 | t &gt; 1) = Inf;
0767    dis = reshape(dis(e2f),[],3);
0768    [jnk, pos] = min(dis,[],2);
0769    idx = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(1:length(pos),pos,1);
0770    dis = dis';
0771    dis2 = dis(logical(idx'));
0772 
0773    in = in1 | in2;
0774    <span class="keyword">if</span> nnz(in) == 1
0775          e(i) = find(in1);  <span class="comment">% this should be an index into mdl.boundary</span>
0776          p(i,:) = proj1(in1,:);
0777    <span class="keyword">else</span>
0778       <span class="comment">% take the element that is closest to ee</span>
0779       cand = find(in);
0780       dd(in1(cand)) = dis1(in1);
0781       dd(in2(cand)) = dis2(in2);
0782       [jnk pos] = min(dd);
0783       e(i) = cand(pos);
0784       p(i,:) = proj1(e(i),:);
0785    <span class="keyword">end</span>
0786 
0787 <span class="keyword">end</span>
0788 
0789 
0790 <a name="_sub16" href="#_subfunctions" class="code">function do_unit_test</a>
0791 xy= [ -0.89 -0.74 -0.21  0.31  0.79  0.96  0.67  0.05 -0.36 -0.97;
0792        0.14  0.51  0.35  0.50  0.27 -0.23 -0.86 -0.69 -0.85 -0.46]';
0793 [fmdl] = <a href="../../eidors/meshing/netgen/ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>({2,xy,[4,80],},[],[]);
0794 elec_pos = [-0.5, -0.8, 1];
0795 <span class="comment">% place_elec_on_surf(fmdl, elec_pos, [0.1 0 0.01]);</span>
0796 <span class="comment">% place_elec_on_surf(fmdl, elec_pos, [0.15 0.1 0.01]);</span>
0797 mdl = <a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>(fmdl, [16 0 1], [0.15 0.1 0.01]);
0798 <span class="comment">% place_elec_on_surf(fmdl, [16 0 1], [0.1 0 0.01]);</span>
0799 subplot(121)
0800 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);
0801 
0802 mdl = <a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>(fmdl, [16 0 1], [0.15 0.1 0.01],[],0.1);
0803 <span class="comment">% place_elec_on_surf(fmdl, [16 0 1], [0.1 0 0.01]);</span>
0804 subplot(122)
0805 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl);</pre></div>
<hr><address>Generated on Tue 12-May-2015 16:08:56 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>